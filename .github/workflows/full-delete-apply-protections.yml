name: Delete and Apply Branch Protections

on:
  workflow_dispatch:
    inputs:
      dry_run:
        type: boolean
        description: 'If "true", show what would be done without making requests'
        required: false
        default: false

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

env:
  RW_PAT: ${{ secrets.WORKFLOWS }}
  ORG: MO-test-env
  REPO_FILE: repo-config.yml
  BRANCH_PROTECTION_FILE: default-protection-config.yml

jobs:
  apply-all:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Run Python Scripts
        id: run-python
        run: |
          echo "Running minimal_yml_to_json.py on repo-config.yml"
          python minimal_yml_to_json.py ${{ env.REPO_FILE }} > minimal_repo_output.txt
          cat minimal_repo_output.txt
          
          echo "Running minimal_yml_to_json.py on branch-protection-config.yml"
          python minimal_yml_to_json.py ${{ env.BRANCH_PROTECTION_FILE }} > minimal_protection_output.txt
          cat minimal_protection_output.txt
          
          # Create outputs that can be used in the next step
          echo "minimal_repo=$(cat minimal_repo_output.txt | base64 -w 0)" >> $GITHUB_OUTPUT
          echo "minimal_protection=$(cat minimal_protection_output.txt | base64 -w 0)" >> $GITHUB_OUTPUT

      - name: Parse Repo yml into JSON
        id: parse-yml
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const org = process.env.ORG;
            // Access the outputs from the Python scripts
            const minimalRepoOutput = Buffer.from('${{ steps.run-python.outputs.minimal_repo }}', 'base64').toString();
            const minimalProtectionOutput = Buffer.from('${{ steps.run-python.outputs.minimal_protection }}', 'base64').toString();
            
            // Log the Python outputs for debugging
            core.info('Python script outputs:');
            core.info(`Minimal YAML Parser - Repo Config:\n${minimalRepoOutput}`);
            core.info(`Minimal YAML Parser - Protection Config:\n${minimalProtectionOutput}`);
            
            // Parse the JSON outputs
            const repoConfig = JSON.parse(minimalRepoOutput);
            const protectionConfig = JSON.parse(minimalProtectionOutput);

            // Process repositories to create branch protections by repo
            const branchProtectionsByRepo = {};
            
            if (repoConfig && repoConfig.repositories) {
              for (const repo of repoConfig.repositories) {
                // Extract the repository name from the first key in the repo object
                const repoName = Object.keys(repo).find(key => key !== 'default' && key !== 'locked');
                
                if (!repoName) {
                  core.warning('Found repository entry without a valid name, skipping');
                  continue;
                }
                
                // Get the repository data - either from the repo[repoName] or directly from repo
                const repoData = {
                  default: repo.default || [],
                  locked: repo.locked || []
                };
                
                let apiDefaultBranch = null;
                try {
                  const { data: repoInfo } = await github.rest.repos.get({
                    owner: org,
                    repo: repoName,
                  });
                  apiDefaultBranch = repoInfo.default_branch;
                  core.info(`API default branch for ${repoName}: ${apiDefaultBranch}`);
                } catch (error) {
                  core.warning(`Failed to get repo info for ${repoName}: ${error.message}`);
                  continue;
                }
                
                // Get default and locked branches from config or use defaults
                branchProtectionsByRepo[repoName] = {
                  default: repoData.default.length > 0 ? repoData.default : [],
                  locked: repoData.locked.length > 0 ? repoData.locked : []
                };

                // Use only api call if no branches are specified
                if (branchProtectionsByRepo[repoName].default.length === 0 && 
                    branchProtectionsByRepo[repoName].locked.length === 0 && 
                    apiDefaultBranch) {
                  const otherBranch = apiDefaultBranch === 'main' ? 'master' : 'main';
                  branchProtectionsByRepo[repoName].default = [apiDefaultBranch];
                  branchProtectionsByRepo[repoName].locked = [otherBranch];
                }

                if (apiDefaultBranch && !(branchProtectionsByRepo[repoName].default.includes(apiDefaultBranch))) {
                  core.warning(`Default branch ${apiDefaultBranch} is not in the list of default branches for ${repoName}!`);
                }
              }
            } else {
              core.error('Invalid or empty repository configuration');
            }

            // Extract protection configurations
            const defaultProtectionConfig = protectionConfig && protectionConfig.branch_protection ? protectionConfig.branch_protection : {};
            const lockedProtectionConfig = protectionConfig && protectionConfig.lock_branch_protection ? protectionConfig.lock_branch_protection : {};
            
            // Set outputs for next steps
            core.setOutput("branch-protections_by_repo", JSON.stringify(branchProtectionsByRepo));
            core.setOutput("default_protection_config", JSON.stringify(defaultProtectionConfig));
            core.setOutput("locked_protection_config", JSON.stringify(lockedProtectionConfig));

      - name: Apply 
        id: apply
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const org = process.env.ORG;
            const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            const repos = JSON.parse('${{ steps.parse-yml.outputs.branch-protections_by_repo }}');
            const defaultConfig = JSON.parse('${{ steps.parse-yml.outputs.default_protection_config }}');
            const lockedConfig = JSON.parse('${{ steps.parse-yml.outputs.locked_protection_config }}');
            
            // Helper function to delete all existing branch protections for a repo 
            const deleteBranchProtections = async (repo) => {
              try {
                core.info(`Deleting branch protections for ${org}/${repo}`);
                // Query for repository ID and all branch protection rules directly
                const repoQuery = `
                  query($owner: String!, $name: String!) {
                    repository(owner: $owner, name: $name) {
                      id
                      branchProtectionRules(first: 100) {
                        nodes {
                          id
                          pattern
                        }
                      }
                    }
                  }
                `;
                
                const repoResult = await github.graphql(repoQuery, {
                  owner: org,
                  name: repo
                });
                
                if (!repoResult.repository) {
                  throw new Error(`Repository ${org}/${repo} not found`);
                }
                
                const protectionRules = repoResult.repository.branchProtectionRules.nodes;
                core.info(`Found ${protectionRules.length} branch protection rules in ${org}/${repo}`);
                
                // Delete each protection rule
                for (const rule of protectionRules) {
                  if (dryRun) {
                    core.info(`[DRY RUN] Would delete branch protection rule with pattern: ${rule.pattern} (ID: ${rule.id})`);
                    return;
                  } else {
                    core.info(`Deleting branch protection rule with pattern: ${rule.pattern} (ID: ${rule.id})`);
                    
                    const deleteMutation = `
                      mutation($ruleId: ID!) {
                        deleteBranchProtectionRule(input: {branchProtectionRuleId: $ruleId}) {
                          clientMutationId
                        }
                      }
                    `;
                    
                    await github.graphql(deleteMutation, {
                      ruleId: rule.id
                    });
                    
                    core.info(`‚õî Successfully deleted branch protection rule with pattern: ${rule.pattern}`);
                  }
                }
                
                core.info(`All branch protection rules have been deleted for ${org}/${repo}`);
              } catch (e) {
                core.error(`‚ùå Failed to delete branch protections for ${org}/${repo}: ${e.message}`);
              }
            };

            // Helper function to apply protection to a branch using GraphQL
            const applyBranchProtection = async (repo, branch, protectionType, config) => {
              try {
                core.info(`Applying ${protectionType} protection to ${org}/${repo}@${branch}`);
                if(dryRun){
                  core.info(`[DRY RUN] Would APPLY ${protectionType} protection to ${org}/${repo}@${branch}`);
                  return;
                }
                // Get repository ID and existing rules using GraphQL
                const repoQuery = `
                  query($owner: String!, $name: String!) {
                    repository(owner: $owner, name: $name) {
                      id
                      branchProtectionRules(first: 100) {
                        nodes {
                          id
                          pattern
                        }
                      }
                    }
                  }
                `;
                
                const repoResult = await github.graphql(repoQuery, {
                  owner: org,
                  name: repo
                });
                
                if (!repoResult.repository) {
                  throw new Error(`Repository ${org}/${repo} not found`);
                }
                
                const repositoryId = repoResult.repository.id;
                const existingRules = repoResult.repository.branchProtectionRules.nodes;
                
                // Check if a rule with this pattern already exists
                const existingRule = existingRules.find(rule => rule.pattern === branch);
                
                // Delete existing rule if it exists
                if (existingRule) {
                  core.info(`Branch protection rule for pattern '${branch}' already exists. Updating...`);
                  const deleteMutation = `
                    mutation($ruleId: ID!) {
                      deleteBranchProtectionRule(input: {branchProtectionRuleId: $ruleId}) {
                        clientMutationId
                      }
                    }
                  `;
                  
                  await github.graphql(deleteMutation, {
                    ruleId: existingRule.id
                  });
                  core.info(`Deleted existing rule for pattern '${branch}'`);
                }

                // Prepare bypass actor inputs if configured
                const bypassPullRequestActorIds = [];
                
                if (protectionType === 'DEFAULT' && config.bypass_pull_request_allowances) {
                  // Get user IDs for bypass users
                  if (config.bypass_pull_request_allowances.users?.length > 0) {
                    const userQuery = `
                      query($logins: String!) {
                        search(query: $logins, type: USER, first: 100) {
                          nodes {
                            ... on User {
                              id
                              login
                            }
                          }
                        }
                      }
                    `;
                    const userResult = await github.graphql(userQuery, {
                      logins: config.bypass_pull_request_allowances.users.join(' ')
                    });
                    
                    if (userResult.search?.nodes) {
                      bypassPullRequestActorIds.push(...userResult.search.nodes.map(user => user.id));
                    }
                  }
                  
                  // Get team IDs for bypass teams
                  if (config.bypass_pull_request_allowances.teams?.length > 0) {
                    const teamQuery = `
                      query($org: String!, $teamSlugs: String!) {
                        organization(login: $org) {
                          teams(first: 100, query: $teamSlugs) {
                            nodes {
                              id
                              slug
                            }
                          }
                        }
                      }
                    `;
                    const teamResult = await github.graphql(teamQuery, {
                      org: org,
                      teamSlugs: config.bypass_pull_request_allowances.teams.join(' ')
                    });
                    
                    if (teamResult.organization?.teams?.nodes) {
                      bypassPullRequestActorIds.push(...teamResult.organization.teams.nodes.map(team => team.id));
                    }
                  }
                }
                
                // Prepare push allowance inputs if configured
                const pushActorIds = [];
                
                if (protectionType === 'DEFAULT' && config.restrictions) {
                  // Get user IDs for push allowlist
                  if (config.restrictions.users?.length > 0) {
                    const userQuery = `
                      query($logins: String!) {
                        search(query: $logins, type: USER, first: 100) {
                          nodes {
                            ... on User {
                              id
                              login
                            }
                          }
                        }
                      }
                    `;
                    const userResult = await github.graphql(userQuery, {
                      logins: config.restrictions.users.join(' ')
                    });
                    
                    if (userResult.search?.nodes) {
                      pushActorIds.push(...userResult.search.nodes.map(user => user.id));
                    }
                  }
                  
                  // Get team IDs for push allowlist
                  if (config.restrictions.teams?.length > 0) {
                    const teamQuery = `
                      query($org: String!, $teamSlugs: String!) {
                        organization(login: $org) {
                          teams(first: 100, query: $teamSlugs) {
                            nodes {
                              id
                              slug
                            }
                          }
                        }
                      }
                    `;
                    const teamResult = await github.graphql(teamQuery, {
                      org: org,
                      teamSlugs: config.restrictions.teams.join(' ')
                    });
                    
                    if (teamResult.organization?.teams?.nodes) {
                      pushActorIds.push(...teamResult.organization.teams.nodes.map(team => team.id));
                    }
                  }
                }

                // Prepare required status check contexts if configured
                const requiredStatusCheckContexts = [];
                if (protectionType === 'DEFAULT' && config.required_status_checks?.contexts?.length > 0) {
                  requiredStatusCheckContexts.push(...config.required_status_checks.contexts);
                }

                // Create branch protection rule with all options using GraphQL
                const createMutation = `
                  mutation(
                    $repositoryId: ID!,
                    $pattern: String!,
                    $requiresApprovingReviews: Boolean!,
                    $requiredApprovingReviewCount: Int,
                    $dismissesStaleReviews: Boolean,
                    $requiresCodeOwnerReviews: Boolean,
                    $requiresCommitSignatures: Boolean,
                    $isAdminEnforced: Boolean,
                    $requiresLinearHistory: Boolean,
                    $allowsForcePushes: Boolean,
                    $allowsDeletions: Boolean,
                    $blocksCreations: Boolean,
                    $requiresConversationResolution: Boolean,
                    $lockBranch: Boolean,
                    $bypassPullRequestActorIds: [ID!],
                    $pushActorIds: [ID!],
                    $requiresStatusChecks: Boolean,
                    $requiresStrictStatusChecks: Boolean,
                    $requiredStatusCheckContexts: [String!]
                  ) {
                    createBranchProtectionRule(input: {
                      repositoryId: $repositoryId,
                      pattern: $pattern,
                      requiresApprovingReviews: $requiresApprovingReviews,
                      requiredApprovingReviewCount: $requiredApprovingReviewCount,
                      dismissesStaleReviews: $dismissesStaleReviews,
                      requiresCodeOwnerReviews: $requiresCodeOwnerReviews,
                      requiresCommitSignatures: $requiresCommitSignatures,
                      isAdminEnforced: $isAdminEnforced,
                      requiresLinearHistory: $requiresLinearHistory,
                      allowsForcePushes: $allowsForcePushes,
                      allowsDeletions: $allowsDeletions,
                      blocksCreations: $blocksCreations,
                      requiresConversationResolution: $requiresConversationResolution,
                      lockBranch: $lockBranch,
                      pushActorIds: $pushActorIds,
                      bypassPullRequestActorIds: $bypassPullRequestActorIds,
                      requiresStatusChecks: $requiresStatusChecks,
                      requiresStrictStatusChecks: $requiresStrictStatusChecks,
                      requiredStatusCheckContexts: $requiredStatusCheckContexts
                    }) {
                      branchProtectionRule {
                        id
                        pattern
                        requiresApprovingReviews
                        requiredApprovingReviewCount
                        dismissesStaleReviews
                        requiresCodeOwnerReviews
                        requiresCommitSignatures
                        isAdminEnforced
                        requiresLinearHistory
                        allowsForcePushes
                        allowsDeletions
                        blocksCreations
                        requiresConversationResolution
                        lockBranch
                        bypassPullRequestAllowances(first: 10) {
                          nodes {
                            actor {
                              ... on User {
                                login
                              }
                              ... on Team {
                                name
                              }
                            }
                          }
                        }
                        pushAllowances(first: 10) {
                          nodes {
                            actor {
                              ... on User {
                                login
                              }
                              ... on Team {
                                name
                              }
                            }
                          }
                        }
                        requiredStatusCheckContexts
                      }
                    }
                  }
                `;
                
                // Create the branch protection rule with all options
                const mutationParams = {
                  repositoryId,
                  pattern: branch,
                  requiresApprovingReviews: config.required_pull_request_reviews ? true : false,
                  requiredApprovingReviewCount: config.required_pull_request_reviews?.required_approving_review_count || 0,
                  dismissesStaleReviews: config.required_pull_request_reviews?.dismiss_stale_reviews || false,
                  requiresCodeOwnerReviews: config.required_pull_request_reviews?.require_code_owner_reviews || false,
                  requiresCommitSignatures: config.required_signatures || false,
                  isAdminEnforced: config.enforce_admins || false,
                  requiresLinearHistory: config.required_linear_history || false,
                  allowsForcePushes: config.allow_force_pushes || false,
                  allowsDeletions: config.allow_deletions || false,
                  blocksCreations: config.block_creations || false,
                  requiresConversationResolution: config.required_conversation_resolution || false,
                  lockBranch: config.lock_branch || false,
                  requiresStatusChecks: !!config.required_status_checks,
                  requiresStrictStatusChecks: config.required_status_checks?.strict || false,
                  requiredStatusCheckContexts: requiredStatusCheckContexts
                };
                
                // Only add actor IDs if they exist
                if (bypassPullRequestActorIds.length > 0) {
                  mutationParams.bypassPullRequestActorIds = bypassPullRequestActorIds;
                }
                
                if (pushActorIds.length > 0) {
                  mutationParams.pushActorIds = pushActorIds;
                }
                
                const createResult = await github.graphql(createMutation, mutationParams);

              core.info(`‚úÖ Created branch protection rule for ${repo}@${branch}`);
              } catch (e) {
                core.error(`‚ùå Failed: ${repo}@${branch}: ${e.message}`);
                core.error(e.stack);
              }
            };
            
            // Helper function to delete all existing rulesets 
            const deleteAllRulesets = async (repo) =>{
              try {
                const { data: existingRulesets } = await github.rest.repos.getRepoRulesets({
                  owner: org,
                  repo: repo
                });
                
                if (existingRulesets && existingRulesets.length > 0) {
                  core.info(`Found ${existingRulesets.length} existing rulesets for ${org}/${repo}:`);
                  for (const ruleset of existingRulesets) {
                    // core.info(`- Ruleset: ${ruleset.name} (ID: ${ruleset.id})`);
                    // core.info(`  Target: ${ruleset.target}, Enforcement: ${ruleset.enforcement}`);
                    if(dryRun){
                      core.info(`[DRY RUN] Would delete ruleset ${ruleset.name} (ID: ${ruleset.id})`);
                      return;
                    }
                    else {
                      // Delete all existing rulesets
                      await github.rest.repos.deleteRepoRuleset({
                        owner: org,
                        repo: repo,
                        ruleset_id: ruleset.id
                      });
                    }
                    
                  }
                } else {
                  core.info(`No existing rulesets found for ${org}/${repo}\n`);
                }
              } catch (error) {
                core.warning(`Error reading existing rulesets for ${org}/${repo}: ${error.message}`);
              }
            }

            // Helper function to apply signature verification as a repository ruleset
            const applySignatureVerificationRuleset = async (repo) => {
              if(dryRun){
                core.info(`[DRY RUN] Would create and apply signature verification ruleset to ${org}/${repo}`);
                return;
              }
              try {
                core.info(`Applying signature verification ruleset to ${org}/${repo}`);
                
                // Check for existing rulesets with the same name
                const rulesetName = "Signature Verification Ruleset";
                try {
                  core.info(`Checking for existing rulesets named "${rulesetName}" in ${org}/${repo}`);
                  const { data: existingRulesets } = await github.rest.repos.getRepoRulesets({
                    owner: org,
                    repo: repo
                  });
                  
                  // Find ruleset with matching name
                  const existingRuleset = existingRulesets.find(ruleset => ruleset.name === rulesetName);
                  
                  if (existingRuleset) {
                    core.info(`Found existing ruleset "${rulesetName}" with ID ${existingRuleset.id}. Deleting it...`);
                    
                    // Delete the existing ruleset
                    await github.rest.repos.deleteRepoRuleset({
                      owner: org,
                      repo: repo,
                      ruleset_id: existingRuleset.id
                    });
                    
                    core.info(`Successfully deleted existing ruleset "${rulesetName}"`);
                  } else {
                    core.info(`No existing ruleset named "${rulesetName}" found in ${org}/${repo}`);
                  }
                } catch (error) {
                  core.warning(`Error checking/deleting existing rulesets: ${error.message}`);
                }
                
                // Create the ruleset payload
                const rulesetPayload = {
                  name: rulesetName,
                  target: "branch",
                  enforcement: "active",
                  bypass_actors: [{
                      actor_id: 1,
                      actor_type: "OrganizationAdmin",
                      bypass_mode: "always"
                    }],
                  conditions: {
                    ref_name: {
                      include: ["~ALL"],
                      exclude: []
                    }
                  },
                  rules: [
                    {
                      type: "required_signatures"
                    }
                  ]
                };
                
                // Create the repository ruleset using REST API
                const { data: ruleset } = await github.rest.repos.createRepoRuleset({
                  owner: org,
                  repo: repo,
                  ...rulesetPayload
                });
                
                core.info(`üîè Created signature verification ruleset for ${repo}`);
              } catch (e) {
                core.error(`‚ùå Failed to apply signature verification ruleset to ${repo}: ${e.message}`);
              }
            };

            // Primary logic to use the above functions
            for (const [repo, branches] of Object.entries(repos)) {
              core.info(`\n****** Processing ${org}/${repo}`);
              //Handle Rulesets
              await deleteAllRulesets(repo);
              core.info('');

              // Currently commented out unless TechOps requires in future
              // Apply signature verification as a repository ruleset
              // await applySignatureVerificationRuleset(repo);
              core.info('');
              
              // Delete all existing branch protections 
              await deleteBranchProtections(repo);
              core.info('');

              // Apply to default branches
              for (const branch of branches.default || []) {
                await applyBranchProtection(repo, branch, 'DEFAULT', defaultConfig);
              }
              
              // Apply to locked branches
              for (const branch of branches.locked || []) {
                await applyBranchProtection(repo, branch, 'LOCKED', lockedConfig);
              }
            }

