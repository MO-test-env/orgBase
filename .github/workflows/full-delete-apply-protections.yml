name: Delete and Apply Branch Protections

on:
  workflow_dispatch:
    inputs:
      dry_run:
        type: boolean
        description: 'If "true", show what would be done without making requests'
        required: false
        default: false

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

env:
  RW_PAT: ${{ secrets.WORKFLOWS }}
  ORG: MO-test-env
  REPO_FILE: repo-config.yml
  BRANCH_PROTECTION_FILE: default-protection-config.yml

jobs:
  apply-all:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Run Python Scripts
        id: run-python
        run: |
          echo "Running minimal_yml_to_json.py on repo-config.yml"
          python minimal_yml_to_json.py ${{ env.REPO_FILE }} > minimal_repo_output.txt
          cat minimal_repo_output.txt
          
          echo "Running minimal_yml_to_json.py on branch-protection-config.yml"
          python minimal_yml_to_json.py ${{ env.BRANCH_PROTECTION_FILE }} > minimal_protection_output.txt
          cat minimal_protection_output.txt
          
          # Create outputs that can be used in the next step
          echo "minimal_repo=$(cat minimal_repo_output.txt | base64 -w 0)" >> $GITHUB_OUTPUT
          echo "minimal_protection=$(cat minimal_protection_output.txt | base64 -w 0)" >> $GITHUB_OUTPUT

      - name: Parse Repo yml into JSON
        id: parse-yml
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const org = process.env.ORG;
            // Access the outputs from the Python scripts
            const minimalRepoOutput = Buffer.from('${{ steps.run-python.outputs.minimal_repo }}', 'base64').toString();
            const minimalProtectionOutput = Buffer.from('${{ steps.run-python.outputs.minimal_protection }}', 'base64').toString();
            
            // Log the Python outputs for debugging
            core.info('Python script outputs:');
            core.info(`Minimal YAML Parser - Repo Config:\n${minimalRepoOutput}`);
            core.info(`Minimal YAML Parser - Protection Config:\n${minimalProtectionOutput}`);
            
            // Parse the JSON outputs
            const repoConfig = JSON.parse(minimalRepoOutput);
            const protectionConfig = JSON.parse(minimalProtectionOutput);

            // Process repositories to create branch protections by repo
            const branchProtectionsByRepo = {};
            
            if (repoConfig && repoConfig.repositories) {
              for (const repo of repoConfig.repositories) {
                // Extract the repository name from the first key in the repo object
                const repoName = Object.keys(repo).find(key => key !== 'default' && key !== 'locked');
                
                if (!repoName) {
                  core.warning('Found repository entry without a valid name, skipping');
                  continue;
                }
                
                // Get the repository data - either from the repo[repoName] or directly from repo
                const repoData = {
                  default: repo.default || [],
                  locked: repo.locked || []
                };
                
                let apiDefaultBranch = null;
                try {
                  const { data: repoInfo } = await github.rest.repos.get({
                    owner: org,
                    repo: repoName,
                  });
                  apiDefaultBranch = repoInfo.default_branch;
                  core.info(`API default branch for ${repoName}: ${apiDefaultBranch}`);
                } catch (error) {
                  core.warning(`Failed to get repo info for ${repoName}: ${error.message}`);
                  continue;
                }
                
                // Get default and locked branches from config or use defaults
                branchProtectionsByRepo[repoName] = {
                  default: repoData.default.length > 0 ? repoData.default : [],
                  locked: repoData.locked.length > 0 ? repoData.locked : []
                };

                // Use only api call if no branches are specified
                if (branchProtectionsByRepo[repoName].default.length === 0 && 
                    branchProtectionsByRepo[repoName].locked.length === 0 && 
                    apiDefaultBranch) {
                  const otherBranch = apiDefaultBranch === 'main' ? 'master' : 'main';
                  branchProtectionsByRepo[repoName].default = [apiDefaultBranch];
                  branchProtectionsByRepo[repoName].locked = [otherBranch];
                }

                if (apiDefaultBranch && !(branchProtectionsByRepo[repoName].default.includes(apiDefaultBranch))) {
                  core.warning(`Default branch ${apiDefaultBranch} is not in the list of default branches for ${repoName}!`);
                }
              }
            } else {
              core.error('Invalid or empty repository configuration');
            }

            // Extract protection configurations
            const defaultProtectionConfig = protectionConfig && protectionConfig.branch_protection ? protectionConfig.branch_protection : {};
            const lockedProtectionConfig = protectionConfig && protectionConfig.lock_branch_protection ? protectionConfig.lock_branch_protection : {};
            
            // Set outputs for next steps
            core.setOutput("branch-protections_by_repo", JSON.stringify(branchProtectionsByRepo));
            core.setOutput("default_protection_config", JSON.stringify(defaultProtectionConfig));
            core.setOutput("locked_protection_config", JSON.stringify(lockedProtectionConfig));

      - name: Apply 
        id: apply
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const org = process.env.ORG;
            const dryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            const repos = JSON.parse('${{ steps.parse-yml.outputs.branch-protections_by_repo }}');
            const defaultConfig = JSON.parse('${{ steps.parse-yml.outputs.default_protection_config }}');
            const lockedConfig = JSON.parse('${{ steps.parse-yml.outputs.locked_protection_config }}');
            
            // Helper function to delete all existing branch protections for a repo 
            const deleteBranchProtections = async (repo) => {
              try {
                core.info(`Deleting branch protections for ${org}/${repo}`);
                // Query for repository ID and all branch protection rules directly
                const repoQuery = `
                  query($owner: String!, $name: String!) {
                    repository(owner: $owner, name: $name) {
                      id
                      branchProtectionRules(first: 100) {
                        nodes {
                          id
                          pattern
                        }
                      }
                    }
                  }
                `;
                
                const repoResult = await github.graphql(repoQuery, {
                  owner: org,
                  name: repo
                });
                
                if (!repoResult.repository) {
                  throw new Error(`Repository ${org}/${repo} not found`);
                }
                
                const protectionRules = repoResult.repository.branchProtectionRules.nodes;
                core.info(`Found ${protectionRules.length} branch protection rules in ${org}/${repo}`);
                
                // Delete each protection rule
                for (const rule of protectionRules) {
                  if (dryRun) {
                    core.info(`[DRY RUN] Would delete branch protection rule with pattern: ${rule.pattern} (ID: ${rule.id})`);
                    return;
                  } else {
                    core.info(`Deleting branch protection rule with pattern: ${rule.pattern} (ID: ${rule.id})`);
                    
                    const deleteMutation = `
                      mutation($ruleId: ID!) {
                        deleteBranchProtectionRule(input: {branchProtectionRuleId: $ruleId}) {
                          clientMutationId
                        }
                      }
                    `;
                    
                    await github.graphql(deleteMutation, {
                      ruleId: rule.id
                    });
                    
                    core.info(`‚õî Successfully deleted branch protection rule with pattern: ${rule.pattern}`);
                  }
                }
                
                core.info(`All branch protection rules have been deleted for ${org}/${repo}`);
              } catch (e) {
                core.error(`‚ùå Failed to delete branch protections for ${org}/${repo}: ${e.message}`);
              }
            };


            // Helper function to apply protection to a branch
            const applyBranchProtection = async (repo, branch, protectionType, config) => {
              try {
                core.info(`Applying ${protectionType} protection to ${org}/${repo}@${branch}`);
                if(dryRun){
                  core.info(`[DRY RUN] Would APPLY ${protectionType} protection to ${org}/${repo}@${branch}`);
                  return;
                }
                // Get repository ID using GraphQL
                const repoQuery = `
                  query($owner: String!, $name: String!) {
                    repository(owner: $owner, name: $name) {
                      id
                      branchProtectionRules(first: 100) {
                        nodes {
                          id
                          pattern
                        }
                      }
                    }
                  }
                `;
                
                const repoResult = await github.graphql(repoQuery, {
                  owner: org,
                  name: repo
                });
                
                if (!repoResult.repository) {
                  throw new Error(`Repository ${org}/${repo} not found`);
                }
                
                const repositoryId = repoResult.repository.id;
                const existingRules = repoResult.repository.branchProtectionRules.nodes;
                
                // Check if a rule with this pattern already exists
                const existingRule = existingRules.find(rule => rule.pattern === branch);
                
                // Because the delete job runs before this the following block should never get hit, but I wrote them separately and checking here does not hurt
                if (existingRule) {
                  core.info(`Branch protection rule for pattern '${branch}' already exists. Updating...`);
                  const deleteMutation = `
                    mutation($ruleId: ID!) {
                      deleteBranchProtectionRule(input: {branchProtectionRuleId: $ruleId}) {
                        clientMutationId
                      }
                    }
                  `;
                  
                  await github.graphql(deleteMutation, {
                    ruleId: existingRule.id
                  });
                  core.info(`Deleted existing rule for pattern '${branch}'`);
                }
                
                // Create the basic branch protection rule without bypass actors
                const minimalGraphqlConfig = {
                  requiresApprovingReviews: config.required_pull_request_reviews ? true : false,
                  requiredApprovingReviewCount: config.required_pull_request_reviews?.required_approving_review_count || 0,
                  dismissesStaleReviews: config.required_pull_request_reviews?.dismiss_stale_reviews || false,
                  requiresCodeOwnerReviews: config.required_pull_request_reviews?.require_code_owner_reviews || false,
                  requiresCommitSignatures: config.required_signatures || false,
                  isAdminEnforced: config.enforce_admins || false,
                  requiresLinearHistory: config.required_linear_history || false,
                  allowsForcePushes: config.allow_force_pushes || false,
                  allowsDeletions: config.allow_deletions || false,
                  blocksCreations: config.block_creations || false,
                  requiresConversationResolution: config.required_conversation_resolution || false,
                  lockBranch: config.lock_branch || false,
                };

                // Create branch protection rule using GraphQL (minimal version)
                const createMutation = `
                  mutation($repositoryId: ID!, $pattern: String!, $requiresApprovingReviews: Boolean!, $requiredApprovingReviewCount: Int, $dismissesStaleReviews: Boolean, $requiresCodeOwnerReviews: Boolean, $requiresCommitSignatures: Boolean, $isAdminEnforced: Boolean, $requiresLinearHistory: Boolean, $allowsForcePushes: Boolean, $allowsDeletions: Boolean, $blocksCreations: Boolean, $requiresConversationResolution: Boolean, $lockBranch: Boolean) {
                    createBranchProtectionRule(input: {
                      repositoryId: $repositoryId,
                      pattern: $pattern,
                      requiresApprovingReviews: $requiresApprovingReviews,
                      requiredApprovingReviewCount: $requiredApprovingReviewCount,
                      dismissesStaleReviews: $dismissesStaleReviews,
                      requiresCodeOwnerReviews: $requiresCodeOwnerReviews,
                      requiresCommitSignatures: $requiresCommitSignatures,
                      isAdminEnforced: $isAdminEnforced,
                      requiresLinearHistory: $requiresLinearHistory,
                      allowsForcePushes: $allowsForcePushes,
                      allowsDeletions: $allowsDeletions,
                      blocksCreations: $blocksCreations,
                      requiresConversationResolution: $requiresConversationResolution,
                      lockBranch: $lockBranch
                    }) {
                      branchProtectionRule {
                        id
                        pattern
                      }
                    }
                  }
                `;
                
                // Create the basic branch protection rule
                const createResult = await github.graphql(createMutation, {
                  repositoryId,
                  pattern: branch,
                  ...minimalGraphqlConfig,
                });
                
                if( protectionType === 'DEFAULT' ){
                  // REST API to update the rule with bypass actors and restrictions
                  const restParams = {
                    owner: org,
                    repo: repo,
                    branch: branch,
                    required_pull_request_reviews: config.required_pull_request_reviews || null,
                    enforce_admins: config.enforce_admins || null,
                    required_status_checks: config.required_status_checks || null,
                    required_linear_history: config.required_linear_history || null,
                    allow_force_pushes: config.allow_force_pushes || null,
                    allow_deletions: config.allow_deletions || null,
                    required_conversation_resolution: config.required_conversation_resolution || null,
                    lock_branch: config.lock_branch || null,
                    required_signatures: config.required_signatures || null
                  };
                  
                  // Add bypass pull request allowances if configured
                  if (config.bypass_pull_request_allowances) {
                    restParams.bypass_pull_request_allowances = {
                      users: config.bypass_pull_request_allowances.users || [],
                      teams: config.bypass_pull_request_allowances.teams || [],
                      apps: config.bypass_pull_request_allowances.apps || []
                    };
                  }
                  
                  // Add push restrictions if configured
                  if (config.restrictions) {
                    restParams.restrictions = {
                      users: config.restrictions.users || [],
                      teams: config.restrictions.teams || [],
                      apps: config.restrictions.apps || []
                    };
                  }
                  
                  // Update branch protection with REST API to add bypass actors and restrictions
                  await github.rest.repos.updateBranchProtection(restParams);
                }

              core.info(`‚úÖ Created branch protection rule for ${repo}@${branch}`);
              } catch (e) {
                core.error(`‚ùå Failed: ${repo}@${branch}: ${e.message}`);
                core.error(e.stack);
              }
            };
            
            // Helper function to delete all existing rulesets 
            const deleteAllRulesets = async (repo) =>{
              try {
                const { data: existingRulesets } = await github.rest.repos.getRepoRulesets({
                  owner: org,
                  repo: repo
                });
                
                if (existingRulesets && existingRulesets.length > 0) {
                  core.info(`Found ${existingRulesets.length} existing rulesets for ${org}/${repo}:`);
                  for (const ruleset of existingRulesets) {
                    // core.info(`- Ruleset: ${ruleset.name} (ID: ${ruleset.id})`);
                    // core.info(`  Target: ${ruleset.target}, Enforcement: ${ruleset.enforcement}`);
                    if(dryRun){
                      core.info(`[DRY RUN] Would delete ruleset ${ruleset.name} (ID: ${ruleset.id})`);
                      return;
                    }
                    else {
                      // Delete all existing rulesets
                      await github.rest.repos.deleteRepoRuleset({
                        owner: org,
                        repo: repo,
                        ruleset_id: ruleset.id
                      });
                    }
                    
                  }
                } else {
                  core.info(`No existing rulesets found for ${org}/${repo}\n`);
                }
              } catch (error) {
                core.warning(`Error reading existing rulesets for ${org}/${repo}: ${error.message}`);
              }
            }

            // Helper function to apply signature verification as a repository ruleset
            const applySignatureVerificationRuleset = async (repo) => {
              if(dryRun){
                core.info(`[DRY RUN] Would create and apply signature verification ruleset to ${org}/${repo}`);
                return;
              }
              try {
                core.info(`Applying signature verification ruleset to ${org}/${repo}`);
                
                // Check for existing rulesets with the same name
                const rulesetName = "Signature Verification Ruleset";
                try {
                  core.info(`Checking for existing rulesets named "${rulesetName}" in ${org}/${repo}`);
                  const { data: existingRulesets } = await github.rest.repos.getRepoRulesets({
                    owner: org,
                    repo: repo
                  });
                  
                  // Find ruleset with matching name
                  const existingRuleset = existingRulesets.find(ruleset => ruleset.name === rulesetName);
                  
                  if (existingRuleset) {
                    core.info(`Found existing ruleset "${rulesetName}" with ID ${existingRuleset.id}. Deleting it...`);
                    
                    // Delete the existing ruleset
                    await github.rest.repos.deleteRepoRuleset({
                      owner: org,
                      repo: repo,
                      ruleset_id: existingRuleset.id
                    });
                    
                    core.info(`Successfully deleted existing ruleset "${rulesetName}"`);
                  } else {
                    core.info(`No existing ruleset named "${rulesetName}" found in ${org}/${repo}`);
                  }
                } catch (error) {
                  core.warning(`Error checking/deleting existing rulesets: ${error.message}`);
                }
                
                // Create the ruleset payload
                const rulesetPayload = {
                  name: rulesetName,
                  target: "branch",
                  enforcement: "active",
                  bypass_actors: [{
                      actor_id: 1,
                      actor_type: "OrganizationAdmin",
                      bypass_mode: "always"
                    }],
                  conditions: {
                    ref_name: {
                      include: ["~ALL"],
                      exclude: []
                    }
                  },
                  rules: [
                    {
                      type: "required_signatures"
                    }
                  ]
                };
                
                // Create the repository ruleset using REST API
                const { data: ruleset } = await github.rest.repos.createRepoRuleset({
                  owner: org,
                  repo: repo,
                  ...rulesetPayload
                });
                
                core.info(`üîè Created signature verification ruleset for ${repo}`);
              } catch (e) {
                core.error(`‚ùå Failed to apply signature verification ruleset to ${repo}: ${e.message}`);
              }
            };

            // Primary logic to use the above functions
            for (const [repo, branches] of Object.entries(repos)) {
              core.info(`\n****** Processing ${org}/${repo}`);
              //Handle Rulesets
              await deleteAllRulesets(repo);
              core.info('');

              // Currently commented out unless TechOps requires in future
              // Apply signature verification as a repository ruleset
              // await applySignatureVerificationRuleset(repo);
              core.info('');
              
              // Delete all existing branch protections 
              await deleteBranchProtections(repo);
              core.info('');

              // Apply to default branches
              for (const branch of branches.default || []) {
                await applyBranchProtection(repo, branch, 'DEFAULT', defaultConfig);
              }
              
              // Apply to locked branches
              for (const branch of branches.locked || []) {
                await applyBranchProtection(repo, branch, 'LOCKED', lockedConfig);
              }
            }

