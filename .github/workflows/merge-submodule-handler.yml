name: Merge Submodule + Base PR (on /merge comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write
  actions: write

env:
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}
  GH_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  merge-flow:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    steps:
      # ------------------------------------------------------------------
      # 1Ô∏è‚É£ Checkout base repo (full history, **with** submodules)
      # ------------------------------------------------------------------
      - name: Checkout base repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ env.CROSS_TOKEN }}

      # ------------------------------------------------------------------
      # 2Ô∏è‚É£ Detect ALL submodules
      # ------------------------------------------------------------------
      - name: Get submodule info
        id: submods
        run: |
          SUBMODULES_JSON="[]"
          while IFS= read -r entry; do
            SUBMODULE_PATH=$(echo "$entry" | awk '{print $2}')
            SUBMODULE_URL=$(git config --file .gitmodules --get "submodule.${SUBMODULE_PATH}.url")

            # Convert URL ‚Üí owner/repo
            if [[ "$SUBMODULE_URL" == git@github.com:* ]]; then
              SUBMODULE_REPO=${SUBMODULE_URL#git@github.com:}
            elif [[ "$SUBMODULE_URL" == https://github.com/* ]]; then
              SUBMODULE_REPO=${SUBMODULE_URL#https://github.com/}
            else
              echo "‚ùå Unsupported submodule URL: $SUBMODULE_URL"
              exit 1
            fi
            SUBMODULE_REPO=${SUBMODULE_REPO%.git}

            # Append to JSON
            SUBMODULES_JSON=$(jq -c \
              --arg path "$SUBMODULE_PATH" \
              --arg repo "$SUBMODULE_REPO" \
              '. += [{"path": $path, "repo": $repo}]' <<< "$SUBMODULES_JSON")
          done < <(git config --file .gitmodules --get-regexp '^submodule\..*\.path$')

          echo "submodules=$SUBMODULES_JSON" >> $GITHUB_OUTPUT
          echo "‚úÖ Found submodules: $SUBMODULES_JSON"



      # ------------------------------------------------------------------
      # 3Ô∏è‚É£ Gather PR metadata (head ref, head repo, base branch)
      # ------------------------------------------------------------------
      - name: Get base PR metadata
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('pr_number', pr.number);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('head_repo', pr.head.repo.full_name);
            core.setOutput('base_ref', pr.base.ref);

      # ------------------------------------------------------------------
      # 4Ô∏è‚É£-6Ô∏è‚É£ Process each submodule sequentially
      # ------------------------------------------------------------------
      - name: Process submodules
        id: process_submods
        env:
          CROSS_TOKEN: ${{ env.CROSS_TOKEN }}
          SUBMODULES: ${{ steps.submods.outputs.submodules }}
          HEAD_REF: ${{ steps.pr_info.outputs.head_ref }}
          BASE_REF: ${{ steps.pr_info.outputs.base_ref }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          RESULTS=""

          for row in $(echo "$SUBMODULES" | jq -c '.[]'); do
            SUB_PATH=$(echo "$row" | jq -r '.path')
            SUB_REPO=$(echo "$row" | jq -r '.repo')
            echo "üîé Processing submodule $SUB_REPO ($SUB_PATH)"

            # Find matching PR
            PR_NUM=$(gh api repos/$SUB_REPO/pulls \
              -H "Authorization: Bearer $CROSS_TOKEN" \
              --jq ".[] | select(.head.ref==\"$HEAD_REF\") | .number" || true)

            if [[ -n "$PR_NUM" ]]; then
              echo "‚úÖ Found submodule PR #$PR_NUM"
              # Merge PR
              gh api repos/$SUB_REPO/pulls/$PR_NUM/merge \
                -H "Authorization: Bearer $CROSS_TOKEN" \
                -f merge_method=squash || { RESULTS="$RESULTS\n‚Ä¢ $SUB_REPO: merge failed ‚ùå"; exit 1; }
              echo "‚úÖ Merged submodule PR #$PR_NUM"

              # Bump pointer
              git fetch origin "$HEAD_REF"
              git checkout -B "$HEAD_REF" "origin/$HEAD_REF"
              git submodule update --init "$SUB_PATH"
              git -C "$SUB_PATH" fetch origin main
              git -C "$SUB_PATH" checkout origin/main
              git add "$SUB_PATH"
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git commit -m "chore(submod): bump $SUB_REPO to origin/main" || true
              git push "https://${CROSS_TOKEN}@github.com/$REPO.git" "$HEAD_REF" --force
              RESULTS="$RESULTS\n‚Ä¢ $SUB_REPO: merged #$PR_NUM + bumped ‚úÖ"
            else
              RESULTS="$RESULTS\n‚Ä¢ $SUB_REPO: no matching PR found ‚ÑπÔ∏è"
            fi
          done

          echo "results=$RESULTS" >> $GITHUB_OUTPUT

      # ------------------------------------------------------------------
      # 6Ô∏è‚É£ Merge base PR (only if all submodules succeeded)
      # ------------------------------------------------------------------
      - name: Merge base PR
        if: success()
        id: merge_base
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const number = parseInt('${{ steps.pr_info.outputs.pr_number }}', 10);
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: number,
            });
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: number,
              merge_method: 'squash',
              commit_title: `chore(submods): squash merge #${number}`,
              commit_message: `Squash‚Äëmerged submodule PR #${number}`,
            });
            core.info(`Merged base PR #${number}`);

      # ------------------------------------------------------------------
      # 7Ô∏è‚É£ Final comment ‚Äì success / failure 
      # ------------------------------------------------------------------
      - name: Comment success
        if: steps.merge_base.outcome == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            const results = `\n${{ steps.process_submods.outputs.results }}`;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: "Pull Request Merged ‚úÖ\n" + results,
            });

      - name: Comment failure
        if: steps.merge_base.outcome != 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: "Pull Request Not Merged ‚ùå ‚Äì see workflow logs for details."
            });