name: Merge Submodule + Base PR (on /merge comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write
  actions: write

env:
  # The token that can read/write both the base and submodule repositories
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  merge-flow:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    steps:
      # ------------------------------------------------------------------
      # 0️⃣ Resolve dynamic values (submodule repo & path) from .gitmodules
      # ------------------------------------------------------------------
      - name: Detect submodule repo and path
        id: detect_submodule
        run: |
          set -euo pipefail
          # Look for the first entry in .gitmodules – assumes a single submodule
          SUBMODULE_LINE=$(git config -f .gitmodules --list | grep '^submodule\.' | head -n1)
          SUB_NAME=${SUBMODULE_LINE%%.*}
          REPO=$(git config -f .gitmodules --get "$SUB_NAME.url")
          PATH=$(git config -f .gitmodules --get "$SUB_NAME.path")
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "path=$PATH" >> $GITHUB_OUTPUT

      - name: Export detected values
        run: |
          echo "SUBMODULE_REPO=${{ steps.detect_submodule.outputs.repo }}" >> $GITHUB_ENV
          echo "SUBMODULE_PATH=${{ steps.detect_submodule.outputs.path }}" >> $GITHUB_ENV

      # ------------------------------------------------------------------
      # 1️⃣ Checkout base repo (full history, **with** submodules)
      # ------------------------------------------------------------------
      - name: Checkout base repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true          # <-- crucial: we need the submodule directory
          token: ${{ env.CROSS_TOKEN }}

      # ------------------------------------------------------------------
      # 2️⃣ Gather PR metadata (head ref, head repo, base branch)
      # ------------------------------------------------------------------
      - name: Get base PR metadata
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('pr_number', pr.number);
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('head_repo', pr.head.repo.full_name);
            core.setOutput('base_ref', pr.base.ref);

      # ------------------------------------------------------------------
      # 3️⃣ Merge matching PR in the submodule (if it exists)
      # ------------------------------------------------------------------
      - name: Merge submodule PR (if any)
        id: merge_submodule
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            const sub = process.env.SUBMODULE_REPO;
            const [owner, repo] = sub.split('/');
            const branch = '${{ steps.pr_info.outputs.head_ref }}';
            const { data: prs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              per_page: 100
            });
            const match = prs.find(p => p.head.ref === branch);
            if (!match) {
              core.info('No submodule PR matches head ref.');
              core.setOutput('found', 'false');
              return;
            }
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: match.number,
              merge_method: 'merge'
            });
            core.info(`Merged submodule PR #${match.number}`);
            core.setOutput('found', 'true');
            core.setOutput('pr_number', match.number);

      # ------------------------------------------------------------------
      # 4️⃣ Merge the base PR (admin‑style)
      # ------------------------------------------------------------------
      - name: Merge base PR
        id: merge_base
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const number = parseInt('${{ steps.pr_info.outputs.pr_number }}', 10);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: number,
              merge_method: 'merge'
            });
            core.info(`Merged base PR #${number}`);
            core.setOutput('merged', 'true');

      # ------------------------------------------------------------------
      # 5️⃣ Bump submodule pointer on main and push
      # ------------------------------------------------------------------
      - name: Bump submodule pointer
        if: steps.merge_base.outputs.merged == 'true'
        env:
          GITHUB_TOKEN_PUSH: ${{ env.CROSS_TOKEN }}
          SUBMODULE_PATH: ${{ env.SUBMODULE_PATH }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Ensure we are on the latest main
          git checkout main
          git pull origin main

          # Create a temporary branch (will be pushed as main later)
          BUMP_BRANCH="bump-submod-$(date +%s)"
          git switch -c "$BUMP_BRANCH"

          # Update the submodule to the latest commit on its default branch
          git submodule sync "${SUBMODULE_PATH}"
          git submodule update --remote "${SUBMODULE_PATH}"

          # Stage & commit only if there is a real change
          if git diff --quiet --cached; then
            echo "Submodule already up‑to‑date – nothing to push."
            exit 0
          fi

          git add "${SUBMODULE_PATH}"
          git commit -m "chore(submod): bump submodule to latest ${SUBMODULE_REPO}"
          
          # Push fast‑forward only (force‑with‑lease guards against race conditions)
          git push "https://${GITHUB_TOKEN_PUSH}@github.com/${{ github.repository }}.git" \
            "$BUMP_BRANCH:main"

      # ------------------------------------------------------------------
      # 6️⃣ Final comment – success / failure
      # ------------------------------------------------------------------
      - name: Comment success
        if: steps.merge_base.outcome == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            const subFound = '${{ steps.merge_submodule.outputs.found }}' === 'true';
            let body = "Pull Request Merged ✅\n\n";
            if (subFound) {
              body += `• Submodule PR #${{ steps.merge_submodule.outputs.pr_number }} merged.\n`;
            } else {
              body += "• No matching submodule PR found.\n";
            }
            body += "• Base PR merged and submodule pointer bumped (if needed).\n";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body
            });

      - name: Comment failure
        if: steps.merge_base.outcome != 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: "Pull Request Not Merged ❌ – see workflow logs for details."
            });