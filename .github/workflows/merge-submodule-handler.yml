name: Merge Submodule + Base PR (on /merge comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write
  actions: write

env:
  # Change this if your submodule repo is somewhere else
  SUBMODULE_REPO: 'MOvenshire/submod'
  # token used to access both base and submodule repos (needs repo access to both)
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  handle-merge-command-2:
    if: github.event.issue.pull_request != null
    runs-on: ubuntu-latest
    steps:

      - name: Check comment is "/merge" and not from a bot
        id: check
        run: |
          set -eo pipefail
          comment_body="${{ github.event.comment.body }}"
          comment_author_type="${{ github.event.comment.user.type }}"
          echo "comment_body<<EOF" >> $GITHUB_OUTPUT
          echo "${comment_body}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          if [[ "$comment_author_type" == "Bot" ]]; then
            echo "found_merge=false" >> $GITHUB_OUTPUT
          elif [[ "$comment_body" == "/merge" ]]; then
            echo "found_merge=true" >> $GITHUB_OUTPUT
          else
            echo "found_merge=false" >> $GITHUB_OUTPUT
          fi

      - name: Edit original comment -> "Attempting to Merge PR ⏳"
        if: steps.check.outputs.found_merge == 'true'
        id: edit_comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: "Attempting to Merge PR ⏳"
            });
            core.setOutput('comment_id', commentId);

      - name: Checkout base repo (full history)
        if: steps.check.outputs.found_merge == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false
          token: ${{ secrets.WORKFLOWS }}

      - name: Get base PR metadata
        if: steps.check.outputs.found_merge == 'true'
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('head_repo_full_name', pr.head.repo.full_name);
            core.setOutput('base_ref', pr.base.ref);

      - name: Merge matching PR in submodule repo (if one exists)
        if: steps.check.outputs.found_merge == 'true'
        id: merge_submodule_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            // Find an open PR in the submodule repo whose branch name matches the base PR head ref.
            const submodule = process.env.SUBMODULE_REPO;
            const branchName = '${{ steps.pr_info.outputs.head_ref }}';
            const [subOwner, subRepo] = submodule.split('/');
            core.info(`Looking for PR in ${submodule} with head branch ${branchName}`);

            // List open PRs and try to find one whose head.ref matches branchName
            const { data: prs } = await github.rest.pulls.list({
              owner: subOwner,
              repo: subRepo,
              state: 'open',
              per_page: 100
            });

            const found = prs.find(p => p.head.ref === branchName || p.head.ref === `users/${branchName}` || p.head.ref.endsWith(`/${branchName}`));
            if (!found) {
              core.info(`No open submodule PR found for branch "${branchName}" in ${submodule}.`);
              core.setOutput('found', 'false');
              return;
            }

            core.info(`Found submodule PR #${found.number}: ${found.title}`);
            // Merge it
            await github.rest.pulls.merge({
              owner: subOwner,
              repo: subRepo,
              pull_number: found.number,
              merge_method: 'merge'
            });
            core.info(`Merged submodule PR #${found.number}`);
            core.setOutput('found', 'true');
            core.setOutput('submodule_pr_number', found.number.toString());

      - name: Merge base PR (admin-style merge)
        if: steps.check.outputs.found_merge == 'true'
        id: merge_base_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = parseInt('${{ steps.pr_info.outputs.pr_number }}', 10);
            core.info(`Merging base PR #${prNumber} in ${context.repo.owner}/${context.repo.repo}`);
            // Merge - fall back to merge method if fast-forward not possible
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'merge'
            });
            core.info(`Merged base PR #${prNumber}`);
            core.setOutput('merged', 'true');

      - name: Bump submodule pointer on main and push
        if: steps.check.outputs.found_merge == 'true' && steps.merge_base_pr.outputs.merged == 'true'
        id: bump_submodule
        env:
          GITHUB_TOKEN_PUSH: ${{ env.CROSS_TOKEN }}
          SUBMODULE_REPO: ${{ env.SUBMODULE_REPO }}
          SUBMODULE_PATH: submod   # change if your submodule path is different in the base repo
        run: |
          set -euo pipefail
          echo "Preparing to bump submodule pointer on main..."

          # ensure we have the latest main
          git fetch origin main:refs/remotes/origin/main
          git checkout origin/main
          git switch -c merge-submod-bump || git switch merge-submod-bump

          # ensure .gitmodules exists and submodule path exists
          if [ ! -f .gitmodules ]; then
            echo ".gitmodules not found in repository root. Exiting with no-op."
            exit 0
          fi

          # Derive submodule path from .gitmodules if SUBMODULE_PATH doesn't exist
          if [ ! -d "${SUBMODULE_PATH}" ]; then
            echo "Submodule path ${SUBMODULE_PATH} not present in checkout. Attempting to init submodule."
            git submodule update --init --recursive || true
          fi

          # Identify submodule default branch and latest SHA
          SUB_OWNER=$(echo "$SUBMODULE_REPO" | cut -d'/' -f1)
          SUB_REPO=$(echo "$SUBMODULE_REPO" | cut -d'/' -f2)

          # Detect default branch of submodule repo
          DEFAULT_BRANCH=$(git ls-remote --symref "https://${GITHUB_TOKEN_PUSH}@github.com/${SUB_OWNER}/${SUB_REPO}.git" HEAD | awk '/^ref:/ {gsub("refs/heads/","",$2); print $2; exit}')
          DEFAULT_BRANCH=${DEFAULT_BRANCH:-main}
          echo "Detected submodule default branch: ${DEFAULT_BRANCH}"

          LATEST_SUB_SHA=$(git ls-remote "https://${GITHUB_TOKEN_PUSH}@github.com/${SUB_OWNER}/${SUB_REPO}.git" "refs/heads/${DEFAULT_BRANCH}" | awk '{print $1}')
          if [ -z "${LATEST_SUB_SHA}" ]; then
            echo "Failed to determine latest submodule SHA. Aborting bump."
            exit 1
          fi
          echo "Latest submodule SHA on ${DEFAULT_BRANCH}: ${LATEST_SUB_SHA}"

          # If submodule dir exists, update its git dir; otherwise create an empty folder and link
          if [ -d "${SUBMODULE_PATH}" ]; then
            git -C "${SUBMODULE_PATH}" fetch "https://${GITHUB_TOKEN_PUSH}@github.com/${SUB_OWNER}/${SUB_REPO}.git" "${DEFAULT_BRANCH}"
            git -C "${SUBMODULE_PATH}" checkout "${LATEST_SUB_SHA}" || git -C "${SUBMODULE_PATH}" rev-parse --verify "${LATEST_SUB_SHA}"
          else
            # clone the specific commit into the path (shallow)
            git clone --no-checkout "https://${GITHUB_TOKEN_PUSH}@github.com/${SUB_OWNER}/${SUB_REPO}.git" "${SUBMODULE_PATH}"
            pushd "${SUBMODULE_PATH}"
            git fetch --depth=1 origin "${DEFAULT_BRANCH}"
            git checkout "${LATEST_SUB_SHA}"
            popd
          fi

          # Stage the submodule change
          git add "${SUBMODULE_PATH}"
          if git diff --cached --quiet; then
            echo "No submodule pointer change detected (already up-to-date). Nothing to push."
            exit 0
          fi

          # Commit and push bump to main
          git commit -m "chore(submod): bump submodule ${SUBMODULE_REPO} to ${LATEST_SUB_SHA}" || true
          echo "Pushing bump branch to origin/main (as a direct push to main)."
          # Use tokened URL to push
          git push "https://${GITHUB_TOKEN_PUSH}@github.com/${{ github.repository }}.git" HEAD:main

      - name: Final comment update (success)
        if: steps.check.outputs.found_merge == 'true' && (steps.merge_submodule_pr.outputs.found == 'true' || steps.merge_submodule_pr.outputs.found == 'false') && steps.merge_base_pr.outcome == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = '${{ steps.edit_comment.outputs.comment_id }}';
            let body = "Pull Request Merged ✅\n\n";
            const subFound = '${{ steps.merge_submodule_pr.outputs.found }}';
            if (subFound === 'true') {
              body += "• Submodule PR was found and merged.\n";
              body += `• Submodule PR number: #${{ steps.merge_submodule_pr.outputs.submodule_pr_number }}\n`;
            } else {
              body += "• No matching submodule PR found — proceeding with base PR merge.\n";
            }
            body += "• Base PR merged. Submodule pointer bumped on `main` (if necessary).\n";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body
            });

      - name: Final comment update (failure)
        if: steps.check.outputs.found_merge == 'true' && steps.merge_base_pr.outcome != 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = '${{ steps.edit_comment.outputs.comment_id }}';
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: "Pull Request Not Merged ❌\nCheck the workflow logs for details."
            });
