name: Create/ Link PR

on:
  pull_request:
    types: [opened, reopened, synchronize]

env:
  RW_PAT: ${{ secrets.WORKFLOWS }} # Personal Access Token with RW access to repo contents, PRs

jobs:
  # Job 1: Checkout once and discover all submodules
  discover-submodules:
    name: Discover Submodules
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.submodule.outputs.matrix }}
      has-submodules: ${{ steps.submodule.outputs.has-submodules }}
      submodules-json: ${{ steps.submodule.outputs.submodules-json }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 0
          token: ${{ env.RW_PAT }}

      - name: Authenticate submodules
        run: |
          # Rewrite relative URLs (../repo.git) to absolute GitHub URLs with token
          git config --global url."https://${RW_PAT}@github.com/".insteadOf "https://github.com/"
          git config --global url."https://${RW_PAT}@github.com/MO-test-env/".insteadOf "../"

          git submodule sync --recursive
          git submodule update --init --recursive
        env:
          RW_PAT: ${{ env.RW_PAT }}


      - name: Get changed files
        id: changed
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let files = [];
            let page = 1;
            while (true) {
              const { data } = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100,
                page
              });
              if (data.length === 0) break;
              files.push(...data.map(f => f.filename));
              page++;
            }
            core.setOutput("changed_files", JSON.stringify(files));

      - name: Read .gitmodules
        id: gitmodules
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            try {
              const { data: contentData } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.gitmodules',
                ref: context.payload.pull_request.head.sha
              });

              const decoded = Buffer.from(contentData.content, 'base64').toString();
              // Parse .gitmodules
              const regex = /\[submodule "(.*?)"\]\s+path = (.*?)\s+url = (.*?)$/gm;
              let match;
              let submodules = [];
              while ((match = regex.exec(decoded)) !== null) {
                const repoName = match[3].replace(/^.*[\\/]/, '').replace(/\.git$/i, '');
                const fullUrl = `https://github.com/MO-test-env/${repoName}`;
                submodules.push({
                  name: match[1],
                  path: match[2],
                  repo: repoName,
                  url: fullUrl
                });
              }
              core.setOutput("submodules_json", JSON.stringify(submodules));
            } catch (e) {
              core.setOutput("submodules_json", "[]");
            }

      # Filter submodules changed in this PR
      - name: Filter changed submodules
        id: detect
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const changedFilesRaw = `${{ steps.changed.outputs.changed_files }}` || '[]';
            const submodulesRaw   = `${{ steps.gitmodules.outputs.submodules_json }}` || '[]';
            core.info(`ðŸ”Ž STEPS_CHANGED_OUTPUTS_CHANGED_FILES raw: ${changedFilesRaw}`);
            core.info(`ðŸ”Ž STEPS_GITMODULES_OUTPUTS_SUBMODULES_JSON raw: ${submodulesRaw}`);

            let changedFiles, submodules;
            try {
              changedFiles = JSON.parse(changedFilesRaw);
            } catch (e) {
              core.error('Failed to parse changed files JSON');
              changedFiles = [];
            }
            try {
              submodules = JSON.parse(submodulesRaw);
            } catch (e) {
              core.error('Failed tomodules JSON');
              submodules = [];
            }

            core.info(`ðŸ”Ž Parsed changedFiles (${changedFiles.length}): ${JSON.stringify(changedFiles)}`);
            core.info(`ðŸ”Ž Parsed submodules (${submodules.length}): ${JSON.stringify(submodules)}`);

            // Filter only those submodules whose path appears in the PR file list
            const changedSubs = submodules.filter(s => {
              // Guard against missing `path` property
              if (!s?.path) return false;
              // `includes` works with exact match; trim whitespace just in case
              return changedFiles.includes(s.path.trim());
            });

            core.info(`ðŸ”Ž changedSubs (${changedSubs.length}): ${JSON.stringify(changedSubs)}`);

            // Export the filtered list for the next step
            core.setOutput("submodules_json", JSON.stringify(changedSubs));
      
      - name: Get PR base branch
        id: pr_base
        run: |
          echo "base_branch=${{ github.event.pull_request.base.ref }}" >> $GITHUB_OUTPUT


      # Create branches and PRs in submodules via REST API
      
      - name: Create Submodule PR
        uses: actions/github-script@v7
        id: create
        if: ${{ steps.submodule.outputs.has-submodules == 'true' }} 
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const baseBranch = 'main'; // Change if your base branch is different
            const prBranch = 'submodule-update-branch'; // Replace with your dynamic submodule branch

            // List all PRs for this branch
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${prBranch}`,
              base: baseBranch,
              state: 'all' // Includes open, closed, merged
            });

            // Check for existing open or merged PR
            const existingPR = prs.find(pr => pr.state === 'open' || pr.merged_at);

            if (existingPR) {
              console.log(`PR already exists or is merged: #${existingPR.number}`);
              core.setOutput('skip_create', 'true');
              core.setOutput('pr_number', existingPR.number);
            } else {
              // Create new PR
              const { data: newPR } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Update submodule ${prBranch}`,
                head: prBranch,
                base: baseBranch,
                body: 'Automated submodule update.'
              });

              console.log(`Created new PR: #${newPR.number}`);
              core.setOutput('skip_create', 'false');
              core.setOutput('pr_number', newPR.number);
            }


            - name: Post submodule list as PR comment
              uses: actions/github-script@v7
              with:
                github-token: ${{ env.RW_PAT }}
                script: |
                  const json = `${{ steps.create.outputs.final_json }}`;
                  const body = [
                    "ðŸ”Ž **Detected submodules** (cached for downstream workflows):",
                    "<!-- SUBMODULES_JSON -->",
                    "```json",
                    json,
                    "```",
                    "<!-- /SUBMODULES_JSON -->"
                  ].join("\n");

                  // Look for existing cache comment
                  const { data: comments } = await github.rest.issues.listComments({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number
                  });
                  const cacheComment = comments.find(c => c.body.includes('<!-- SUBMODULES_JSON -->'));

                  if (cacheComment) {
                    await github.rest.issues.updateComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: cacheComment.id,
                      body
                    });
                  } else {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number,
                      body
                    });
                  }

  link-and-validate:
    name: "PR Status: ${{ matrix.repo_name }}"
    needs: discover-submodules
    if: needs.discover-submodules.outputs.has-submodules == 'true'

    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
      statuses: write

    strategy:
      # Process up to 5 submodules in parallel (adjust as needed)
      fail-fast: false
      max-parallel: 5
      matrix: ${{ fromJson(needs.discover-submodules.outputs.matrix) }}
    
    steps:
      - name: Process submodule - ${{ matrix.owner }}/${{ matrix.repo_name }}
        run: |
          echo "Processing submodule: ${{ matrix.owner }}/${{ matrix.repo_name }}"
          echo "Path: ${{ matrix.path }}"
          echo "Full repo: ${{ matrix.repo }}"

      - name: Extract ticket number
        id: extract
        run: |
          BRANCH_NAME="${{ github.head_ref }}"

          # Allowed codes
          CODES="cbdit|cdc|cpse"

          TICKET_NUM=$(echo "$BRANCH_NAME" | grep -Eo "($CODES)-[0-9]+" | head -n1)

          echo "ticket_num=$TICKET_NUM" >> $GITHUB_OUTPUT
          echo "Branch: $BRANCH_NAME, Ticket: $TICKET_NUM"
      
      - name: Check for submodule PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            // const branchName = 'users/${{ steps.extract.outputs.ticket_num }}';
            const branchName = '${{ github.head_ref }}'
            const owner = '${{ matrix.owner }}';
            const repo = '${{ matrix.repo_name }}';
            const path = '${{ matrix.path }}';
            // Search for PR with matching branch
            const { data: prs } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
              state: 'open',
              head: `${owner}:${branchName}`
            });
            
            if (prs.length === 0) {
              core.setOutput('found', 'false');
              core.setOutput('pr_url', '');
              core.setOutput('pr_number', '');
              return;
            }
            
            const pr = prs[0];
            core.setOutput('found', 'true');
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('pr_number', pr.number.toString());

      - name: Create check run for submodule PR status
        id: antman
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const prUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submodulePrUrl = '${{ steps.check_pr.outputs.pr_url }}';
            core.setOutput('is_approved', 'false');
            core.setOutput('is_mergeable','false')
            
            // Check if submodules were updated in this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Get list of submodules from .gitmodules to check against
            let submodulePaths = [];
            try {
              const { data: gitmodules } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.gitmodules',
                ref: context.payload.pull_request.base.sha
              });
              
              const content = Buffer.from(gitmodules.content, 'base64').toString();
              const pathMatches = content.match(/path = (.+)/g);
              if (pathMatches) {
                submodulePaths = pathMatches.map(match => match.replace('path = ', '').trim());
              }
            } catch (error) {
              console.log('No .gitmodules found or error reading it:', error.message);
            }
            
            const submodule_updated = files.some(file => {
              // Check if .gitmodules itself was modified
              if (file.filename === '.gitmodules') {
                return true;
              }
              
              // Check if any known submodule paths were modified
              return submodulePaths.some(submodulePath => {
                return file.filename === submodulePath || file.filename.startsWith(submodulePath + '/');
              });
            });
            
            console.log(`Submodule updated: ${submodule_updated}`);

            let status, conclusion, title, summary;
            
            if (!found) {
              // search to see if submodule was updated to begin with
              if (submodule_updated) {
                status = 'completed';
                conclusion = 'failure';
                process.exit(1);
              } else {
                // No submodule updated, skip this check entirely
                status = 'completed';
                conclusion = 'success';
                process.exit(0);
              }
            } else {
              // PR found - now check if it's open and approved
              
              const urlParts = prUrl.match(/eos2git.cec.lab.emc\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
              if (!urlParts) {
                status = 'completed';
                conclusion = 'failure';
              } else {
                const [, submoduleOwner, submoduleRepo, prNumber] = urlParts;
                
                try {
                  // Get PR details
                  const { data: pr } = await github.rest.pulls.get({
                    owner: submoduleOwner,
                    repo: submoduleRepo,
                    pull_number: parseInt(prNumber)
                  });
                                    
                  // Check if PR is open
                  if (pr.state !== 'open') {
                    status = 'completed';
                    conclusion = 'failure';
                  } else {
                    // PR is open, now check approval status
                    const { data: reviews } = await github.rest.pulls.listReviews({
                      owner: submoduleOwner,
                      repo: submoduleRepo,
                      pull_number: parseInt(prNumber)
                    });
                    
                    // Get latest review from each reviewer
                    const latestReviews = {};
                    reviews.forEach(review => {
                      if (review.state !== 'COMMENTED') { // Only consider APPROVED, CHANGES_REQUESTED, DISMISSED
                        latestReviews[review.user.login] = review;
                      }
                    });
                    
                    // Check if there are any approvals and no blocking change requests
                    const approvals = Object.values(latestReviews).filter(review => review.state === 'APPROVED');
                    const changeRequests = Object.values(latestReviews).filter(review => review.state === 'CHANGES_REQUESTED');
                    
                    console.log(`Approvals: ${approvals.length}, Change Requests: ${changeRequests.length}`);
                    
                    // Check if PR is ready to merge
                    const isApproved = approvals.length > 1 && changeRequests.length === 0;
                    core.setOutput('approvals_count', approvals.length);
                    core.setOutput('change_requests_count', changeRequests.length);
                    if (isApproved) {
                      core.setOutput('is_approved', 'true');
                      core.setOutput('is_mergeable','true');
                    }
                  }
                } catch (error) {
                  console.error('Error checking PR status:', error);
                }
              }
            }
      
      - name: Add PR label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const label = found ? 'submodule-linked' : 'submodule-pending';
            const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
            console.log(`Label: ${label}, Submodule PR Status: ${isApproved}`);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // Update labels
            if(isApproved) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['ready-to-merge']
              });  
            };
      - name: Add Comment, Summarize & Validate PR Status
        if: steps.check_pr.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');  
            const summaryPath = process.env.GITHUB_STEP_SUMMARY;  

            let mergeable_display = '${{ steps.check_pr.outputs.is_mergeable }}' === "true"
            ? "ðŸŸ¢ Mergeable"
            : "â›” Blocked";

            let pr_state_display = '${{ steps.check_pr.outputs.found }}' === "true"
            ? "ðŸ“‚ Open"
            : "â“ Not Found";

            let approval_display = '${{ steps.antman.outputs.is_approved }}' === "true"
            ? "âœ… Approved"
            : `âš ï¸ Pending (${{ steps.antman.outputs.approvals_count }}/2)`;
            
            let result_display = (
            '${{ steps.antman.outputs.is_approved }}' === "true" &&
            '${{ steps.check_pr.outputs.found }}' === "true"
            )
            ? "## ðŸŽ‰ Result\nThe PR check **succeeded**. The Submodule PR is mergeable and approved."
            : "## âŒ Result\nThe PR check **failed**. One or more conditions are not satisfied.";

            // Get all existing comments first
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            console.log("number of comments: " + comments.length);

            // Look for our consolidated comment
            const consolidatedComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸ”— Linked Submodule PRs Summary')
            );

            // Build the current repo section
            const currentRepoSection = 
              `### [\`${{ matrix.repo }}\`](${{ steps.check_pr.outputs.pr_url }})\n\n` +
              `| Field | Value |\n` +
              `|-------|-------|\n` +
              `| **Directory** | \`${{ matrix.path }}\` |\n` +
              `| **Ticket** | \`${{ steps.extract.outputs.ticket_num }}\` |\n` +
              `| **PR State** | ${pr_state_display} |\n` +
              `| **Approvals** | ${approval_display} |\n` +
              `| **Change Requests** | \`${{ steps.check_pr.outputs.change_requests_count }}\` |\n\n` +
              `${result_display}\n\n` +
              `---\n\n`;

            if (consolidatedComment) {
              // Update existing consolidated comment
              console.log('Consolidated comment exists, checking if this repo is already included...');
              
              const repoMarker = `### [\`${{ matrix.repo }}\`]`;
              
              if (consolidatedComment.body.includes(repoMarker)) {
                // Replace the existing section for this repo
                console.log('Updating existing repo section...');
                
                // Find the start and end of this repo's section
                const lines = consolidatedComment.body.split('\n');
                const startIndex = lines.findIndex(line => line.includes(repoMarker));
                
                if (startIndex !== -1) {
                  // Find the next repo section or end of content
                  let endIndex = lines.length;
                  for (let i = startIndex + 1; i < lines.length; i++) {
                    if (lines[i].startsWith('### [') || lines[i] === '<!-- END_REPOS -->') {
                      endIndex = i;
                      break;
                    }
                  }
                  
                  // Replace the section
                  const beforeSection = lines.slice(0, startIndex).join('\n');
                  const afterSection = lines.slice(endIndex).join('\n');
                  const updatedBody = beforeSection + '\n' + currentRepoSection + afterSection;
                  
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: consolidatedComment.id,
                    body: updatedBody
                  });
                }
              } else {
                // Add new repo section before the end marker
                console.log('Adding new repo section...');
                
                let updatedBody;
                if (consolidatedComment.body.includes('<!-- END_REPOS -->')) {
                  // Insert before the end marker
                  updatedBody = consolidatedComment.body.replace(
                    '<!-- END_REPOS -->',
                    currentRepoSection + '<!-- END_REPOS -->'
                  );
                } else {
                  // Just append to the end
                  updatedBody = consolidatedComment.body + currentRepoSection;
                }
                
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: consolidatedComment.id,
                  body: updatedBody
                });
              }
            } else {
              // Create new consolidated comment
              console.log('Creating new consolidated comment...');
              
              const newComment = 
                "# ðŸ”— Linked Submodule PRs Summary\n\n" +
                "## ðŸ“Š Overview\n" +
                "This comment tracks all linked submodule PRs for this change.\n\n" +
                currentRepoSection +
                "<!-- END_REPOS -->";
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: newComment
              });
            }
            fs.appendFileSync(summaryPath, currentRepoSection);
            process.exit(('${{ steps.antman.outputs.is_approved }}' === "true" && '${{ steps.check_pr.outputs.found }}' === "true") ? 0 : 1);

  workflow-status:
    name: "Link PR"
    runs-on: ubuntu-latest  
    needs: [discover-submodules, link-and-validate]
    if: always()  # Always run this job
    steps:
      - name: Check results
        run: |
          if [[ "${{ needs.discover-submodules.outputs.has-submodules }}" == "false" ]]; then
            echo "## No submodules found - check passes âœ…" >> $GITHUB_STEP_SUMMARY
            exit 0
          elif [[ "${{ needs.link-and-validate.result }}" == "success" ]]; then
            echo "## ðŸŽ‰ Result" >> $GITHUB_STEP_SUMMARY
            echo "All submodule checks passed! Ready to merge with \`/merge\` command" >> $GITHUB_STEP_SUMMARY
            exit 0
          else
            echo "## âŒ Result" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ’¥ Required submodules check failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### To fix submodule conflicts: Rebase base repo branch and rebase submodule repo branch" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Commands to rebase submodule:" >> $GITHUB_STEP_SUMMARY
            echo "  \`cd <submodule-path>\`" >> $GITHUB_STEP_SUMMARY
            echo "  \`git checkout <your-branch>\`" >> $GITHUB_STEP_SUMMARY
            echo "  \`git pull --rebase origin main\`" >> $GITHUB_STEP_SUMMARY
            echo "  \`git push origin test_branch\`" >> $GITHUB_STEP_SUMMARY
            echo "  (If you pushed your branch already you need to use \`git push --force-with-lease\` flag)" >> $GITHUB_STEP_SUMMARY
            echo "  \`cd ..\`" >> $GITHUB_STEP_SUMMARY
            echo "  \`git add <submodule-path>\`" >> $GITHUB_STEP_SUMMARY
            echo "  \`git commit -m 'Bump submodule to latest main\`" >> $GITHUB_STEP_SUMMARY
            echo "  \`git push\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### If there are no conflicts, get 2 approvals and re run this job for âœ…" >> $GITHUB_STEP_SUMMARY

            exit 1
          fi