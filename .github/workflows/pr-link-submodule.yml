# .github/workflows/pr-link-submodule.yml
name: Link and Validate Submodule PR

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - main
      - master # Add your delivery target branches here we can also read this in from the pr eventually I think 

jobs:
  link-and-validate:
    runs-on: ubuntu-latest
    if: startsWith(github.head_ref, 'mo/') #ask why/ if this is necessary
    
    permissions: #set permissions for github token - it will have access to this repo github automatically creates and destroys token 1 per workflow
      contents: write
      pull-requests: write
      issues: write
      checks: write
      statuses: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0
          token: ${{ secrets.WORKFLOWS }}
      
      - name: Extract ticket number
        id: extract
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          TICKET_NUM="$BRANCH_NAME"
          echo "ticket_num=$TICKET_NUM" >> $GITHUB_OUTPUT
          echo "Branch: $BRANCH_NAME, Ticket: $TICKET_NUM"
      
      - name: Get submodule info
        id: submodule
        run: |
          # Get submodule path and URL
          SUBMODULE_PATH=$(git config --file .gitmodules --get-regexp path | awk '{ print $2 }' | head -1)
          SUBMODULE_URL=$(git config --file .gitmodules --get-regexp url | awk '{ print $2 }' | head -1)
          
          # Extract owner and repo from URL
          if [[ $SUBMODULE_URL == git@github.com:* ]]; then
            SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/git@github.com://' | sed 's/.git$//')
          elif [[ $SUBMODULE_URL == https://github.com/* ]]; then
            SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/https:\/\/github.com\///' | sed 's/.git$//')
          else
            echo "Unknown submodule URL format"
            exit 1
          fi
          
          echo "submodule_path=$SUBMODULE_PATH" >> $GITHUB_OUTPUT
          echo "submodule_repo=$SUBMODULE_REPO" >> $GITHUB_OUTPUT
          echo "Submodule: $SUBMODULE_REPO at $SUBMODULE_PATH"
      
      - name: Check for submodule PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOWS }}
          script: |
            const [owner, repo] = '${{ steps.submodule.outputs.submodule_repo }}'.split('/');
            const branchName = 'users/${{ steps.extract.outputs.ticket_num }}';
            
            // Search for PR with matching branch
            const { data: prs } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
              state: 'open',
              head: `${owner}:${branchName}`
            });
            
            if (prs.length === 0) {
              core.setOutput('found', 'false');
              core.setOutput('pr_url', '');
              core.setOutput('pr_number', '');
              return;
            }
            
            const pr = prs[0];
            core.info(`Found PR: ${pr.html_url}`);
            core.info(`Number: ${pr.number}`);
            core.info(`State: ${pr.state}`);
            core.setOutput('found', 'true');
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('pr_state', pr.state);
            

      - name: Set commit status for submodule PR
        id: marissa
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOWS }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const prUrl = '${{ steps.check_pr.outputs.pr_url }}';
            core.setOutput('is_approved', 'false');

            // Default values
            let state = 'success';
            let description = 'No submodules updated';
            let targetUrl = prUrl || '';

            // Simulate the submodule checks (simplified from your version)
            if (!found) {
              state = 'success';
              description = 'No linked submodule PR found, skipping';
            } else {
              const urlParts = prUrl.match(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
              if (!urlParts) {
                state = 'failure';
                description = `Invalid submodule PR URL: ${prUrl}`;
              } else {
                const [, subOwner, subRepo, prNumber] = urlParts;
                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: subOwner,
                    repo: subRepo,
                    pull_number: Number(prNumber)
                  });

                  if (pr.state !== 'open') {
                    state = 'failure';
                    description = `Submodule PR is ${pr.state}`;
                  } else {
                    const { data: reviews } = await github.rest.pulls.listReviews({
                      owner: subOwner,
                      repo: subRepo,
                      pull_number: Number(prNumber)
                    });

                    const latestReviews = {};
                    reviews.forEach(r => {
                      if (r.state !== 'COMMENTED') latestReviews[r.user.login] = r;
                    });

                    const approvals = Object.values(latestReviews).filter(r => r.state === 'APPROVED');
                    const changeReqs = Object.values(latestReviews).filter(r => r.state === 'CHANGES_REQUESTED');

                    if (approvals.length > 0 && changeReqs.length === 0) {
                      core.setOutput('is_approved', 'true');
                      state = 'success';
                      description = `Submodule PR approved (${approvals.length} approvals)`;
                    } else {
                      state = 'pending';
                      description = `Awaiting approval (approvals: ${approvals.length}, changes: ${changeReqs.length})`;
                    }
                  }
                } catch (err) {
                  console.error('Error checking submodule PR:', err);
                  state = 'failure';
                  description = `Error checking submodule PR: ${err.message}`;
                }
              }
            }

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state,
              context: 'Submodule PR Status',
              description,
              target_url: targetUrl
            });

      
      - name: Add PR label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOWS }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const label = found ? 'submodule-linked' : 'submodule-pending';
            const isApproved = '${{ steps.marissa.outputs.is_approved }}' === 'true';
            console.log(`Label: ${label}, Submodule PR Status: ${isApproved}`);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // Update labels
            if(isApproved) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['ready-to-merge']
              });  
            };

      - name: Add comment with submodule PR link
        if: steps.check_pr.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOWS }}
          script: |
            const prNumber = context.issue.number;
            const submodulePrUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submoduleRepo = '${{ steps.submodule.outputs.submodule_repo }}';
            const isApproved = '${{ steps.marissa.outputs.is_approved }}' === 'true';
            console.log(`Submodule PR Status: ${isApproved}`);
            var comment = "";
            if(isApproved) {
              comment = `## ðŸ”— Linked Submodule PR\n\nThis PR is linked to a submodule PR:\n- **Submodule Repository:** \`${submoduleRepo}\`\n- **Submodule PR:** ${submodulePrUrl}\n- **Status:** âœ… Closed - Ready to merge!\n\nâœ… **The linked submodule PR has been closed. This PR can now be merged.**\n\n---\n*This comment was automatically updated by the status check workflow.*`;                  
            } else {
              comment = `## ðŸ”— Linked Submodule PR
              
              This PR is linked to a submodule PR:
              - **Submodule Repository:** \`${submoduleRepo}\`
              - **Submodule PR:** ${submodulePrUrl}
              - **Status:** â³ Waiting for submodule PR to be approved
              
              âš ï¸ **Important:** This PR cannot be merged until the linked submodule PR is approved.
              
              ---
              *This comment was automatically generated by the PR linking workflow.*`;
            }
            
            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            console.log("number of comments: " + comments.length);
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Linked Submodule PR')
            );
            
            if (botComment) {
              console.log('Comment already exists');
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              console.log('Comment does not exist');
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
            }