name: Merge (on /merge comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.WORKFLOWS2 }} # Personal Access Token with RW access to repo contents, PRs
  MIN_REVIEWERS: 0
  OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}
  COMMENT_ID: ${{ github.event.comment.id }}
  PR_NUMBER: ${{ github.event.issue.number }}

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  merge-chain:
    if: |
      github.event.issue.pull_request != null &&
      github.event.issue.state == 'open' &&
      github.event.comment.user.type == 'User' &&
      github.event.comment.body == '/merge'
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Comment start 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n # üîß Merge workflow started #\n";
            appendMsg = appendMsg + `[üñ•Ô∏è View this workflow run](${runUrl})`;
            appendMsg = appendMsg + "\n**_(Step 1/5)_** Initializing \n - Checking user permissions.";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });
        
      - name: Check org membership
        id: org-membership
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            let username = context.actor;
            console.log('User:', username);
            if ( !username ) {
              core.setFailed('Username not found');
              core.setOutput("failMsg", "Workflow stopped because username could not be found.");
              return;
            }
            try {
              const membership = await github.rest.orgs.getMembershipForUser({
                org: process.env.OWNER, 
                username,
              });
              console.log('Membership state:', membership.data.state);
              console.log('Role:', membership.data.role);
              
              if (membership.data.state !== 'active') {
                core.setFailed('User is not an active org member');
                core.setOutput("failMsg", `Workflow stopped because user is not an active member of the ${process.env.OWNER} organization.`);
              }
            } catch (error) {
              console.log('Error details:', error.message);
              core.setFailed('User is not an org member');
              core.setOutput("failMsg", `Workflow stopped because user is not an member of the ${process.env.OWNER} organization.`);
            }

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = process.env.PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("title", pr.data.title);
            core.setOutput("body", pr.data.body);
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("merged", pr.data.merged);
            core.setOutput("mergeable_state", pr.data.mergeable_state);
            core.setOutput("state", pr.data.state);
            if (pr.data.merged == true){
              core.setFailed("Workflow stopped because the base PR is already merged.");
              core.setOutput("failMsg", "Workflow stopped because the base PR is already merged.");
              return;
            }

      - name: Comment on PR info success 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            let appendMsg = "\n - Successfully got PR data.\n - Reading .gitmodules file and comparing with PR diff.";
            if('${{ steps.pr.outputs.merged}}' == 'true'){
              appendMsg = "\n ## Nothing to merge. ##"
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token:       ${{ env.RW_PAT }}
          ref:         ${{ steps.pr.outputs.base_ref }}
          fetch-depth: 0
          submodules:  false

      # INIT SUBMOD INFO 
      - name: Read gitmodules file
        id: read-modules-file
        uses: actions/github-script@v7
        env:
          RW_PAT: ${{ env.RW_PAT }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const gitmodulesContent = fs.readFileSync('.gitmodules', 'utf8');
            const owner = process.env.OWNER;

            const submoduleRegex = /\[submodule "(.*)"\]\s*path = (.*)\s*url = (.*)\s*branch = (.*)/g;
            const submodules = {};
            let match;

            while ((match = submoduleRegex.exec(gitmodulesContent)) !== null) {
              const name = match[1];
              const path = match[2];
              const url = match[3];
              const branch = match[4];

              const repoName = url.replace('../', '').replace('.git', '');
              const newUrl = `https://github.com/${owner}/${repoName}.git`;

              core.info(`Found submodule: ${name} with path ${path} and url ${url}`);

              submodules[name] = {
                path,
                url: newUrl,
                branch,
                repoName: repoName,
              };
            }

            if (Object.keys(submodules).length === 0) {
              core.info("No submodules found in .gitmodules file.");
            }

            const json = JSON.stringify(submodules, null, 2);
            core.info("Submodules JSON:");
            core.info(json);
            core.setOutput('git_modules', json);
      
      - name: Config Bot user and Authenticate submodules
        id: auth
        run: |
          git checkout "${{steps.pr.outputs.head_ref}}"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule update --init --recursive
      
      # Parse PR diff and filter out unchanged submodules
      - name: Update submodules with SHA and PR branch
        id: diff-submodules
        uses: actions/github-script@v7
        env:
          GIT_MODULES: ${{ steps.read-modules-file.outputs.git_modules }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
        with:
          script: |
            const { execSync } = require('child_process');

            const gitModules = JSON.parse(process.env.GIT_MODULES);

            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };

            const diff = run(`git diff origin/${process.env.BASE_REF}...origin/${process.env.PR_BRANCH} `);

            // Parse the diff to find changed submodules and their SHAs
            let changedSubmodules = {};
            let currentFile = null;

            diff.split('\n').forEach(line => {
              const fileMatch = line.match(/^\+\+\+ b\/(.*)$/);
              const subMatch = line.match(/^\+Subproject commit ([0-9a-f]{40})$/);
              
              if (fileMatch) {
                currentFile = fileMatch[1];
              } else if (subMatch && currentFile) {
                changedSubmodules[currentFile] = subMatch[1];
              }
            });

            console.log(`Changed submodules: ${JSON.stringify(changedSubmodules, null, 2)}`);

            const updatedModules = {};
            for (const submodule in gitModules) {
              const path = gitModules[submodule].path;
              const sha = changedSubmodules[path];
              if (!sha) {
                core.info(`Removing submodule ${submodule} (path: ${path}) as it's not in the diff`);
                continue;
              }
              
              console.log(`submodule ${submodule} (path: ${path}) sha: ${sha}`);
              let prBranch = run(`git -C ${path} for-each-ref --format='%(refname:short)' refs/remotes/origin/ --points-at ${sha}`);
              if (prBranch == '')
              {
                //Fall back on just seeing if any branch contains the relevant sha (ex if user pushes a new change to branch in submodule but not update sha in base)
                prBranch = run(`git -C ${path} branch -r --contains ${sha}`);
              }
              core.info(`PR branch: *${prBranch}*`);

              if (prBranch == '')
              {
                core.setFailed('Unable to find remote branch containing the SHA');
                core.setOutput("failMsg", `Unable to find remote branch containing the SHA for submodule ${submodule} with sha ${sha}. \n Please ensure you have pushed up your branch or ensure that the base sha is pointing the right place.`);
                return;
              }
              const prBranchArr = prBranch.trim().split('\n');
              core.info(`PR branch Array: *${prBranchArr}*`);
              const defaultBranch = `origin/${gitModules[submodule].branch}`;
              console.log(`defaultBranch: ${defaultBranch}`);
              if(prBranchArr.includes(defaultBranch))
              {
                core.info('Prevent failure if the submodule is just pointing to the  default branch.');
                core.info(`Keeping submodule ${submodule}: SHA=${sha}, PR Branch=${prBranch}`);
                updatedModules[submodule] = {
                  ...gitModules[submodule],
                  sha,
                  prBranch: defaultBranch,
                };
              } else if(prBranchArr.length > 1)
              {
                core.setFailed('The submodule sha is present on multiple branches. ');
                core.setOutput("failMsg", `The submodule sha is present on multiple branches for submodule ${submodule} with sha ${sha}. \n Please ensure your base PR branch is pointing to the correct submodule sha. Delete any duplicate branches you do not want merged.`);
                return;
              }
              else 
              {
                core.info(`Keeping submodule ${submodule}: SHA=${sha}, PR Branch=${prBranch}`);
                updatedModules[submodule] = {
                  ...gitModules[submodule],
                  sha,
                  prBranch: prBranchArr[0],
                };
              }
            }

            const updatedGitModulesJSON = JSON.stringify(updatedModules, null, 2);
            core.info("Updated git_modules JSON:");
            core.info(updatedGitModulesJSON);

            core.setOutput('updated_git_modules', updatedGitModulesJSON);

      # PRE-CHECK BASE 
      - name: Confirm Approvals for base PR
        id: base-approvals
        if: ${{ steps.pr.outputs.merged == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });

            const latestByUser = {};
            for (const review of reviews) {
              latestByUser[review.user.login] = review.state;
            }
            const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
            const approvalCount = approvedUsers.length;

            console.log(` Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

            if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
              core.setFailed(` Not enough approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
              core.setOutput("failMsg", `(${approvalCount}/${process.env.MIN_REVIEWERS})`);
              return;
            } else {
              console.log(' Required approvals met.');
            }

      - name: Squash if needed and rebase onto base (with submodule conflict handling)
        if: ${{ steps.pr.outputs.state == 'open' && steps.diff-submodules.outputs.updated_git_modules != '{}' }}
        id: squash-rebase
        uses: actions/github-script@v7
        env:
          BASE: ${{ steps.pr.outputs.base_ref }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          TOKEN: ${{ env.RW_PAT }}
          GIT_MODULES: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          PR_TITLE: ${{ steps.pr.outputs.title }}
        with:
          script: |
            const { execSync } = require('child_process');

            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              console.log(`$ ${cmd}`);
              try {
                return execSync(cmd, { stdio, encoding }).trim();
              } catch (err) {
                if (!opts.allowFail) throw err;
                console.warn(`‚ö†Ô∏è Command failed (continuing): ${cmd}`);
                console.warn(err.stdout || err.message);
                return '';
              }
            };

            const baseRef = process.env.BASE;
            const headRef = process.env.PR_BRANCH;
            const prTitle = process.env.PR_TITLE;
            const gitModules = JSON.parse(process.env.GIT_MODULES);
            const submodules = Object.values(gitModules).map(m => m.path.trim().replace(/\/$/, ''));

            console.log(`Base: ${baseRef}, Head: ${headRef}`);
            console.log(`Submodules: ${submodules.join(', ')}`);

            //  Fetch latest base and head 
            run(`git fetch origin ${baseRef}:refs/remotes/origin/${baseRef}`);
            run(`git fetch origin ${headRef}:refs/remotes/origin/${headRef}`);
            run(`git checkout ${headRef}`);

            //  Squash commits only if more than one 
            const base = run(`git merge-base HEAD origin/${baseRef}`);
            const commitCount = parseInt(run(`git rev-list --count ${base}..HEAD`), 10);
            console.log(`Commit count in PR: ${commitCount}`);

            if (commitCount > 1) {
              console.log('üßπ Multiple commits detected ‚Äî performing squash.');
              const msgs = run(`git log --reverse --pretty=format:"%s%n%b" ${base}..HEAD`);
              const subject = `${prTitle} - Squash`;
              run(`git reset --soft ${base}`);
              run(`git commit -m "${subject}" -m "${msgs.replace(/"/g, '\\"')}"`);
            } else {
              console.log(' Only one commit ‚Äî skipping squash.');
            }

            //  Rebase onto base branch 
            console.log(`Starting rebase onto origin/${baseRef} ...`);
            const rebaseOutput = run(`git rebase origin/${baseRef}`, { allowFail: true });

            //  Detect and handle conflicts 
            let conflicted = run(`git diff --name-only --diff-filter=U`, { allowFail: true })
              .split('\n')
              .filter(Boolean);

            if (conflicted.length > 0) {
              console.log(`‚ö†Ô∏è Rebase conflicts detected: ${conflicted.join(', ')}`);

              const subConflicts = conflicted.filter(f =>
                submodules.some(s => f === s || f.startsWith(`${s}/`))
              );
              const nonSubConflicts = conflicted.filter(f =>
                !submodules.some(s => f === s || f.startsWith(`${s}/`))
              );

              if (nonSubConflicts.length > 0) {
                core.setFailed(`‚ùå Rebase conflicts in non-submodule files:\n${nonSubConflicts.join('\n')}`);
                process.exit(1);
              }

              if (subConflicts.length > 0) {
                console.log(`Submodule conflicts only ‚Äî auto-resolving.`);
                subConflicts.forEach(sub => run(`git add "${sub}"`));
                run(`git commit --no-edit`);
                run(`git rebase --continue`, { allowFail: true });
              }
            } else {
              console.log(' No rebase conflicts detected.');
            }

            //  Final validation and push 
            try {
              const finalRebase = run(`git rebase origin/${baseRef}`, { allowFail: true });
              if (/up to date/i.test(finalRebase) || /no rebase in progress/i.test(finalRebase)) {
                console.log('‚úÖ Branch already up to date ‚Äî skipping redundant rebase.');
              } else if (finalRebase.includes('error') || finalRebase.includes('conflict')) {
                core.setFailed('‚ùå Rebase failed ‚Äî unresolved conflicts remain.');
                process.exit(1);
              }
            } catch (err) {
              core.setFailed('‚ùå Rebase failed ‚Äî unresolved conflicts remain.');
              process.exit(1);
            }

            run(`git push --force-with-lease origin ${headRef}`);
            console.log(' Rebase and push completed successfully.');



      - name: Comment on submodule precheck
        if: ${{ steps.pr.outputs.merged == 'false' }}
        uses: actions/github-script@v7
        env:
          UPDATED_GIT_MODULES: ${{ steps.diff-submodules.outputs.updated_git_modules }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let appendMsg = "\n - Base PR has enough approvals.";
            if (`${{ steps.rebase.conclusion == 'success' }}`)
            {
              appendMsg = appendMsg + "\n - Commits squashed\n - Rebase pushed successfully resolving submodule conflicts. ";
            } else {
              appendMsg = appendMsg + "\n - Base has no conflicts. ";
            } 
            const updatedGitModules = process.env.UPDATED_GIT_MODULES || '{}';
            if ( updatedGitModules != '{}') {
              appendMsg = appendMsg + "\n - Running submodule pre-check.";
            }else {
              appendMsg = appendMsg + "\n\n - No submodules detected skipping to merge base.";
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });

      # PRE-CHECK SUBMODULES
      - name: Detect submod PR numbers and Pre-check all Submodules
        if: ${{ steps.pr.outputs.merged == 'false'  && steps.diff-submodules.outputs.updated_git_modules != '{}' }}
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          RW_PAT: ${{ env.RW_PAT }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const { execSync } = require('child_process');
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodules = [];

            for (const sub of Object.values(submods)) {
              core.info(JSON.stringify(sub, null, 2));
              let prBranch = (sub.prBranch||'')?.replace(/^origin\//, '');
              if (prBranch == sub.branch)
              {
                submodules.push({ 
                  name: sub.repoName, 
                  path: sub.path, 
                  url: sub.url, 
                  branch: sub.branch, 
                  merged: true, 
                  mergeable_state: 'clean', 
                  pr_number: '0', 
                  prBranch: 'default',
                  sha: sub.sha,
                });
                continue;
              }
              let submodulePr = await github.rest.pulls.list({
                owner: process.env.OWNER,
                repo: sub.repoName,
                head: `${process.env.OWNER}:${prBranch}`,
                base: sub.branch,
                state: 'all',
                sort: 'updated', 
                direction: 'desc',
                per_page: 3,
              });

              if(!submodulePr.data || submodulePr.data.length == 0){
                core.setFailed('No submodule PR found');
                core.setOutput("failMsg", `No submodule PR found for submodule ${sub.repoName} with branch ${sub.prBranch} and base ${sub.branch}. Please confirm you have opened all submodule PRs and your base is pointing to the top of the correct branch.`);
                return;
              } else {
                core.info(`Using most recently updated relevant found submodule PR: ${submodulePr.data[0].number}`);
                let prInfo = submodulePr.data[0];
                if(!prInfo.merged && (prInfo.mergeable_state === undefined || prInfo.mergeable_state === 'unknown') ) // retry if undefined
                {
                  for (let i = 0; i < 5; i++) {
                    console.log(`Retrying... ${i}`);
                      const miliseconds = (i+1) * 1000;
                      await new Promise(resolve => setTimeout(resolve, miliseconds));
                      const retry= await github.rest.pulls.get({
                      owner: process.env.OWNER,
                      repo: sub.repoName,
                      pull_number: prInfo.number
                    })
                    prInfo = retry.data;
                    if(prInfo.merged == 'true' || (prInfo.mergeable_state !== undefined && prInfo.mergeable_state !== 'unknown' )){
                      break;
                    }
                  }
                }

                const isMerged = prInfo.state === 'closed' && prInfo.merged === true;
                const isMergeableClean = prInfo.mergeable === true || ( prInfo.mergeable_state === 'clean' || prInfo.mergeable_state === 'unstable' );

                console.log(`üîé Submodule ${sub.repoName} PR #${prInfo.number} merged=${isMerged}, mergeable = ${prInfo.mergeable}, mergeable_state=${prInfo.mergeable_state}, state = ${prInfo.state}`);

                core.info(`Submodule ${sub.repoName} PR #${prInfo.number} (state=${prInfo.mergeable_state})`);
                if (!isMergeableClean && !isMerged) {
                  core.setFailed(`‚ùå Submodule ${sub.repoName} PR #${prInfo.number} is not mergeable (state=${prInfo.mergeable_state})`);
                  core.setOutput("failMsg", `‚ùå Submodule ${sub.repoName} PR #${prInfo.number} is not mergeable (state=${prInfo.mergeable_state})`);
                  return;
                }

                //Confirm approvals for submodule PR 
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: process.env.OWNER,
                  repo: sub.repoName,
                  pull_number: prInfo.number,
                });

                const latestByUser = {};
                for (const review of reviews) {
                  latestByUser[review.user.login] = review.state;
                }
                const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
                const approvalCount = approvedUsers.length;

                console.log(` Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

                if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
                  core.setFailed(` Not enough submodule approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
                  core.setOutput("failMsg", `Not enough submodule approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
                  return;
                }
                
                submodules.push({ 
                  name: sub.repoName, 
                  path: sub.path, 
                  url: sub.url, 
                  branch: sub.branch, 
                  merged: prInfo.merged, 
                  mergeable_state: prInfo.mergeable_state, 
                  pr_number: prInfo.number, 
                  prBranch: sub.prBranch,
                  sha: sub.sha,
                });
                core.info(`üîé Submodule ${sub.repoName} PR #${prInfo.number} merged=${isMerged}, mergeable_state=${prInfo.mergeable_state}`);
              } 
            }

            const submodulesJson = JSON.stringify(submodules, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesJson);
            core.setOutput('submodules', submodulesJson);

            // Filter only unmerged submodules
            const unmerged = submodules.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("‚ùå Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);

      - name: Comment on Pre-check Success
        if: ${{ steps.pre-check-submod.conclusion == 'success' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let newBody = comment.body;
            const unmergedSubmodules = process.env.UNMERGED_SUBMODULES;
            const ifEmptyUnmergedArr = unmergedSubmodules == "[]";
            if(!ifEmptyUnmergedArr){
              newBody += "\n\n" + "**_(Step 2/5)_** Starting to merge submodules.";
            }
            else{
              newBody += "\n\n" + "**_(Step 2/5)_** Skipping submodule merge. All submodules are already merged";
            }
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });

      # MERGE SUBMODULES
      - name: Merge Submodules
        if: ${{ steps.diff-submodules.outputs.updated_git_modules != '{}' && steps.pre-check-submod.outputs.unmerged != '[]' && steps.pre-check-submod.conclusion == 'success' }}
        id: merge-submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.pre-check-submod.outputs.unmerged }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES);
            for (const sub of submodules){
              console.info(`üîé Processing submodule: ${JSON.stringify(sub)}`);
              let retryCount = 0;
              const url = new URL(sub.url);
              const [owner, repo] = url.pathname.replace(/^\//,'').replace(/\.git$/,'').split('/');
              const pr = sub.pr_number;
              const { data: prInfo } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
              while ( retryCount < 3){
                try {
                  const res = await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: pr,
                    merge_method: "squash",
                  });
                  break;
                } catch (error) {
                  retryCount++;
                  console.error(`Failed to merge submodule ${sub.name} PR #${pr}: ${error.message}`);
                  if (retryCount === 3) {
                    throw error;
                  }
                }
              }
            }

      - name: Comment after Merging submods 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let newBody = comment.body + "\n";
            const result = "${{ steps.merge-submodules.conclusion }}";
            if( result == "skipped")
            {
              newBody = newBody + "\n\n**_(Step 3/5)_** Beginning to bump submodules for base PR branch.";
            }
            else
            {
              newBody = newBody + " - All submodules merged.\n\n**_(Step 3/5)_** Beginning to bump submodules for base PR branch.";
            }
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });
      
      # BUMP SUBSMODULES
      - name: Bump submodules
        if: ${{ steps.pre-check-submod.outputs.submodules != '[]' && steps.diff-submodules.outputs.updated_git_modules != '{}'}}
        id: bump
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.pre-check-submod.outputs.submodules  }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{steps.pr.outputs.head_ref}}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          script: |
            const { execSync } = require('child_process');
            const submodules = JSON.parse(process.env.SUBMODULES);
            let changed = false;

            execSync(`git checkout "${{steps.pr.outputs.head_ref}}"`)
            
            for (const sub of submodules) {
              const path = sub.path;
              const org = process.env.OWNER;
              const repo = sub.name;
              const urlWithToken = `https://${process.env.TOKEN}@github.com/${org}/${repo}.git`;

              // Determine branch from gitModules, default to "main"
              let branch;
              try {
                branch = sub.branch || 'main';
              } catch (e) {
                branch = 'main';
              }

              console.log(`üîß Updating submodule ${repo} at ${path} to branch ${branch}`);
              execSync(`git -C ${path} fetch origin ${branch}:${branch}`, { stdio: 'inherit' });

              const latestCommit = execSync(
                `git ls-remote ${urlWithToken} refs/heads/${branch} | awk '{print $1}'`,
                { encoding: 'utf8' }
              ).trim();

              const currentCommit = execSync(
                `git -C ${path} rev-parse HEAD`,
                { encoding: 'utf8' }
              ).trim();

              if (currentCommit !== latestCommit) {
                console.log(`‚ö†Ô∏è ${sub.name} is outdated. Resetting to ${latestCommit}`);
                execSync(`git -C ${path} reset --hard ${latestCommit}`, { stdio: 'inherit' });
                execSync(`git add ${path}`);
                changed = true;
              } else {
                console.log(`‚úÖ ${sub.name} is already up-to-date`);
              }
            }

            if (changed) {
              execSync(`git commit -m "Bump submodules to default branch from base PR ${process.env.BASE_REF}"`);
              execSync(`git push origin ${process.env.BRANCH}`);
            } else {
              console.log('‚úÖ All submodules already up-to-date.');
            }

      - name: Check base mergeability again for race conditions
        id: pr-2
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("mergeable_state", pr.data.mergeable_state);

      - name: Comment after Bump
        if: ${{ steps.bump.conclusion == 'success' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let appendMsg = "\n - Submodules bumped \n\n";
            const mergeable = "${{ steps.pr-2.outputs.mergeable }}" === "true";
            if (mergeable) {
              appendMsg = appendMsg + "**_(Step 4/5)_** Skipping final squash and rebase. (No conflicts detected)\n\n**_(Step 5/5)_** Starting to merge base."
            }
            else {
              appendMsg = appendMsg + "**_(Step 4/5)_** Starting extra auto-resolve submodule conflicts with squash and rebase."
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });
      

      # This was moved earlier in the workflow to ensure that nothing would get merged if the submodules could not be rebased cleanly. The next two steps should never have to run but they exist so that the rebase will be repeated if another user happens to push up a change within the same minute
      - name: Squash all PR commits 
        if: ${{ steps.pr-2.outputs.mergeable != 'true' }}
        id: final-squash
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const run = (cmd, options = {}) => {
              console.log(`$ ${cmd}`);
              return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...options }).trim();
            };

            try {
              const baseRef = '${{ steps.pr.outputs.base_ref }}';
              const prTitle = '${{ steps.pr.outputs.title }}';
              const headRef = '${{ steps.pr.outputs.head_ref }}';

              run(`git fetch origin ${baseRef}:refs/remotes/origin/${baseRef}`);
              // find common commit 
              const base = run(`git merge-base HEAD origin/${baseRef}`);

              const msgs = run(`git log --reverse --pretty=format:"%s%n%b" ${base}..HEAD`);
              const subject = `${prTitle} `;
              const body = msgs;

              // put all changes since common commit into working tree and commmit them 
              run(`git reset --soft ${base}`);
              run(`git commit -m "${subject}" -m "${body.replace(/"/g, '\\"')}"`);

            } catch (error) {
              console.error('‚ùå Squash step failed:', error.message);
              process.exit(1);
            }

      - name: Rebase onto base branch & resolve submodule conflicts
        id: final-rebase
        if: ${{ steps.pr-2.outputs.mergeable != 'true' && steps.squash.conclusion == 'success' }}
        uses: actions/github-script@v7
        env:
          GIT_MODULES:  ${{ steps.diff-submodules.outputs.updated_git_modules }}
        with:
          script: |
            const { execSync } = require('child_process');
            const run = (cmd, options = {}) => {
              console.log(`$ ${cmd}`);
              try {
                return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...options }).trim();
              }
              catch (err) {
                console.warn(`‚ö†Ô∏è Command failed but continuing: ${cmd}`);
                console.warn(err.stdout || err.message);
                return ''; // return empty string so the job does not immediately exit when we hit the expected merge conflict 
              }
            };

            const baseRef = '${{ steps.pr.outputs.base_ref }}';
            const headRef = '${{ steps.pr.outputs.head_ref }}';
            const gitModules = JSON.parse(process.env.GIT_MODULES);
            const submodules = gitModules ? Object.values(gitModules).map(m => m.path.trim().replace(/\/$/, '')) : [];

            run(`git checkout ${headRef}`);
            run(`git fetch origin ${baseRef}`);

            console.log(` Starting rebase onto origin/${baseRef} ...`);

            const rebaseOutput = run(`git rebase origin/${baseRef}`);
            if (rebaseOutput.includes('is up to date') || rebaseOutput.includes('Fast-forwarded')) {
              console.log(' Rebase already up to date.');
            }

            // Detect conflicted files
            const conflicted = run(`git diff --name-only --diff-filter=U`).split('\n').filter(Boolean);
            if (conflicted.length === 0) {
              console.log(' No conflicts detected.');
            }
            console.log(` Conflicts detected in: ${conflicted.join(', ')}`);

            const conflictedSubmodules = conflicted.filter(path => submodules.includes(path));
            submodules.forEach(sub => run(`git add "${sub}"`));
            run(`git commit --no-edit`);
            run(`git rebase --continue`);
            
            // confirm the base is now up to date or exit
            try {
              execSync(`git rebase origin/${baseRef}`, { stdio: 'inherit' });
            }catch (err) {
              core.setFailed("Base still has conflicts");
              return; 
            }

            run(`git push --force-with-lease origin ${headRef}`);
            console.log(' Rebase and push completed successfully.');

      # MERGE BASE
      - name: Merge base PR
        id: merge-base
        uses: actions/github-script@v7
        env:
          BRANCH: ${{steps.pr.outputs.head_ref}}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const { execSync } = require('child_process');
            await execSync(`git fetch origin ${process.env.BRANCH}`, { stdio: 'inherit' });
            const prNumber = process.env.PR_NUMBER;
            await github.rest.pulls.merge({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
              merge_method: 'squash'
            });

      - name: Comment on merge base success
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
              const { data: comment } = await github.rest.issues.getComment({
                owner: process.env.OWNER,
                repo: process.env.REPO,
                comment_id: commentId,
              });

              const appendMsg = "\n ### **üöÄ Base PR merged successfully.** ### \n";
              const newBody = comment.body + appendMsg;
              await github.rest.issues.updateComment({
                owner: process.env.OWNER,
                repo: process.env.REPO,
                comment_id: commentId,
                body: newBody,
              });

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_ORG_MEMBERSHIP: ${{ steps.org-membership.outputs.failMsg }}
          FAIL_MSG_DIFF_SUBMOD: ${{ steps.diff-submodules.outputs.failMsg }}
          FAIL_MSG_BASE_APPROVAL: ${{ steps.base-approvals.outputs.failMsg }}
          FAIL_MSG_DETECT_CONFLICTS: ${{ steps.squash-rebase.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
              if ('${{ steps.org-membership.conclusion }}' == 'failure'){
                appendMsg = process.env.FAIL_MSG_ORG_MEMBERSHIP;
                resolutionSteps = "_Please check that you have permissions to perform this action and try again later._";
              } else if ('${{ steps.pr.conclusion }}' == 'failure'){
                appendMsg = "API failed to get information on base pr.";
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.read-modules-file.conclusion }}' == 'failure'){
                appendMsg = "Failed to read the .gitmodules file.";
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.auth.conclusion }}' == 'failure'){
                appendMsg = "Failed to authenticate submodules with github. ";
                resolutionSteps = "_Please confirm you have pushed up your submodule branches._";
              } else if ('${{ steps.diff-submodules.conclusion }}' == 'failure'){
                appendMsg = "Submodule diff failed. "+ process.env.FAIL_MSG_DIFF_SUBMOD;
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.base-approvals.conclusion }}' == 'failure'){
                appendMsg = "Base PR does not have enough approvals. "+ process.env.FAIL_MSG_BASE_APPROVAL;
                resolutionSteps = "_Please ensure your code is reviewed then try again._";
              } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
                appendMsg = "Submodules failed pre-check. "+ process.env.FAIL_MSG_PRE_CHECK_SUBMOD;
                resolutionSteps = "_Please ensure there are no merge conflicts in your submodules and you have enough approvals._";
              } else if ('${{ steps.merge-submodules.conclusion }}' == 'failure'){
                appendMsg = "Submodule merge failed. ";
              } else if ('${{ steps.bump.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Submodule bump failed**";
                resolutionSteps = "_Please check the submodule configuration and try again. You can check the job logs on **Actions** tab for more information._";
              } else if ('${{ steps.squash-rebase.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Rebase failed**";
                resolutionSteps = "If the rebase fails, it's likely due to merge conflicts in the base repository. _Please manually resolve these conflicts and push the branch back to continue._";
                resolutionSteps += "\n_Please locally resolve them with a rebase or merge, push up your changes, and try again._";
              } else if ('${{ steps.merge-base.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Merge Base failed**\n The PR likely has merge conflicts. _Please manually resolve them and push the changes to this branch._";
              } else {
                appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information. ";
              };            
              
            const newBody = comment.body + "\n\n" + failureMsg+appendMsg +"\n"+resolutionSteps;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });
