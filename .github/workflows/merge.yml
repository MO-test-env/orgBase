name: Merge

on:
  workflow_call:
    inputs:
      username:
        description: 'User that triggered the workflow'
        required: true
        type: string
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  MIN_REVIEWERS: 2
  USERNAME: ${{ inputs.username }}
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

concurrency:
  group: merge-operations-${{ inputs.owner }}-${{ inputs.repo }}
  cancel-in-progress: false

jobs:
  merge-chain:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Comment start 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n # üîß Merge workflow started #\n";
            appendMsg = appendMsg + `[üñ•Ô∏è View this workflow run](${runUrl})`;
            appendMsg = appendMsg + "\n**_(Step 1/5)_** Initializing \n - Checking user permissions.";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });
        
      - name: Check User Permissions 
        id: permissions
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            let username = process.env.USERNAME;
            core.info(`User: ${username}`);
            if ( !username ) {
              core.setFailed(`Username not found`);
              core.setOutput('failMsg', 'Workflow stopped because username could not be found from github.actor');
              return;
            }
            try {
              core.info(`Confirming user has access to ${process.env.OWNER}/${process.env.REPO}`);
              // Check if user has access to the repo
              await github.rest.repos.checkCollaborator({
                owner:process.env.OWNER,
                repo: process.env.REPO,
                username
              });
              
              // Check if user is an org member
              try {
                core.info(`Checking if ${process.env.USERNAME} is a member of ${process.env.OWNER}`);
                const membership = await github.rest.orgs.getMembershipForUser({
                  org: process.env.OWNER, 
                  username,
                });
                core.info(`Membership state: ${membership.data.state}`);
                core.info(`Role: ${membership.data.role}`);
                
                if (membership.data.state !== 'active') {
                  core.setFailed(`User is not an active org member`);
                  core.setOutput("failMsg", `Workflow stopped because user is not an active member of the ${process.env.OWNER} organization.`);
                  return;
                }
                // They're an org member with repo access
                core.info(`User: ${username} is a member of ${process.env.OWNER} and allowed to merge.`);
                core.setOutput('UserType', 'internal');
                return; 

              } catch (error) {
                if (error.status === 404) {
                  // User has repo access but is not an org member so must be an external collaborator
                  core.info(`User: ${username} is a collaborator of ${process.env.OWNER} and allowed to merge.`);
                }
              }
            } catch (error) {
              if (error.status === 404) {
                // No access to repo (this should never happen)
                core.setFailed(`User does not have access to the repo`);
                core.setOutput('failMsg', 'Workflow stopped because user does not have access to the repo.');
                return;
              }
            }

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = process.env.PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("title", pr.data.title);
            core.setOutput("body", pr.data.body);
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("merged", pr.data.merged);
            core.setOutput("mergeable_state", pr.data.mergeable_state);
            core.setOutput("state", pr.data.state);

            // Confirm early stops 
            // STOP if base is already merged or closed
            if (pr.data.merged == true || pr.data.state == 'closed' ){ 
              core.setFailed("Workflow stopped because the base PR is already merged.");
              core.setOutput("failMsg", "Workflow stopped because the base PR is already merged.");
              return;
            }
            // STOP if the PR has no changes, avoid empty commits
            if( (pr.data.additions == 0 && pr.data.deletions == 0) || (pr.data.changed_files == 0) ){
              core.setFailed("Workflow stopped because the base PR has no changes.");
              core.setOutput("failMsg", "Workflow stopped because the base PR has no changes.");
              return;
            }

            // Get default branch of base repo 
            const { data: repo } = await github.rest.repos.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
            });
            core.setOutput("default_branch", repo.default_branch);
            core.setOutput("isMergeIntoDefaultBranch", pr.data.base.ref == repo.default_branch);

      - name: Comment on PR info success 
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            let appendMsg = "\n - Successfully checked user permissions and base PR data.\n - Reading .gitmodules file and determining branch strategy based on PR base_ref.";
            if('${{ steps.pr.outputs.merged}}' == 'true'){
              appendMsg = "\n ## Nothing to merge. ##"
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token:       ${{ env.RW_PAT }}
          ref:         ${{ steps.pr.outputs.base_ref }}
          fetch-depth: 0
          submodules:  false

      # INIT SUBMOD INFO 
      - name: Read gitmodules file
        id: read-modules-file
        uses: actions/github-script@v7
        env:
          RW_PAT: ${{ env.RW_PAT }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const owner = process.env.OWNER;
            const baseRef = process.env.BASE_REF;
            
            const gitmodulesContent = fs.readFileSync('.gitmodules', 'utf8');
            const gitmodulesLines = gitmodulesContent.split('\n');
            
            const submodules = {};
            let currentSubmodule = null;
            
            // Process the .gitmodules file line by line to extract all information
            gitmodulesLines.forEach(line => {
              const submoduleMatch = line.match(/\[submodule "(.*)"\]/);
              const pathMatch = line.match(/\s*path = (.*)/);
              const urlMatch = line.match(/\s*url = (.*)/);
              const branchMatch = line.match(/\s*branch = (.*)/);
              
              if (submoduleMatch) {
                currentSubmodule = submoduleMatch[1];
                submodules[currentSubmodule] = {};
              } else if (currentSubmodule && pathMatch) {
                submodules[currentSubmodule].path = pathMatch[1].trim();
              } else if (currentSubmodule && urlMatch) {
                submodules[currentSubmodule].url = urlMatch[1].trim();
              } else if (currentSubmodule && branchMatch) {
                // Store the branch from .gitmodules if it exists
                submodules[currentSubmodule].configuredBranch = branchMatch[1].trim();
                core.info(`Found configured branch in .gitmodules: ${branchMatch[1].trim()} for submodule ${currentSubmodule}`);
              }
            });
            
            // Process each submodule to set up the complete information 
            for (const name in submodules) {
              if (!submodules[name].path || !submodules[name].url) {
                core.warning(`Incomplete submodule information for ${name}, skipping`);
                delete submodules[name];
                continue;
              }
              
              // Extract repo name from URL for later API calls
              let repoName;

              // Handle different URL formats
              if (url.startsWith('https://github.com/')) {
                // HTTPS URL format: https://github.com/org/repo.git
                const parts = url.replace('https://github.com/', '').replace('.git', '').split('/');
                if (parts.length >= 2) {
                  orgName = parts[0];
                  repoName = parts[1];
                } else {
                  repoName = parts[0];
                }
              } else if (url.startsWith('git@github.com:')) {
                // SSH URL format: git@github.com:org/repo.git
                core.info('ssh');
                const parts = url.replace('git@github.com:', '').replace('.git', '').split('/');
                if (parts.length >= 2) {
                  orgName = parts[0];
                  repoName = parts[1];
                } else {
                  repoName = parts[0];
                }
              } else if (url.startsWith('../')) {
                // Relative URL format: ../repo.git
                repoName = url.replace('../', '').replace('.git', '');
                url = `https://github.com/${owner}/${repoName}.git`;
              } else {
                // Handle any other format
                const parts = url.split(/[\/:]/).filter(Boolean);
                repoName = parts[parts.length - 1].replace('.git', '');
              }

              core.info(`Processing submodule: ${name} with path ${path}, url ${url}, repoName ${repoName}`);
              submodules[name] = {
                repoName,
                path,
                url,
                configuredBranch, // again ok if undefined
              };
            }
            
            // This should never happen so log for information 
            if (Object.keys(submodules).length === 0) {
              core.info("No submodules found in .gitmodules file.");
            }
            
            const json = JSON.stringify(submodules, null, 2);
            core.info("Submodules JSON:");
            core.info(json);
            core.setOutput('git_modules', json);
      
      - name: Config Bot User
        id: auth
        run: |
          git checkout "${{steps.pr.outputs.head_ref}}"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github.com@github.com"
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
      
      # Parse PR diff and filter out unchanged submodules
      - name: Update submodules with SHA 
        id: diff-submodules
        uses: actions/github-script@v7
        env:
          GIT_MODULES: ${{ steps.read-modules-file.outputs.git_modules }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const { execSync } = require('child_process');
            const gitModules = JSON.parse(process.env.GIT_MODULES);

            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };

            const diff = run(`git diff origin/${process.env.BASE_REF}...origin/${process.env.PR_BRANCH} `);

            // Parse the diff to find changed submodules and their SHAs
            let changedSubmodules = {};
            let currentFile = null;

            diff.split('\n').forEach(line => {
              const fileMatch = line.match(/^\+\+\+ b\/(.*)$/);
              const subMatch = line.match(/^\+Subproject commit ([0-9a-f]{40})$/);
              
              if (fileMatch) {
                currentFile = fileMatch[1];
              } else if (subMatch && currentFile) {
                changedSubmodules[currentFile] = subMatch[1];
              }
            });
            console.log(`Changed submodules: ${JSON.stringify(changedSubmodules, null, 2)}`);

            const updatedModules = {};
            for (const submodule in gitModules) {
              const path = gitModules[submodule].path;
              const sha = changedSubmodules[path];
              if (!sha) {
                core.info(`Removing submodule ${submodule} (path: ${path}) as it's not in the diff`);
                continue;
              }
              // Verify the submodule sha is actually present on that remote repo (aka did the user push their branch)
              const owner = process.env.OWNER;
              const repo = gitModules[submodule].repoName;
              try {
                const res = await github.rest.repos.getCommit({ owner, repo, ref: sha });
              } catch (e) {
                if (e.status === 404) {
                  core.setFailed(`‚ùå SHA ${sha} not found in ${owner}/${repo}`);
                  core.setOutput('failMsg', `‚ùå SHA ${sha} not found in ${owner}/${repo}, Please ensure you have pushed your branch and your sha `);
                  return;
                }
                throw e;
              }
              
              console.log(`Submodule ${submodule} (path: ${path}) sha: ${sha}`);
              updatedModules[submodule] = {
                ...gitModules[submodule],
                sha,
              };
            }

            const updatedGitModulesJSON = JSON.stringify(updatedModules, null, 2);
            core.info("JSON of only submodules present in the diff and their shas :");
            core.info(updatedGitModulesJSON);
            core.setOutput('updated_git_modules', updatedGitModulesJSON);

      # PRE-CHECK BASE 
      - name: Confirm Approvals for base PR
        id: base-approvals
        if: ${{ steps.pr.outputs.merged == 'false' }}
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });

            const latestByUser = {};
            for (const review of reviews) {
              latestByUser[review.user.login] = review.state;
            }
            const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
            const approvalCount = approvedUsers.length;

            console.log(` Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

            if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
              core.setFailed(` Not enough approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
              core.setOutput("failMsg", `(${approvalCount}/${process.env.MIN_REVIEWERS})`);
              return;
            } else {
              console.log(' Required approvals met.');
            }
    
      - name: Squash if needed and rebase (with submodule conflict handling)
        if: ${{ steps.pr.outputs.state == 'open' && steps.diff-submodules.outputs.updated_git_modules != '{}' }}
        id: squash-rebase
        uses: actions/github-script@v7
        env:
          BASE: ${{ steps.pr.outputs.base_ref }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          TOKEN: ${{ env.RW_PAT }}
          GIT_MODULES: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          PR_TITLE: ${{ steps.pr.outputs.title }}
        with:
          script: |
            const { execSync } = require('child_process');

            // Helper function that pre-sets some parameters for synchronous command execution  
            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              console.log(`$ ${cmd}`);
              try {
                return execSync(cmd, { stdio, encoding }).trim();
              } catch (err) {
                // Allow graceful failure/ fall through so that submodule rebase conflicts can be resolved
                if (!opts.allowFail) throw err;
                console.warn(`‚ö†Ô∏è Command failed (continuing): ${cmd}`);
                console.warn(err.stdout || err.message);
                return '';
              }
            };

            const baseRef = process.env.BASE;
            const headRef = process.env.PR_BRANCH;
            const prTitle = process.env.PR_TITLE;
            const gitModules = JSON.parse(process.env.GIT_MODULES);
            const submodules = Object.values(gitModules).map(m => m.path.trim().replace(/\/$/, ''));

            console.log(`Base: ${baseRef}, Head: ${headRef}`);
            console.log(`Submodules: ${submodules.join(', ')}`);

            //  Fetch latest base and head 
            run(`git fetch origin ${baseRef}:refs/remotes/origin/${baseRef}`);
            run(`git fetch origin ${headRef}:refs/remotes/origin/${headRef}`);
            run(`git checkout ${headRef}`);
            run(`git submodule update --init --recursive ${submodules.join(' ')}`);

            //  Squash commits only if more than one 
            const base = run(`git merge-base HEAD origin/${baseRef}`);
            const commitCount = parseInt(run(`git rev-list --count ${base}..HEAD`), 10);
            console.log(`Commit count in PR: ${commitCount}`);

            if (commitCount > 1) {
              console.log(' Multiple commits detected ‚Äî performing squash.');
              const msgs = run(`git log --reverse --pretty=format:"%s%n%b" ${base}..HEAD`);
              const subject = `${prTitle} - Squash`;
              run(`git reset --soft ${base}`);
              run(`git commit -m "${subject}" -m "${msgs.replace(/"/g, '\\"')}"`);
            } else {
              console.log(' Only one commit ‚Äî skipping squash.');
            }

            //  Rebase onto base branch 
            console.log(`Starting rebase onto origin/${baseRef} ...`);
            const rebaseOutput = run(`git rebase origin/${baseRef}`, { allowFail: true });

            // Declare variables for conflict tracking
            let hadSubConflicts = false;
            
            //  Detect and handle conflicts 
            let conflicted = run(`git diff --name-only --diff-filter=U`, { allowFail: true }).split('\n').filter(Boolean);

            if (conflicted.length > 0) {
              console.log(`‚ö†Ô∏è Rebase conflicts detected: ${conflicted.join(', ')}`);

              const subConflicts = conflicted.filter(f => submodules.some(s => f === s || f.startsWith(`${s}/`)));
              const nonSubConflicts = conflicted.filter(f => !submodules.some(s => f === s || f.startsWith(`${s}/`)));
              
              // Set flag if we have submodule conflicts
              hadSubConflicts = subConflicts.length > 0;

              if (nonSubConflicts.length > 0) {
                core.setFailed(`‚ùå Rebase conflicts in non-submodule files:\n${nonSubConflicts.join('\n')}`);
                core.setOutput("failMsg", `Workflow stopped because rebase conflicts in non-submodule files:\n${nonSubConflicts.join('\n')}`);
                process.exit(1);
              }

              if (subConflicts.length > 0) {
                console.log(`Submodule conflicts only ‚Äî auto-resolving.`);
                subConflicts.forEach(sub => run(`git add "${sub}"`));
                run(`git commit --no-edit`); // Already set the commit message with squash above so no need to change
                run(`git rebase --continue`, { allowFail: true });
              }
            } else {
              console.log(' No rebase conflicts detected.');
            }

            //  Final validation and push 
            let rebaseSuccessful = false;

            // Try one more rebase command to ensure that there are no more conflicts and the previous was successful
            try {
              const finalRebase = run(`git rebase origin/${baseRef}`, { allowFail: true });
              if (/up to date/i.test(finalRebase) || /no rebase in progress/i.test(finalRebase)) {
                console.log(' Branch already up to date ‚Äî Confirmed no more conflicts.');
                rebaseSuccessful = true;
              } else if (finalRebase.includes('error') || finalRebase.includes('conflict')) {
                core.setFailed('‚ùå Rebase failed ‚Äî unresolved conflicts remain.');
                core.setOutput("failMsg", `Unresolved conflicts remain after rebase.`);
                process.exit(1);
              } else {
                rebaseSuccessful = true;
              }
            } catch (err) {
              core.setFailed('‚ùå Rebase failed ‚Äî unresolved conflicts remain.');
              core.setOutput("failMsg", `Unresolved conflicts remain after rebase.`);
              process.exit(1);
            }

            // Only force push if there were submodule conflicts that were resolved successfully
            if (hadSubConflicts && rebaseSuccessful) {
              console.log('Pushing changes with --force-with-lease because submodule conflicts were resolved');
              run(`git push --force-with-lease origin ${headRef}`);
              console.log(' Rebase and force push completed successfully.');
            } else {
              console.log(' No changes pushed to remote.');
            }

      - name: Comment on submodule precheck
        if: ${{ steps.pr.outputs.merged == 'false' }}
        uses: actions/github-script@v7
        env:
          UPDATED_GIT_MODULES: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          BASE_STATE: ${{ steps.pr.outputs.state }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let appendMsg = "\n - Base PR has enough approvals.";

            const updatedGitModules = process.env.UPDATED_GIT_MODULES || '{}';
            const baseState = process.env.BASE_STATE || '';
            if ( updatedGitModules != '{}') {
              if ( baseState == 'open' )
              {
                appendMsg +="\n - Commits squashed\n - Rebase pushed successfully to resolve submodule conflicts. ";
              }
              appendMsg = appendMsg + "\n - Running submodule pre-check.";
            }else {
              appendMsg = appendMsg + "\n - No submodules detected skipping to merge base.";
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });

      # PRE-CHECK SUBMODULES
      - name: Detect submod PR numbers and Pre-check all Submodules
        if: ${{ steps.pr.outputs.merged == 'false'  && steps.diff-submodules.outputs.updated_git_modules != '{}' }}
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          RW_PAT: ${{ env.RW_PAT }}
          BASE_REPO_TGT_BRANCH: ${{ steps.pr.outputs.base_ref }}
          BASE_DEFAULT_BRANCH: ${{ steps.pr.outputs.default_branch }}
          IS_MERGE_INTO_DEFAULT_BRANCH: ${{ steps.pr.outputs.isMergeIntoDefaultBranch }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const { execSync } = require('child_process');
            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodules = {};

            // Loop through all submodules to try and get the PR number for each submodule
            for (const sub of Object.values(submods)) {
              core.info(JSON.stringify(sub, null, 2));
              let foundPr = false;
              let prNumber = null;
              let prInfo = null;
              try {
                let tgtBranch = process.env.BASE_REPO_TGT_BRANCH;
                if ( process.env.IS_MERGE_INTO_DEFAULT_BRANCH ) {
                  let repoInfo = await github.rest.repos.get({
                    owner: process.env.OWNER,
                    repo: sub.repoName,
                  });
                  let subDefaultBranch = repoInfo.data.default_branch;
                  tgtBranch = subDefaultBranch;
                }

                // Try to find PR by commit SHA first (should work even if the sha is not head of branch) but only if PR is open
                const prsWithCommit = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: process.env.OWNER,
                  repo: sub.repoName,
                  commit_sha: sub.sha,
                });
                let prsFromSha = prsWithCommit.data;
                console.info(`Found ${prsFromSha.length} PRs for commit ${sub.sha}`);
                if (prsFromSha.length == 1) {
                  foundPr = true;
                  prNumber = prsFromSha[0].number;
                  prInfo = prsFromSha[0];
                } else {
                  // Fallback if there is either 0 or multiple open PR found 
                  run(`git submodule update --init "${sub.path}"`);
                  let prBranch = run(`git -C ${sub.path} for-each-ref --format='%(refname:short)' refs/remotes/origin/ --points-at ${sub.sha}`);
                  if (prBranch == '')
                  {
                  //Fall back on just seeing if any branch contains the relevant sha (ex if user pushes a new change to branch in submodule but not update sha in base)
                  prBranch = run(`git -C ${sub.path} branch -r --contains ${sub.sha}`);
                  }
                  core.info(`PR branch: *${prBranch}*`);

                  if (prBranch == '')
                  {
                  core.setFailed('Unable to find remote branch containing the SHA');
                  core.setOutput("failMsg", `Unable to find remote branch containing the SHA for submodule ${sub.repoName} with sha ${sub.sha}. \n Please ensure you have pushed up your branch or ensure that the base sha is pointing the right place.`);
                  return;
                  }
                  let prBranchArr = [];
                  let cleanedBranchNames = prBranch.trim().replace(/\n/g,",").split(",").map(b => b.trim()).filter(b => b != '');
                  console.info(`Branch names: ${cleanedBranchNames}`);
                  cleanedBranchNames.forEach(raw => {
                      let branch = raw.replace("origin/","");
                        prBranchArr.push(branch);
                  });
                  core.info(`Normalized branches as Arr: ${prBranchArr.join(', ')}`)
                  if(prBranchArr.includes(tgtBranch)){
                    foundPr = true;
                    prNumber = 0;
                    prInfo = null;
                    core.info(`Code is already on target branch no PR needed`);
                  } else {
                    if(prBranchArr.length == 1){
                      let branchPrs = await github.rest.pulls.list({
                        owner: process.env.OWNER,
                        repo: sub.repoName,
                        head: `${process.env.OWNER}:${prBranchArr[0]}`,
                        state: 'all',
                        sort: 'updated', 
                        direction: 'desc',
                        per_page: 3,
                      });
                      let prsFromBranch = branchPrs.data;
                      console.info(`Found ${prsFromBranch.length} PRs for branch ${prBranchArr[0]}`);
                      if (prsFromBranch.length == 1) {
                        foundPr = true;
                        prNumber = prsFromBranch[0].number;
                        prInfo = prsFromBranch[0];
                      } else {
                        core.setFailed('Unable to find PR for submodule and sha does not appear to already be delivered');
                        core.setOutput("failMsg", `Unable to find PR for submodule ${sub.repoName} and sha does not appear to be previously delivered. \n Please ensure you have pushed up your branch or ensure that the base sha is pointing the right place.`);
                        return;
                      }
                    }
                  }
                  if (prBranchArr.length > 1 && !foundPr ) {
                    core.setFailed('The submodule sha is present on multiple branches. ');
                    core.setOutput("failMsg", `The submodule sha is present on multiple branches for multiple open PRs for submodule ${sub.repoName} with sha ${sub.sha}. \n Please close any duplicate PRs.`);
                    return;
                  }
                }

                // Start actual pre-check to validate enough approvals and no conflicts
                if (foundPr && prNumber > 0)
                {
                  const { data: reviews } = await github.rest.pulls.listReviews({
                    owner: process.env.OWNER,
                    repo: sub.repoName,
                    pull_number: prNumber,
                  });

                  // Re-try loop if the mergeable or mergeable state are undefined - just means those values were still loading when api call was made
                  let retryCount = 0;
                  while(retryCount < 5 && !prInfo.merged && (prInfo.mergeable_state === undefined || prInfo.mergeable_state === 'unknown') ) // retry if undefined
                  {
                    retryCount++;
                    console.log(`Retrying... ${retryCount}`);
                    const miliseconds = (retryCount+1) * 1000;
                    await new Promise(resolve => setTimeout(resolve, miliseconds));
                    const retry= await github.rest.pulls.get({
                      owner: process.env.OWNER,
                      repo: sub.repoName,
                      pull_number: prNumber
                    })
                    prInfo = retry.data;
                  }
                  if (tgtBranch != prInfo.base.ref)
                  {
                    core.warning(`Submodule ${sub.repoName} PR #${prInfo.number}, with base branch ${prInfo.base.ref} does not match expected target branch ${tgtBranch}`);
                  }

                  const latestByUser = {};
                  for (const review of reviews) {
                    latestByUser[review.user.login] = review.state;
                  }
                  const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
                  const approvalCount = approvedUsers.length;
                  const changeRequestCount = Object.values(latestByUser).filter(s => s === 'CHANGES_REQUESTED').length;
                  const prState = prInfo.merged_at ? 'merged' : prInfo.state === 'closed' ? 'closed' : 'open';
                  
                  const isMerged = prInfo.state === 'closed' && prInfo.merged === true;
                  const isMergeableClean = prInfo.mergeable === true || (prInfo.mergeable_state === 'clean' || prInfo.mergeable_state === 'unstable');

                  console.log(`üîé Submodule ${sub.repoName} PR #${prInfo.number} merged=${isMerged}, mergeable = ${prInfo.mergeable}, mergeable_state=${prInfo.mergeable_state}, state = ${prInfo.state}`);

                  core.info(`Submodule ${sub.repoName} PR #${prInfo.number} (state=${prInfo.mergeable_state})`);
                  if (!isMergeableClean && !isMerged) {
                    core.setFailed(`‚ùå Submodule ${sub.repoName} PR #${prInfo.number} is not mergeable (state=${prInfo.mergeable_state})`);
                    core.setOutput("failMsg", `‚ùå Submodule ${sub.repoName} PR #${prInfo.number} is not mergeable (state=${prInfo.mergeable_state})`);
                    return;
                  }

                  console.log(` Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

                  if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
                    core.setFailed(` Not enough submodule approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
                    core.setOutput("failMsg", `Not enough submodule approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
                    return;
                  }
                  

                  submodules[sub.repoName] = {
                    ...sub,
                    name: sub.repoName,
                    pr_number: prInfo.number,
                    approvals: approvalCount,
                    changeRequests: changeRequestCount,
                    prState: prState,
                    merged: prInfo.merged,
                    mergeable_state: prInfo.mergeable_state,
                    merged_sha: prInfo.merged ? prInfo.merge_commit_sha : null,
                    base_branch: prInfo.base.ref
                  };
                  core.info(`üîé Submodule ${sub.repoName} PR #${prInfo.number} merged=${isMerged}, mergeable_state=${prInfo.mergeable_state}`);
                }
                if (foundPr && prNumber == 0) //submod already merged
                {
                  core.info(`Submodule ${sub.repoName} is already merged adding placeholder to previously delivered code. `);
                  submodules[sub.repoName] = {
                    ...sub,
                    name: sub.repoName,
                    pr_number: 0,
                    approvals: process.env.MIN_REVIEWERS,
                    prState: 'closed',
                    merged: true,
                    mergeable_state: 'clean',
                    merged_sha: sub.sha,
                    base_branch: tgtBranch
                  };
                }
              } catch (error) {
                console.log(`Error processing submodule ${sub.repoName}: ${error.message}`);
                core.setFailed(`Error processing submodule ${sub.repoName}: ${error.message}`);
                core.setOutput("failMsg", `Error processing submodule ${sub.repoName}: ${error.message}`);
                return;
              }
            }

            const submodulesArray = Object.values(submodules);
            const submodulesJson = JSON.stringify(submodulesArray, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesJson);
            core.setOutput('submodules', submodulesJson);

            // Filter only unmerged submodules
            const unmerged = submodulesArray.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);

      - name: Comment on Pre-check Success
        if: ${{ steps.pre-check-submod.conclusion == 'success' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let newBody = comment.body;
            const unmergedSubmodules = process.env.UNMERGED_SUBMODULES;
            const ifEmptyUnmergedArr = unmergedSubmodules == "[]";
            if(!ifEmptyUnmergedArr){
              newBody += "\n\n" + "**_(Step 2/5)_** Starting to merge submodules.";
            }
            else{
              newBody += "\n\n" + "**_(Step 2/5)_** Skipping submodule merge. All submodules are already merged";
            }
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });

      # MERGE SUBMODULES
      - name: Merge Submodules
        if: ${{ steps.diff-submodules.outputs.updated_git_modules != '{}' && steps.pre-check-submod.outputs.unmerged != '[]' && steps.pre-check-submod.conclusion == 'success' }}
        id: merge-submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.pre-check-submod.outputs.unmerged }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES);
            const mergeResults = [];
            
            for (const sub of submodules){
              console.info(`üîé Processing submodule: ${JSON.stringify(sub)}`);
              let retryCount = 0;
              const url = new URL(sub.url);
              const [owner, repo] = url.pathname.replace(/^\//,'').replace(/\.git$/,'').split('/');
              const pr = sub.pr_number;
              const { data: prInfo } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
              
              // Check if merge would be an empty commit
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner,
                repo,
                base: prInfo.base.sha,
                head: prInfo.head.sha
              });
              
              if (comparison.files.length === 0 && comparison.commits.length === 0) {
                console.log(`‚ö†Ô∏è Skipping merge of ${sub.name} PR #${pr} as it would result in an empty commit. Closing submodule PR. User can reopen if needed`);
                mergeResults.push({
                  name: sub.name,
                  pr: pr,
                  merged: false,
                  skipped: true,
                  reason: 'empty_commit'
                });
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: prNumber,
                  state: 'closed'
                });
                continue;
              }
              
              // Proceed with merge
              while (retryCount < 3){
                // This should never need to happen more than once, but sometimes api calls fail so looping adds some additional certainty. 
                try {
                  const res = await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: pr,
                    merge_method: "squash",
                  });
                  
                  // Save the merged SHA
                  mergeResults.push({
                    name: sub.name,
                    pr: pr,
                    merged: true,
                    merged_sha: res.data.sha,
                    message: res.data.message
                  });
                  break;
                } catch (error) {
                  retryCount++;
                  console.error(`Failed to merge submodule ${sub.name} PR #${pr}: ${error.message}`);
                  if (retryCount === 3) {
                    mergeResults.push({
                      name: sub.name,
                      pr: pr,
                      merged: false,
                      error: error.message
                    });
                    throw error;
                  }
                }
              }
            }
            
            // Output merge results
            const mergeResultsJson = JSON.stringify(mergeResults, null, 2);
            core.info("Merge results:");
            core.info(mergeResultsJson);
            core.setOutput('merge_results', mergeResultsJson);

      - name: Comment after Merging submods 
        uses: actions/github-script@v7
        env:
          MERGE_RESULTS: ${{ steps.merge-submodules.outputs.merge_results }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            
            let newBody = comment.body + "\n";
            const result = "${{ steps.merge-submodules.conclusion }}";
            
            // Add details about merge results if available
            if (process.env.MERGE_RESULTS) {
              try {
                const mergeResults = JSON.parse(process.env.MERGE_RESULTS);
                if (mergeResults.length > 0) {
                  newBody += "\n**Submodule merge details:**\n";
                  
                  for (const result of mergeResults) {
                    if (result.skipped) {
                      newBody += `- ‚ö†Ô∏è Skipped ${result.name} PR #${result.pr}: ${result.reason === 'empty_commit' ? 'Would result in empty commit' : result.reason}\n`;
                    } else if (result.merged) {
                      newBody += `- Merged ${result.name} PR # ${result.pr} (SHA: ${result.merged_sha.substring(0, 7)})\n`;
                    } else {
                      newBody += `- Failed to merge ${result.name} PR #${result.pr}: ${result.error || 'Unknown error'}\n`;
                    }
                  }
                }
              } catch (error) {
                console.error(`Error parsing merge results: ${error.message}`);
              }
            }
            if( result == "skipped")
            {
              newBody = newBody + "\n\n**_(Step 3/5)_** Beginning to bump submodules for base PR branch.";
            }
            else
            {
              newBody = newBody + " - All submodules merged.\n\n**_(Step 3/5)_** Beginning to bump submodules for base PR branch.";
            }
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });
      
      # BUMP SUBSMODULES
      - name: Bump submodules
        if: ${{ steps.pre-check-submod.outputs.submodules != '[]' && steps.diff-submodules.outputs.updated_git_modules != '{}'}}
        id: bump
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.pre-check-submod.outputs.submodules  }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{steps.pr.outputs.head_ref}}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            // API calls were the most lightweight and fastest way to do this logic. If you are curious about trees vs branches vs commits vs subtrees vs raw refs, there are some great online resources or I am happy to chat and talk through it. 
            const { execSync } = require('child_process');
            const submodules = JSON.parse(process.env.SUBMODULES);
            const headRef = process.env.BRANCH;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            
            // Get the current commit SHA for the branch
            const { data: refData } = await github.rest.git.getRef({
              owner,
              repo,
              ref: `heads/${headRef}`
            });
            const currentBranchSha = refData.object.sha;
            
            // Get the current tree
            const { data: commitData } = await github.rest.git.getCommit({
              owner,
              repo,
              commit_sha: currentBranchSha
            });
            const currentTreeSha = commitData.tree.sha;
            
            // Prepare tree updates for submodules
            const treeUpdates = [];
            let needsUpdate = false;
            
            // Process each submodule
            for (const sub of submodules) {
              const path = sub.path;
              const subOwner = owner;
              const subRepo = sub.name;
              const branch = sub.base_branch;
              
              console.log(`üîß Processing submodule ${subRepo} at path ${path} on branch ${branch}`);
              
              try {
                // Get the latest commit on the branch 
                const { data: branchData } = await github.rest.repos.getBranch({
                  owner: subOwner,
                  repo: subRepo,
                  branch: branch
                });
                
                const latestCommit = branchData.commit.sha;
                console.log(`Latest commit on ${branch} for ${subRepo}: ${latestCommit}`);
                
                // Get current submodule commit if possible
                let currentCommit = '';
                try {
                  // Try to get the current submodule commit from the tree
                  const { data: treeData } = await github.rest.git.getTree({
                    owner,
                    repo,
                    tree_sha: currentTreeSha,
                    recursive: 1
                  });
                  
                  const submoduleItem = treeData.tree.find(item => 
                    item.path === path && item.type === 'commit'
                  );
                  
                  if (submoduleItem) {
                    currentCommit = submoduleItem.sha;
                    console.log(`Current commit for ${path}: ${currentCommit}`);
                  }
                } catch (e) {
                  console.log(`Could not determine current commit for ${path}: ${e.message}`);
                }
                
                // If submodule needs updating
                if (currentCommit !== latestCommit) {
                  console.log(`‚ö†Ô∏è Submodule ${subRepo} needs update from ${currentCommit || 'unknown'} to ${latestCommit}`);
                  
                  // Add to tree updates
                  treeUpdates.push({
                    path: path,
                    mode: '160000', // Submodule mode - have probably seen this when committing or doing diff locally 
                    type: 'commit',
                    sha: latestCommit
                  });
                  
                  needsUpdate = true;
                  //NOTE nothing up here is actually pushing to your PR branch. 
                } else {
                  console.log(`‚úÖ Submodule ${subRepo} is already up-to-date at ${currentCommit}`);
                }
              } catch (error) {
                console.log(`‚ö†Ô∏è Error processing submodule ${subRepo}: ${error.message}`);
              }
            }
            
            // If any submodules need updating, create a new commit
            // This should basically always happen but protects from extraneous commits  
            if (needsUpdate) {
              try {
                // Create a new tree based on the treeUpdates we initialized and pushed to above
                const { data: newTree } = await github.rest.git.createTree({
                  owner,
                  repo,
                  base_tree: currentTreeSha,
                  tree: treeUpdates
                });
                
                // Create a commit
                const { data: newCommit } = await github.rest.git.createCommit({
                  owner,
                  repo,
                  message: `Bump submodules to default branch from base PR ${process.env.BASE_REF}`,
                  tree: newTree.sha,
                  parents: [currentBranchSha]
                });
                
                // Update the PR branch reference with the new tree 
                await github.rest.git.updateRef({
                  owner,
                  repo,
                  ref: `heads/${headRef}`,
                  sha: newCommit.sha,
                  force: false
                });
                
                console.log(`‚úÖ Successfully updated submodules with commit ${newCommit.sha}`);
                core.setOutput('updated', 'true');
                core.setOutput('commit_sha', newCommit.sha);
              } catch (error) {
                console.log(`‚ùå Error updating submodules: ${error.message}`);
                core.setFailed(`Failed to update submodules: ${error.message}`);
              }
            } else {
              console.log('‚úÖ All submodules already up-to-date.');
              core.setOutput('updated', 'false');
            }

      - name: Check base mergeability again for race conditions
        id: pr-2
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("mergeable_state", pr.data.mergeable_state);

      - name: Comment after Bump
        if: ${{ steps.bump.conclusion == 'success' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            let appendMsg = "\n - Submodules bumped \n\n";
            const mergeable = "${{ steps.pr-2.outputs.mergeable }}" === "true";
            if (mergeable) {
              appendMsg = appendMsg + "**_(Step 4/5)_** Skipping extra auto-resolve submodule conflicts with squash and rebase. (No conflicts detected)\n\n**_(Step 5/5)_** Starting to merge base."
            }
            else {
              appendMsg = appendMsg + "**_(Step 4/5)_** Starting extra auto-resolve submodule conflicts with squash and rebase."
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });

      # This was moved earlier in the workflow to ensure that nothing would get merged if the submodules could not be rebased cleanly. The next two steps should never have to run but they exist so that the rebase will be repeated if another user happens to push up a change within the same few minutes and hopefully prevent race conditions. Simply re-run if race conditions do occur and this backup fails. 
      - name: Squash all PR commits 
        if: ${{ steps.pr-2.outputs.mergeable != 'true' }}
        id: final-squash
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const run = (cmd, options = {}) => {
              console.log(`$ ${cmd}`);
              return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...options }).trim();
            };

            try {
              const baseRef = '${{ steps.pr.outputs.base_ref }}';
              const prTitle = '${{ steps.pr.outputs.title }}';
              const headRef = '${{ steps.pr.outputs.head_ref }}';

              run(`git fetch origin ${baseRef}:refs/remotes/origin/${baseRef}`);
              // find common commit 
              const base = run(`git merge-base HEAD origin/${baseRef}`);

              const msgs = run(`git log --reverse --pretty=format:"%s%n%b" ${base}..HEAD`);
              const subject = `${prTitle} `;
              const body = msgs;

              // put all changes since common commit into working tree and commmit them 
              run(`git reset --soft ${base}`);
              run(`git commit -m "${subject}" -m "${body.replace(/"/g, '\\"')}"`);

            } catch (error) {
              console.error('‚ùå Squash step failed:', error.message);
              process.exit(1);
            }

      - name: Rebase onto base branch & resolve submodule conflicts
        id: final-rebase
        if: ${{ steps.pr-2.outputs.mergeable != 'true' && steps.final-squash.conclusion == 'success' }}
        uses: actions/github-script@v7
        env:
          GIT_MODULES:  ${{ steps.diff-submodules.outputs.updated_git_modules }}
        with:
          script: |
            const { execSync } = require('child_process');
            const run = (cmd, options = {}) => {
              console.log(`$ ${cmd}`);
              try {
                return execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...options }).trim();
              }
              catch (err) {
                console.warn(`‚ö†Ô∏è Command failed but continuing: ${cmd}`);
                console.warn(err.stdout || err.message);
                return ''; // return empty string so the job does not immediately exit when we hit the expected merge conflict 
              }
            };

            const baseRef = '${{ steps.pr.outputs.base_ref }}';
            const headRef = '${{ steps.pr.outputs.head_ref }}';
            const gitModules = JSON.parse(process.env.GIT_MODULES);
            const submodules = gitModules ? Object.values(gitModules).map(m => m.path.trim().replace(/\/$/, '')) : [];

            run(`git checkout ${headRef}`);
            run(`git fetch origin ${baseRef}`);

            console.log(` Starting rebase onto origin/${baseRef} ...`);

            const rebaseOutput = run(`git rebase origin/${baseRef}`);
            if (rebaseOutput.includes('is up to date') || rebaseOutput.includes('Fast-forwarded')) {
              console.log(' Rebase already up to date.');
            }

            // Detect conflicted files
            const conflicted = run(`git diff --name-only --diff-filter=U`).split('\n').filter(Boolean);
            if (conflicted.length === 0) {
              console.log(' No conflicts detected.');
            }
            console.log(` Conflicts detected in: ${conflicted.join(', ')}`);

            const conflictedSubmodules = conflicted.filter(path => submodules.includes(path));
            submodules.forEach(sub => run(`git add "${sub}"`));
            run(`git commit --no-edit`);
            run(`git rebase --continue`);
            
            // confirm the base is now up to date or exit
            try {
              execSync(`git rebase origin/${baseRef}`, { stdio: 'inherit' });
            }catch (err) {
              core.setFailed("Base still has conflicts");
              return; 
            }

            run(`git push --force-with-lease origin ${headRef}`);
            console.log(' Rebase and push completed successfully.');

      - name: Comment after Rebase
        if: ${{ steps.pr-2.outputs.mergeable != 'true' && steps.final-rebase.conclusion == 'success' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            const appendMsg = "\n - Rebase pushed successfully. \n\n**_(Step 5/5)_** Starting to merge base.";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });
            
      # MERGE BASE
      - name: Merge base PR
        id: merge-base
        uses: actions/github-script@v7
        env:
          BRANCH: ${{steps.pr.outputs.head_ref}}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const { execSync } = require('child_process');
            await execSync(`git fetch origin ${process.env.BRANCH}`, { stdio: 'inherit' });
            const prNumber = process.env.PR_NUMBER;
            // Option to add a loop here. Again alternative is user re-runs because submodules will register as merged and not cause issues. 
            await github.rest.pulls.merge({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
              merge_method: 'squash'
            });

      - name: Comment on merge base success
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
              const { data: comment } = await github.rest.issues.getComment({
                owner: process.env.OWNER,
                repo: process.env.REPO,
                comment_id: commentId,
              });

              const appendMsg = "\n ### **üöÄ Base PR merged successfully.** ### \n";
              const newBody = comment.body + appendMsg;
              await github.rest.issues.updateComment({
                owner: process.env.OWNER,
                repo: process.env.REPO,
                comment_id: commentId,
                body: newBody,
              });

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_PERMISSIONS: ${{ steps.permissions.outputs.failMsg }}
          FAIL_MSG_PR: ${{ steps.pr.outputs.failMsg }}
          FAIL_MSG_DIFF_SUBMOD: ${{ steps.diff-submodules.outputs.failMsg }}
          FAIL_MSG_BASE_APPROVAL: ${{ steps.base-approvals.outputs.failMsg }}
          FAIL_MSG_SQUASH_REBASE: ${{ steps.squash-rebase.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
              if ('${{ steps.permissions.conclusion }}' == 'failure'){
                appendMsg = process.env.FAIL_MSG_PERMISSIONS;
                resolutionSteps = "_Please check that you have permissions to perform this action and try again later._";
              } else if ('${{ steps.pr.conclusion }}' == 'failure'){
                appendMsg = "API failed to get information on base pr.";
                if (process.env.FAIL_MSG_PR)
                {
                  appendMsg = process.env.FAIL_MSG_PR 
                }
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.read-modules-file.conclusion }}' == 'failure'){
                appendMsg = "Failed to read the .gitmodules file.";
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.auth.conclusion }}' == 'failure'){
                appendMsg = "Failed to authenticate submodules with github. ";
                resolutionSteps = "_Please confirm you have pushed up your submodule branches._";
              } else if ('${{ steps.diff-submodules.conclusion }}' == 'failure'){
                appendMsg = "Submodule diff failed. "+ process.env.FAIL_MSG_DIFF_SUBMOD;
                resolutionSteps = "_Please try again later._";
              } else if ('${{ steps.base-approvals.conclusion }}' == 'failure'){
                appendMsg = "Base PR does not have enough approvals. "+ process.env.FAIL_MSG_BASE_APPROVAL;
                resolutionSteps = "_Please ensure your code is reviewed then try again._";
              } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
                appendMsg = "Submodules failed pre-check. "+ process.env.FAIL_MSG_PRE_CHECK_SUBMOD;
                resolutionSteps = "_Please ensure there are no merge conflicts in your submodules and you have enough approvals._";
              } else if ('${{ steps.merge-submodules.conclusion }}' == 'failure'){
                appendMsg = "Submodule merge failed. ";
              } else if ('${{ steps.bump.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Submodule bump failed**";
                resolutionSteps = "_Please check the submodule configuration and try again. You can check the job logs on **Actions** tab for more information._";
              } else if ('${{ steps.squash-rebase.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Rebase failed**";
                resolutionSteps = process.env.FAIL_MSG_SQUASH_REBASE;
                resolutionSteps += "\n_Please locally resolve conflicts with a rebase or merge, push up your changes, and try again._";
              } else if ('${{ steps.merge-base.conclusion }}' == 'failure') {
                failureMsg = "‚ùå **Job Merge Base failed**\n The PR likely has merge conflicts. _Please manually resolve them and push the changes to this branch._";
              } else {
                appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information. ";
              };            
              
            const newBody = comment.body + "\n\n" + failureMsg+appendMsg +"\n"+resolutionSteps;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });
