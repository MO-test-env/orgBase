name: Auto-Revert Submodules + Base PR

on:
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: write
  issues: write
  actions: write

env:
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  detect-submodules:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      submodules: ${{ steps.extract.outputs.submodules }}
    steps:
      - id: extract
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            const cache = comments.find(c => /<!-- SUBMODULES_JSON -->/.test(c.body));
            if (!cache) { core.setOutput("submodules", "[]"); return; }
            const jsonMatch = cache.body.match(/```json\s*([\s\S]*?)\s*```/);
            core.setOutput('submodules', jsonMatch ? jsonMatch[1] : "[]");

  revert-submodules:
    needs: detect-submodules
    if: needs.detect-submodules.outputs.submodules != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        submod: ${{ fromJson(needs.detect-submodules.outputs.submodules) }}
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\/|\.git$/g,'').split('/');
            const prNumber = sub.pr_number;

            core.info(`üîç Processing PR #${prNumber} in ${repo}`);

            // Get PR Node ID via GraphQL
            const prNodeQuery = `
              query($owner: String!, $repo: String!, $prNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $prNumber) {
                    id
                    merged
                  }
                }
              }
            `;
            const prNodeResp = await github.graphql(prNodeQuery, {
              owner,
              repo,
              prNumber
            });

            const prNode = prNodeResp.repository.pullRequest;
            if (!prNode.merged) {
              core.info(`‚ö†Ô∏è PR #${prNumber} in ${repo} is not merged. Skipping.`);
              return;
            }
            const prNodeId = prNode.id;
            core.info(`PR Node ID for #${prNumber}: ${prNodeId}`);

            // Check if a revert PR already exists
            const { data: openPRs } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              sort: 'created',
              direction: 'desc',
              per_page: 20
            });

            let revertPR = openPRs.find(p =>
              p.title.includes(`Revert "${prNumber}"`) || p.body?.includes(`#${prNumber}`)
            );

            // If no existing revert PR, create it via GraphQL
            if (!revertPR) {
              core.info(`No existing revert PR found for #${prNumber}, creating...`);
              try {
                await github.graphql(`
                  mutation($input: RevertPullRequestInput!) {
                    revertPullRequest(input: $input) {
                      pullRequest {
                        id
                      }
                    }
                  }
                `, { input: { pullRequestId: prNodeId } });

                // Wait briefly to allow the new PR to appear in REST
                await new Promise(resolve => setTimeout(resolve, 3000));

                const { data: recentPRs } = await github.rest.pulls.list({
                  owner,
                  repo,
                  state: 'open',
                  sort: 'created',
                  direction: 'desc',
                  per_page: 5
                });

                revertPR = recentPRs.find(p =>
                  p.title.includes(`Revert "${prNumber}"`) || p.body?.includes(`#${prNumber}`)
                );

                if (!revertPR) throw new Error(`‚ùå Could not find revert PR after creating it for PR #${prNumber}`);
                core.info(`üîÑ Created revert PR #${revertPR.number}`);
              } catch (err) {
                // Handle race condition where GitHub already created a revert PR
                if (err.message.includes('Validation failed: A pull request already exists')) {
                  core.info(`‚ö†Ô∏è A revert PR already exists for #${prNumber}, using existing PR`);
                  revertPR = openPRs.find(p =>
                    p.title.includes(`Revert "${prNumber}"`) || p.body?.includes(`#${prNumber}`)
                  );
                } else {
                  throw err;
                }
              }
            } else {
              core.info(`‚ö†Ô∏è Existing revert PR found #${revertPR.number}, skipping creation`);
            }

            // Merge the revert PR
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: revertPR.number,
              merge_method: "squash"
            });
            core.info(`‚úÖ Successfully merged revert PR #${revertPR.number} for original PR #${prNumber}`);

  # revert-base:
  #   needs: revert-submodules
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/github-script@v7
  #       with:
  #         github-token: ${{ env.CROSS_TOKEN }}
  #         script: |
  #           const prNumber = context.issue.number;
  #           const { data: pr } = await github.rest.pulls.get({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: prNumber
  #           });
  #           if (!pr.merged) return;

  #           const { data: revert } = await github.request("POST /repos/{owner}/{repo}/pulls/{pull_number}/revert", {
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: prNumber
  #           });

  #           await github.rest.pulls.merge({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: revert.number,
  #             merge_method: "squash"
  #           });

  # bump-submodules:
  #   needs: [revert-submodules, revert-base]
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/github-script@v7
  #       with:
  #         github-token: ${{ env.CROSS_TOKEN }}
  #         script: |
  #           const owner = context.repo.owner;
  #           const repo = context.repo.repo;
  #           const workflowFileName = "bump.yml";
  #           const ref = "main";

  #           console.log(`üöÄ Dispatching '${workflowFileName}' on ${ref}...`);
  #           await github.rest.actions.createWorkflowDispatch({
  #             owner,
  #             repo,
  #             workflow_id: workflowFileName,
  #             ref
  #           });
  #           console.log("‚úÖ Bump workflow dispatched successfully");
