name: Revert chain

on:
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: write
  issues: write
  actions: write

env:
  RW_PAT: ${{ secrets.WORKFLOWS }}

jobs:
  revert-chain:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      revert_number: ${{ steps.pr.outputs.revert_number }}
    steps:

      - name: Get PR info
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNum = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNum
            });
            if (!pr.merged) {
              core.setFailed('Base PR is not merged ‚Äì nothing to revert.');
              return;
            }
            core.setOutput('merge_sha', pr.merge_commit_sha);
            core.setOutput('base_branch', pr.base.ref);
            core.setOutput('title', pr.title);

      - name: Detect submodules from comment and populate Json
        id: submod
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const analysis = comments
              .filter(c => /üîç Submodule Analysis Results/.test(c.body))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

            if (!analysis) {
              core.warning("‚ö†Ô∏è No 'Submodule Analysis Results' comment found.");
              core.setOutput('submodules', '[]');
              return;
            }
            const submodules = [];
            const text = analysis.body;
            const blocks = text.split(/(?=####\s*[‚úÖ‚è≥üîÑ‚ùå]\s*`)/g).filter(b => /PR:/i.test(b));

            for (const block of blocks) {
              // If the markdown for the comment generated by the app changes, everything will break
              const nameMatch = block.match(/####\s*[‚úÖ‚è≥üîÑ‚ùå]\s*`([^`]+)`/);
              const branchMatch = block.match(/\*\*Branch:\*\*\s*`([^`]+)`/);
              const statusMatch = block.match(/\*\*Status:\*\*\s*\*\*([^*]+)\*\*/);
              const prMatch = block.match(/\[?#(\d+)\]\((https:\/\/github\.com\/[^)]+)\)/);
              const approvalsMatch = block.match(/\*\*Approvals:\*\*\s*([\d/]+)/);
              const changeRequestsMatch = block.match(/\*\*Change Requests:\*\*\s*(\d+)/);

              if (!nameMatch || !prMatch) {
                core.warning(`‚ö†Ô∏è Skipping malformed submodule block:\n${block}`);
                continue;
              }

              const name = nameMatch[1].trim();
              const branch = branchMatch ? branchMatch[1].trim() : null;
              const status = statusMatch ? statusMatch[1].trim() : null;
              const pr_number = parseInt(prMatch[1], 10);
              const pr_url = prMatch[2];
              const approvals = approvalsMatch ? approvalsMatch[1] : null;
              const change_requests = changeRequestsMatch ? changeRequestsMatch[1] : null;
              const [, org, repo] = pr_url.match(/github\.com\/([^/]+)\/([^/]+)\//) || [];

              submodules.push({
                name,
                branch,
                status,
                pr_number,
                change_requests,
                repo: repo || name,
                org: org || context.repo.owner,
                url: pr_url,
              });
            }

            const json = JSON.stringify(submodules, null, 2);
            core.info("üì¶ Extracted submodule JSON:");
            core.info(json);
            core.setOutput('submodules', json);
      

      - name: Print full diff of merged commit
        run: |
          echo "================= FULL DIFF FOR DEBUG ================="
          git show --submodule=diff ${{ steps.pr.outputs.merge_sha }} || true
          echo "========================================================"

      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0
          submodules: recursive
      
      - name: Create revert branch for base repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin ${{ steps.pr.outputs.base_branch }}
          git checkout -b revert-${{ github.event.issue.number }} origin/${{ steps.pr.outputs.base_branch }}
          git revert -m 1 ${{ steps.pr.outputs.merge_sha }} || true
          git commit -am "Revert: ${{ steps.pr.outputs.title }}" || echo "No base changes to commit"
          git push origin HEAD

      - name: Create revert PR for base repo
        id: basepr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const revertBranch = `revert-${context.issue.number}`;
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Revert "${{ steps.pr.outputs.title }}"`,
              head: revertBranch,
              base: "${{ steps.pr.outputs.base_branch }}",
              body: `Automatically reverting PR #${context.issue.number}`
            });
            core.setOutput('revert_pr', pr.number);
            core.setOutput('revert_branch', revertBranch);
            core.info(`‚úÖ Created base revert PR #${pr.number}`);
      

      - name: Revert and create PRs for submodules
        id: revert-merge-submods
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.submod.outputs.submodules }}
          RW_PAT: ${{ env.RW_PAT }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');

            const submods = JSON.parse(process.env.SUBMODULES_JSON);

            // Load .gitmodules to get branch info
            let gitmodulesBranches = {};
            if (fs.existsSync('.gitmodules')) {
              const gitmodules = fs.readFileSync('.gitmodules', 'utf8');
              const submoduleMatches = [...gitmodules.matchAll(/\[submodule "([^"]+)"\]\s+path = ([^\n]+)\s+url = ([^\n]+)/g)];
              for (const [, name, subPath, url] of submoduleMatches) {
                // Optional: detect branch from url line if present
                const branchMatch = gitmodules.match(new RegExp(`\\[submodule "${name}"\\][\\s\\S]*?branch\\s*=\\s*([^\n]+)`));
                gitmodulesBranches[subPath.trim()] = branchMatch ? branchMatch[1].trim() : 'main';
              }
            }

            for (const sub of submods) {
              const { data: prInfo } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: sub.pr_number,
                });

              const repoUrl = `https://${process.env.RW_PAT}@github.com/${sub.org}/${sub.repo}.git`;
              const branchName = `revert-${context.issue.number}`;
              const tempDir = `/tmp/${sub.repo}-${Date.now()}`;
              const baseBranch = gitmodulesBranches[sub.name] || 'main';

              console.log(`üîß Processing submodule ${sub.name} at ${sub.org}/${sub.repo}, base branch: ${baseBranch}`);

              try {
                // Clone the submodule repo
                execSync(`git clone ${repoUrl} ${tempDir}`, { stdio: 'inherit' });

                // Navigate into repo
                process.chdir(tempDir);

                // Fetch base branch
                execSync(`git fetch origin ${baseBranch}`, { stdio: 'inherit' });

                // Create revert branch from base branch
                execSync(`git checkout -b ${branchName} origin/${baseBranch}`, { stdio: 'inherit' });

                execSync(`git revert -m 1 ${prInfo.data.merge_commit_sha}`, { stdio: 'inherit' });
                execSync(`git commit -am "Revert: ${sub.title || 'Submodule PR #' + sub.pr_number}"`, { stdio: 'inherit' });

                // Push revert branch
                execSync(`git push origin ${branchName}`, { stdio: 'inherit' });

                // Create PR in submodule repo
                const pr = await github.rest.pulls.create({
                  owner: sub.org,
                  repo: sub.repo,
                  title: `Revert PR #${sub.pr_number}`,
                  head: branchName,
                  base: baseBranch,
                  body: `Automatically reverting PR #${sub.pr_number}`
                });

                console.log(`‚úÖ Created revert PR #${pr.data.number} in ${sub.repo}`);

              } catch (err) {
                core.warning(`‚ùóÔ∏è Failed to process ${sub.repo}: ${err.message}`);
              } finally {
                // Clean up temp dir
                execSync(`rm -rf ${tempDir}`);
              }
            }



      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0
          ref: ${{ steps.basepr.outputs.revert_branch }}
          submodules: false

      - name: Authenticate submodules
        run: |
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ steps.submod.outputs.submodules }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{ steps.basepr.outputs.revert_branch }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');

            const submoduleJson = JSON.parse(process.env.SUBMODULES);
            let changed = false;

            // Load .gitmodules to get branch info
            let gitmodulesBranches = {};
            if (fs.existsSync('.gitmodules')) {
              const gitmodules = fs.readFileSync('.gitmodules', 'utf8');
              const submoduleMatches = [...gitmodules.matchAll(/\[submodule "([^"]+)"\]\s+path = ([^\n]+)\s+url = ([^\n]+)/g)];
              for (const [, name, subPath, url] of submoduleMatches) {
                const branchMatch = gitmodules.match(new RegExp(`\\[submodule "${name}"\\][\\s\\S]*?branch\\s*=\\s*([^\n]+)`));
                gitmodulesBranches[subPath.trim()] = branchMatch ? branchMatch[1].trim() : 'main';
              }
            }

            for (const sub of submoduleJson) {
              const path = sub.name;
              const org = sub.org;
              const repo = sub.repo;
              const branch = gitmodulesBranches[path] || 'main';
              const urlWithToken = `https://${process.env.TOKEN}@github.com/${org}/${repo}.git`;

              console.log(`üîß Updating submodule ${repo} at ${path} (branch: ${branch})`);

              // Fetch the branch and check for updates
              execSync(`git -C ${path} fetch origin ${branch}:${branch}`, { stdio: 'inherit' });

              const latestCommit = execSync(
                `git ls-remote ${urlWithToken} refs/heads/${branch} | awk '{print $1}'`,
                { encoding: 'utf8' }
              ).trim();

              const currentCommit = execSync(
                `git -C ${path} rev-parse HEAD`,
                { encoding: 'utf8' }
              ).trim();

              if (currentCommit !== latestCommit) {
                console.log(`‚ö†Ô∏è ${sub.name} is outdated. Resetting to ${latestCommit}`);
                execSync(`git -C ${path} reset --hard ${latestCommit}`, { stdio: 'inherit' });
                execSync(`git add ${path}`, { stdio: 'inherit' });
                changed = true;
              } else {
                console.log(`‚úÖ ${sub.name} is already up-to-date`);
              }
            }

            if (changed) {
              execSync(`git commit -m "Bump submodules to latest .gitmodules branch"`, { stdio: 'inherit' });
              execSync(`git push origin ${process.env.BRANCH}`, { stdio: 'inherit' });
            } else {
              console.log('‚úÖ All submodules already up-to-date.');
            }


  merge-base:
    needs: [revert-chain]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Merge base PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const revertNumber = parseInt("${{ needs.revert-chain.outputs.revert_number }}");
            const prNumber = context.issue.number;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: revertNumber,
              merge_method: 'squash'
            });

