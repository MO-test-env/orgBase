name: Auto-Revert Submodule Matrix + Base PR (on /revert comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  # Detect /revert comment and cached submodule info
  detect-submodules:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      submodules: ${{ steps.extract.outputs.submodules }}
    steps:
      - id: extract
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            const cache = comments.find(c => /<!-- SUBMODULES_JSON -->/.test(c.body));
            if (!cache) throw new Error("No cached submodule comment found");
            const jsonMatch = cache.body.match(/```json\s*([\s\S]*?)\s*```/);
            if (!jsonMatch) throw new Error("Failed to parse JSON from cached comment");
            core.setOutput('submodules', jsonMatch[1]);

  # Revert submodule PRs using GraphQL
  revert-submodules:
    needs: detect-submodules
    runs-on: ubuntu-latest
    strategy:
      matrix:
        submod: ${{ fromJson(needs.detect-submodules.outputs.submodules) }}
      max-parallel: 6
    steps:
      - name: Revert submodule PR via GraphQL
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\/|\.git$/g,'').split('/');
            const prNumber = sub.pr_number;
            try {
              core.info(`üîç Fetching original PR #${prNumber} in ${repo}`);

              // Get PR node ID via GraphQL
              const prQuery = `
                query($owner: String!, $repo: String!, $prNumber: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $prNumber) {
                      id
                    }
                  }
                }
              `;
              core.info(`üì° PR Query: ${prQuery}`);
              core.info(`üìå Query Variables: owner=${owner}, repo=${repo}, prNumber=${prNumber}`);

              const prData = await github.graphql(prQuery, { owner, repo, prNumber });
              core.info(`üì• PR Data Response: ${JSON.stringify(prData, null, 2)}`);

              const prId = prData.repository.pullRequest.id;
              core.info(`üÜî PR Node ID: ${prId}`);

               // Revert PR mutation ‚Äì include a unique branch name to avoid ‚Äúalready exists‚Äù errors
              const revertBranchName = `revert-${prNumber}-${Date.now()}`;
              const revertMutation = `
                mutation($input: RevertPullRequestInput!) {
                  revertPullRequest(input: $input) {
                    pullRequest {
                      number
                      url
                      headRefName
                    }
                  }
                }
              `;
              core.info(`üì° Revert Mutation: ${revertMutation}`);
              core.info(`üìå Revert Variables: pullRequestId=${prId}, revertBranchName=${revertBranchName}`);

              let revertResponse;
              try {
                revertResponse = await github.graphql(revertMutation, {
                  input: {
                    pullRequestId: prId,
                    revertBranchName: revertBranchName
                  }
                });
              } catch (e) {
                // If a revert PR already exists GitHub returns a validation error.
                // Detect that case, locate the existing PR and continue with merging.
                if (/already exists/.test(e.message)) {
                  core.warning(`‚ö†Ô∏è Revert PR already exists for PR #${prNumber}. Attempting to locate it.`);
                  const existingPRs = await github.rest.pulls.list({
                    owner,
                    repo,
                    head: `${owner}:${revertBranchName.split('-').slice(0,2).join('-')}`, // e.g. revert-27
                    state: "open"
                  });
                  if (existingPRs.data.length === 0) {
                    core.setFailed(`‚ùå Could not find existing revert PR for #${prNumber}.`);
                    return;
                  }
                  revertResponse = { revertPullRequest: { pullRequest: existingPRs.data[0] } };
                } else {
                  throw e; // re‚Äëthrow unexpected errors
                }
              }

              const revertBranch = revertResponse.revertPullRequest.pullRequest.headRefName;
              core.info(`‚úÖ Revert PR branch created/found: ${revertBranch}`);

              // Get the new PR number (either freshly created or already existing)
              const { data: pullRequests } = await github.rest.pulls.list({
                owner,
                repo,
                head: `${owner}:${revertBranch}`,
                state: "open"
              });

              const newPR = pullRequests[0];
              core.info(`‚úÖ Using revert PR #${newPR.number} (reverting original PR #${prNumber}) at ${newPR.html_url}`);

              // Merge the revert PR
              const mergeResponse = await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: newPR.number,
                merge_method: "squash",
              });
              core.info(`üì• Merge Response: ${JSON.stringify(mergeResponse, null, 2)}`);

              core.info(`‚úÖ Successfully merged revert PR #${newPR.number}, undoing original PR #${prNumber}`);


  # # Revert base PR using GraphQL
  # revert-base:
  #   needs: detect-submodules
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Revert base PR via GraphQL
  #       uses: actions/github-script@v7
  #       with:
  #         github-token: ${{ env.CROSS_TOKEN }}
  #         script: |
  #           const prNumber = context.issue.number;
  #           core.info(`üîç Attempting GraphQL revert for base PR #${prNumber}`);

  #           const basePR = await github.rest.pulls.get({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: prNumber
  #           });

  #           if (!basePR.data.merged) {
  #             core.info(`‚ö†Ô∏è Base PR #${prNumber} not merged. Skipping revert.`);
  #             return;
  #           }

  #           const query = `
  #             mutation($input: RevertPullRequestInput!) {
  #               revertPullRequest(input: $input) {
  #                 pullRequest { number url }
  #               }
  #             }
  #           `;

  #           const response = await github.graphql(query, {
  #             input: {
  #               pullRequestId: basePR.data.node_id,
  #               commitHeadline: `Revert Base PR #${prNumber}`,
  #               revertBranchName: `revert-base-pr-${prNumber}-${Date.now()}`,
  #             }
  #           });

  #           const newPR = response.revertPullRequest.pullRequest;
  #           core.info(`‚úÖ Created revert PR #${newPR.number} at ${newPR.url}`);

  #           ## hypothetcally bump here

  #           await github.rest.pulls.merge({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: newPR.number,
  #             merge_method: "squash",
  #           });
  #           core.info(`‚úÖ Reverted base PR #${prNumber}`);
  
  # dispatch-submodule-bump:
  #   needs: 
  #     - revert-submodules
  #     - revert-base
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Trigger Check and Bump Submodules workflow
  #       uses: actions/github-script@v7
  #       with:
  #         github-token: ${{ env.CROSS_TOKEN }}
  #         script: |
  #           const owner = context.repo.owner;
  #           const repo = context.repo.repo;
  #           const workflowFileName = "bump.yml";
  #           const ref = "main"; // branch to run workflow on

  #           console.log(`üöÄ Dispatching workflow '${workflowFileName}' on ${ref}...`);

  #           await github.rest.actions.createWorkflowDispatch({
  #             owner,
  #             repo,
  #             workflow_id: workflowFileName,
  #             ref
  #           });

  #           console.log("‚úÖ Workflow dispatched successfully");