name: Revert

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.WORKFLOWS2 }} # Personal Access Token with RW access to repo contents, PRs
  MIN_REVIEWERS: 0

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  init:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      head_ref: ${{ steps.pr.outputs.head_ref }}
      base_ref: ${{ steps.pr.outputs.base_ref }}
      pr_number: ${{ steps.pr.outputs.pr_number }}
      pr_title: ${{ steps.pr.outputs.title }}
      mergeable: ${{ steps.pr.outputs.mergeable }}
      merged: ${{ steps.pr.outputs.merged }}
      mergeable_state: ${{ steps.pr.outputs.mergeable_state }}
      state: ${{ steps.pr.outputs.state }}
      submodules: ${{ steps.add-merged-flag.outputs.submodules }}
      unmerged_submodules: ${{ steps.add-merged-flag.outputs.unmerged }}
    steps:

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("title", pr.data.title);
            core.setOutput("body", pr.data.body);
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("merged", pr.data.merged);
            core.setOutput("mergeable_state", pr.data.mergeable_state);
            core.setOutput("state", pr.data.state);
      
      - name: Confirm Approvals for base PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const latestByUser = {};
            for (const review of reviews) {
              latestByUser[review.user.login] = review.state;
            }
            const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
            const approvalCount = approvedUsers.length;

            console.log(`âœ… Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

            if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
              core.setFailed(`âŒ Not enough approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
              return;
            } else {
              console.log('âœ… Required approvals met.');
            }
      

      - name: Detect submodules from comment and populate Json
        id: submod
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const analysis = comments
              .filter(c => /ðŸ” Submodule Analysis Results/.test(c.body))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

            if (!analysis) {
              core.warning("âš ï¸ No 'Submodule Analysis Results' comment found.");
              core.setOutput('submodules', '[]');
              return;
            }
            const submodules = [];
            const text = analysis.body;
            const blocks = text.split(/(?=####\s*[âœ…â³ðŸ”„âŒ]\s*`)/g).filter(b => /PR:/i.test(b));

            for (const block of blocks) {
              // If the markdown for the comment generated by the app changes, everything will break
              const nameMatch = block.match(/####\s*[âœ…â³ðŸ”„âŒ]\s*`([^`]+)`/);
              const branchMatch = block.match(/\*\*Branch:\*\*\s*`([^`]+)`/);
              const statusMatch = block.match(/\*\*Status:\*\*\s*\*\*([^*]+)\*\*/);
              const prMatch = block.match(/\[?#(\d+)\]\((https:\/\/github\.com\/[^)]+)\)/);
              const approvalsMatch = block.match(/\*\*Approvals:\*\*\s*([\d/]+)/);
              const changeRequestsMatch = block.match(/\*\*Change Requests:\*\*\s*(\d+)/);

              if (!nameMatch || !prMatch) {
                core.warning(`âš ï¸ Skipping malformed submodule block:\n${block}`);
                continue;
              }

              const name = nameMatch[1].trim();
              const branch = branchMatch ? branchMatch[1].trim() : null;
              const status = statusMatch ? statusMatch[1].trim() : null;
              const pr_number = parseInt(prMatch[1], 10);
              const pr_url = prMatch[2];
              const approvals = approvalsMatch ? approvalsMatch[1] : null;
              const change_requests = changeRequestsMatch ? changeRequestsMatch[1] : null;
              const [, org, repo] = pr_url.match(/github\.com\/([^/]+)\/([^/]+)\//) || [];

              submodules.push({
                name,
                branch,
                status,
                pr_number,
                change_requests,
                repo: repo || name,
                org: org || context.repo.owner,
                url: pr_url,
              });
            }

            const json = JSON.stringify(submodules, null, 2);
            core.info("ðŸ“¦ Extracted submodule JSON:");
            core.info(json);
            core.setOutput('submodules', json);


      - name: Pre-check all Submodules
        id: add-merged-flag
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.submod.outputs.submodules }}
          RW_PAT: ${{ env.RW_PAT }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const enriched = [];

            for (const sub of submods) {
              if (!sub.pr_number) {
                enriched.push({ ...sub, merged: true });
                continue;
              }

              const url = new URL(sub.url);
              const [owner, repo] = url.pathname.replace(/^\/|\.git$/g, '').split('/');

              try {
                const { data: prInfo } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: sub.pr_number,
                });

                const isMerged = prInfo.state === 'closed' && prInfo.merged === true;
                const isMergeableClean = prInfo.mergeable_state === 'clean';

                if (!isMergeableClean && !isMerged) {
                  core.setFailed(`âŒ Submodule ${sub.name} PR #${sub.pr_number} is not mergeable (state=${prInfo.mergeable_state})`);
                  return;
                }

                enriched.push({ ...sub, merged: isMerged, mergeable_state: prInfo.mergeable_state });

                core.info(`ðŸ”Ž Submodule ${sub.name} PR #${sub.pr_number} merged=${isMerged}, mergeable_state=${prInfo.mergeable_state}`);

                // Fetch reviews
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner,
                  repo,
                  pull_number: sub.pr_number,
                });

                const approvedReviews = reviews.filter(r => r.state === 'APPROVED');
                if (approvedReviews.length < parseInt(process.env.MIN_REVIEWERS, 10)) {
                  core.setFailed(`âŒ Submodule ${sub.name} PR #${sub.pr_number} does not have enough approvals.`);
                  return;
                }

                core.info(`âœ… Submodule ${sub.name} has ${approvedReviews.length} approved review(s).`);

              } catch (err) {
                core.warning(`â—ï¸ Could not fetch PR #${sub.pr_number} for ${owner}/${repo}: ${err.message}`);
                enriched.push({ ...sub, merged: false, mergeable_state: 'unknown' });
                return;
              }
            }

            const enrichedJson = JSON.stringify(enriched, null, 2);
            core.info("Submodule JSON:");
            core.info(enrichedJson);
            core.setOutput('submodules', enrichedJson);

            // Filter only unmerged submodules
            const unmerged = enriched.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("âŒ Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);

  check-base-conflicts:
    needs: [init]
    if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      conflicts: ${{ steps.detect-conflicts.outputs.conflicts }}
    steps:
      - name: Checkout PR branch
        if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
        uses: actions/checkout@v4
        with:
          token:       ${{ env.RW_PAT }}
          ref:         ${{ needs.init.outputs.base_ref }}
          fetch-depth: 0
          submodules:  false

      - name: Detect conflicts (dryâ€‘run merge)
        if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
        id: detect-conflicts
        uses: actions/github-script@v7
        env:
          BASE: ${{ needs.init.outputs.base_ref }}  
          PR_BRANCH: ${{ needs.init.outputs.head_ref }}
          TOKEN: ${{ env.RW_PAT }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');

            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };

            run('git config --global user.name "github-actions[bot]"');
            run('git config --global user.email "github-actions[bot]@users.noreply.github.com"');

            try {
              run(`git fetch origin "${process.env.PR_BRANCH}"`);
            } catch (e) {
              core.setFailed(`âŒ Failed to fetch base branch ${process.env.PR_BRANCH}: ${e.message}`);
              process.exit(1);
            }

            // Parse submodule paths from .gitmodules 
            let submodulePaths = [];
            if (fs.existsSync('.gitmodules')) {
              const gm = fs.readFileSync('.gitmodules', 'utf8');
              const matches = [...gm.matchAll(/path\s*=\s*(.+)/g)];
              submodulePaths = matches.map(m => m[1].trim());
              console.log(`ðŸ“¦ Found submodules: ${submodulePaths.join(', ')}`);
            } else {
              core.setFailed('âš ï¸ No .gitmodules file found');
              process.exit(1);
            }

            try {
              run(`git merge --no-commit --no-ff "origin/${process.env.PR_BRANCH}"`, { stdio: 'inherit' });
            } catch (_) {
              // merge returned nonâ€‘zero â†’ likely conflicts - allow it to fall through
            }

            let conflictList = '';
            try {
              conflictList = run('git diff --name-only --diff-filter=U');
            } catch (_) {
              // No conflicted files â†’ git diff returns nothing, keep empty string
            }

            if (!conflictList) {
              console.log('!! No conflicted files â€“ this is unexpected when mergeable_state was â€œdirtyâ€.');
              core.setOutput('conflict_files', '[]');  
            } else {
              console.log('âš¡ï¸ Conflicted files (plainâ€‘text):');
              console.log(conflictList);

              const conflicts = conflictList
                .split('\n')
                .filter(Boolean)
                .map(f => f.trim());

              console.log('âš¡ï¸ Conflicted files:', conflicts);

              // Determine if any conflict is *not* inside a submodule path
              const nonSubmoduleConflicts = conflicts.filter(f => {
                return !submodulePaths.some(sub => f === sub || f.startsWith(`${sub}/`));
              });

              const json = JSON.stringify(conflicts);
              core.setOutput('conflict_files', json);
              
              run('git merge --abort || true');

              if (nonSubmoduleConflicts.length > 0) {
                console.log('âŒ Non-submodule conflicts detected:');
                console.log(nonSubmoduleConflicts.join('\n'));
                core.setFailed('Conflicts found in non-submodule paths.');
                return;
              } else {
                console.log('âœ… Only submodule conflicts detected â€” not failing.');
              }
            }

  merge-submodules:
    needs: [ init ]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      needs.init.result == 'success' &&
      needs.init.outputs.unmerged_submodules != '[]' && 
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert'
    env:
      GITHUB_API_URL: https://github.com/api/v3
    strategy:
      matrix:
        submod: ${{ fromJson(needs.init.outputs.unmerged_submodules) }}
      max-parallel: 4
      fail-fast: true
    steps:
      - name: Merge submodule PR
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            console.info(`ðŸ”Ž Processing submodule: ${JSON.stringify(sub)}`);

            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\//,'').replace(/\.git$/,'').split('/');
            const pr = sub.pr_number;
            const { data: prInfo } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
            const res = await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: pr,
              merge_method: "squash",
            });

  aggregate:
    needs: [merge-submodules,check-base-conflicts, init]
    runs-on: ubuntu-latest
    timeout-minutes: 1
    if: >-
      always() &&
      needs.init.result == 'success' &&
      (needs.check-base-conflicts.result == 'success' || needs.check-base-conflicts.result == 'skipped') &&
      (needs.merge-submodules.result == 'success' || needs.merge-submodules.result == 'skipped') && 
      (needs.init.outputs.submodules != '[]') &&
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' 
    steps:
      - name: wait
        run: |
          echo "wait"

  bump-rebase-submodules:
    needs: [aggregate, check-base-conflicts, init]
    if: >-
      always() &&
      needs.aggregate.result == 'success' &&
      ( needs.check-base-conflicts.result == 'success' || needs.check-base-conflicts.result == 'skipped') &&
      needs.init.result == 'success' &&
      needs.init.outputs.submodules != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0
          ref: ${{ needs.init.outputs.head_ref }}
          submodules: false

      - name: Authenticate submodules
        run: |
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ needs.init.outputs.submodules }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{ needs.init.outputs.head_ref }}
        with:
          script: |
            const { execSync } = require('child_process');
            const submoduleJson = JSON.parse(process.env.SUBMODULES);
            let changed = false;

            for (const sub of submoduleJson) {
              const path = sub.name;
              const org = sub.org;
              const branch = sub.branch;
              const urlWithToken = `https://${process.env.TOKEN}@github.com/${org}/${sub.repo}.git`;

              console.log(`ðŸ”§ Updating submodule ${sub.repo} at ${path}`);

              execSync(`git -C ${path} fetch origin ${branch}:${branch}`, { stdio: 'inherit' });

              const latestCommit = execSync(
                `git ls-remote ${urlWithToken} refs/heads/${branch} | awk '{print $1}'`,
                { encoding: 'utf8' }
              ).trim();

              const currentCommit = execSync(
                `git -C ${path} rev-parse HEAD`,
                { encoding: 'utf8' }
              ).trim();

              if (currentCommit !== latestCommit) {
                console.log(`âš ï¸  ${sub.name} is outdated. Resetting to ${latestCommit}`);
                execSync(`git -C ${path} reset --hard ${latestCommit}`, { stdio: 'inherit' });
                execSync(`git add ${path}`);
                changed = true;
              } else {
                console.log(`âœ… ${sub.name} is already up-to-date`);
              }
            }

            if (changed) {
              execSync(`git commit -m "Bump submodules to latest default branch"`);
              execSync(`git push origin ${process.env.BRANCH}`);
            } else {
              console.log('âœ… All submodules already up-to-date.');
            }

  merge-base:
    needs: [bump-rebase-submodules, init]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      needs.bump-rebase-submodules.result == 'success' || (needs.init.outputs.submodules == '[]')
    steps:
      - name: Merge base PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });
