name: Revert chain

on:
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: write
  issues: write
  actions: write

env:
 RW_PAT: ${{ secrets.WORKFLOWS }}

jobs:
  detect-submodules:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      submodules: ${{ steps.extract.outputs.submodules }}
    steps:
      - name: Detect submodules from comment and populate Json
        id: extract
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const analysis = comments
              .filter(c => /üîç Submodule Analysis Results/.test(c.body))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

            if (!analysis) {
              core.warning("‚ö†Ô∏è No 'Submodule Analysis Results' comment found.");
              core.setOutput('submodules', '[]');
              return;
            }
            const submodules = [];
            const text = analysis.body;
            const blocks = text.split(/(?=####\s*[‚úÖ‚è≥üîÑ‚ùå]\s*`)/g).filter(b => /PR:/i.test(b));

            for (const block of blocks) {
              // If the markdown for the comment generated by the app changes, everything will break
              const nameMatch = block.match(/####\s*[‚úÖ‚è≥üîÑ‚ùå]\s*`([^`]+)`/);
              const branchMatch = block.match(/\*\*Branch:\*\*\s*`([^`]+)`/);
              const statusMatch = block.match(/\*\*Status:\*\*\s*\*\*([^*]+)\*\*/);
              const prMatch = block.match(/\[?#(\d+)\]\((https:\/\/github\.com\/[^)]+)\)/);
              const approvalsMatch = block.match(/\*\*Approvals:\*\*\s*([\d/]+)/);
              const changeRequestsMatch = block.match(/\*\*Change Requests:\*\*\s*(\d+)/);

              if (!nameMatch || !prMatch) {
                core.warning(`‚ö†Ô∏è Skipping malformed submodule block:\n${block}`);
                continue;
              }

              const name = nameMatch[1].trim();
              const branch = branchMatch ? branchMatch[1].trim() : null;
              const status = statusMatch ? statusMatch[1].trim() : null;
              const pr_number = parseInt(prMatch[1], 10);
              const pr_url = prMatch[2];
              const approvals = approvalsMatch ? approvalsMatch[1] : null;
              const change_requests = changeRequestsMatch ? changeRequestsMatch[1] : null;
              const [, org, repo] = pr_url.match(/github\.com\/([^/]+)\/([^/]+)\//) || [];

              submodules.push({
                name,
                branch,
                status,
                pr_number,
                change_requests,
                repo: repo || name,
                org: org || context.repo.owner,
                url: pr_url,
              });
            }

            const json = JSON.stringify(submodules, null, 2);
            core.info("üì¶ Extracted submodule JSON:");
            core.info(json);
            core.setOutput('submodules', json);

  create-revert-base:
    needs: detect-submodules
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0

      - name: Get PR info
        id: get-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            if (!pr.merged) {
              core.setFailed('Base PR is not merged ‚Äì nothing to revert.');
              return;
            }

            core.setOutput('merge_commit_sha', pr.merge_commit_sha);
            core.setOutput('base_ref', pr.base.ref);
            core.setOutput('title', pr.title);

      - name: Create revert branch
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin ${{ steps.get-pr.outputs.base_ref }}
          git checkout -b revert-${{ github.event.issue.number }} origin/${{ steps.get-pr.outputs.base_ref }}
          git revert -m 1 ${{ steps.get-pr.outputs.merge_commit_sha }} || true
          git commit -am "Revert: ${{ steps.get-pr.outputs.title }}" || echo "No changes to commit"
          git push origin HEAD

      - name: Create revert PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            const baseRef = "${{ steps.get-pr.outputs.base_ref }}";
            const title = "${{ steps.get-pr.outputs.title }}";
            const revertBranch = `revert-${prNumber}`;

            const { data: newPr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Revert "${title}"`,
              head: revertBranch,
              base: baseRef,
              body: `This reverts PR #${prNumber}`,
            });

            core.info(`‚úÖ Created revert PR #${newPr.number}`);

  revert-submodules:
    needs: detect-submodules
    if: needs.detect-submodules.outputs.submodules != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        submod: ${{ fromJson(needs.detect-submodules.outputs.submodules) }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0

      - uses: actions/github-script@v7
        env:
          RW_PAT: ${{ env.RW_PAT }}
        with:
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            const owner = sub.org;
            const repo = sub.repo;
            const prNumber = sub.pr_number;

            const { data: pr } = await github.rest.pulls.get({
              owner, repo, pull_number: prNumber
            });
            if (!pr.merged) {
              core.info(`‚ö†Ô∏è PR #${prNumber} in ${repo} is not merged. Skipping.`);
              return;
            }

            const branch = `revert-${prNumber}`;
            const mergeCommit = pr.merge_commit_sha;

            const execSync = require('child_process').execSync;
            execSync(`git clone https://${process.env.RW_PAT}@github.com/${owner}/${repo}.git`, { stdio: 'inherit' });
            process.chdir(repo);
            execSync(`git config user.name "github-actions[bot]"`);
            execSync(`git config user.email "github-actions[bot]@users.noreply.github.com"`);
            execSync(`git fetch origin ${pr.base.ref}`);
            execSync(`git checkout -b ${branch} origin/${pr.base.ref}`);
            try {
              execSync(`git revert -m 1 ${mergeCommit}`, { stdio: 'inherit' });
              execSync(`git push origin ${branch}`, { stdio: 'inherit' });
              core.info(`‚úÖ Created revert branch ${branch} for ${repo}`);
            } catch (e) {
              core.warning(`‚ö†Ô∏è Revert failed for ${repo}: ${e.message}`);
              return;
            }

            // Create PR via REST
            const revertPR = await github.rest.pulls.create({
              owner,
              repo,
              title: `Revert "${pr.title}"`,
              head: branch,
              base: pr.base.ref,
              body: `Automatically reverting PR #${prNumber}`
            });
            core.info(`‚úÖ Created revert PR #${revertPR.data.number} in ${repo}`);

            // Merge automatically
            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: revertPR.data.number,
              merge_method: "squash"
            });
            core.info(`‚úÖ Merged revert PR #${revertPR.data.number} in ${repo}`);


  aggregate:
    needs: revert-submodules
    runs-on: ubuntu-latest
    steps:
      - run: echo "All submodule reverts completed. Ready to bump."

  bump-base-revert-pr:
    needs:
      - detect-submodules
      - create-revert-base
      - aggregate
    runs-on: ubuntu-latest
    outputs:
      revert_number: ${{ steps.find-base.outputs.number }}
    env:
      ORIG_PR: ${{ github.event.issue.number }}
    steps:
      - name: Find base revert PR (REST search)
        id: find-base
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const origPrNumber = parseInt(process.env.ORIG_PR, 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;

            core.info(`Searching repository ${owner}/${repo} for a revert PR referencing #${origPrNumber}...`);

            // Helper function: try to find a matching PR in a paginated list
            async function findInList(state, maxPages = 5) {
              for (let page = 1; page <= maxPages; page++) {
                const { data: prs } = await github.rest.pulls.list({
                  owner, repo, state, per_page: perPage, page
                });
                if (!prs || prs.length === 0) break;

                // prefer PRs that explicitly reference the original PR number in the body/title,
                // or whose branch name contains "revert-<origPrNumber>"
                const candidate = prs.find(p => {
                  const title = (p.title||'').toLowerCase();
                  const body = (p.body||'').toLowerCase();
                  const headRef = (p.head && p.head.ref) ? p.head.ref.toLowerCase() : '';

                  if (body.includes(`#${origPrNumber}`)) return true;
                  if (title.includes(`#${origPrNumber}`)) return true;
                  if (title.includes('revert') && body.includes(String(origPrNumber))) return true;
                  if (headRef.includes(`revert-${origPrNumber}`) || headRef.includes(`revert/${origPrNumber}`)) return true;
                  // sometimes GraphHub uses "revert-<repo>-<pr>" or similar; basic "revert" + number heuristics:
                  if (title.includes('revert') && (body.includes(String(origPrNumber)) || title.includes(String(origPrNumber)))) return true;

                  return false;
                });

                if (candidate) return candidate;
              }
              return null;
            }

            // Search open PRs first 
            let found = await findInList('open', 5);

            // Fallback: use the global search API (search bodies/titles for the original PR number)
            if (!found) {
              core.info('Fallback: using search API for references to the original PR number...');
              const q = `repo:${owner}/${repo} type:pr ${origPrNumber} in:body,code`;
              const searchResp = await github.rest.search.issuesAndPullRequests({ q, per_page: 10 });
              if (searchResp && searchResp.data && Array.isArray(searchResp.data.items)) {
                // prefer open results, then any
                const items = searchResp.data.items;
                const match = items.find(i => i.pull_request && i.body && i.body.includes(`#${origPrNumber}`))
                          || items.find(i => i.pull_request);
                if (match) {
                  // match.number is the PR number
                  const { data: pr } = await github.rest.pulls.get({
                    owner, repo, pull_number: match.number
                  });
                  found = pr;
                }
              }
            }

            if (!found) {
              core.setFailed(`Could not locate a revert PR referencing original PR #${origPrNumber}.`);
              return;
            }

            // If search returned a lightweight item (from list), ensure we have full PR object
            let fullPR = found;
            if (!fullPR.head || !fullPR.title) {
              const { data: pr } = await github.rest.pulls.get({
                owner, repo, pull_number: found.number
              });
              fullPR = pr;
            }

            core.info(`Found revert PR #${fullPR.number} (branch: ${fullPR.head.ref})`);

            core.setOutput('number', String(fullPR.number));
            core.setOutput('head_ref', fullPR.head.ref);
            core.setOutput('head_sha', fullPR.head.sha || '');
            core.setOutput('title', fullPR.title || '');
            core.setOutput('body', fullPR.body || '');

      - name: Checkout revert branch
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 1
          submodules: false
          ref: ${{ steps.find-base.outputs.head_ref }}

      - name: Authenticate submodules
        run: |
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Bump submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ needs.detect-submodules.outputs.submodules }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{ steps.find-base.outputs.head_ref }}
        with:
          script: |
            const { execSync } = require('child_process');
            const branch = process.env.BRANCH;
            if (!branch) {
              core.setFailed('‚ùå No branch name supplied to bump-submodules');
              process.exit(1);
            }
            const submodules = JSON.parse(process.env.SUBMODULES || '[]');
            let changed = false;

            for (const sub of submodules) {
              console.log(`üîß Updating submodule ${sub.repo} at ${sub.path}`);
              const urlWithToken = sub.url.replace(/^https:\/\//, `https://${process.env.TOKEN}@`);
              execSync(`git submodule update --init ${sub.path}`, { stdio: 'inherit' });

              const defaultBranch = execSync(
                `git ls-remote --symref ${urlWithToken} HEAD | grep '^ref:' | awk '{print $2}' | sed 's|refs/heads/||'`,
                { encoding: 'utf8' }
              ).trim();

              execSync(`git -C ${sub.path} fetch origin ${defaultBranch}:${defaultBranch}`, { stdio: 'inherit' });
              const latest = execSync(`git ls-remote ${urlWithToken} refs/heads/${defaultBranch} | awk '{print $1}'`, { encoding: 'utf8' }).trim();
              const current = execSync(`git -C ${sub.path} rev-parse HEAD`, { encoding: 'utf8' }).trim();

              if (current !== latest) {
                console.log(`‚ö†Ô∏è Resetting ${sub.repo} to ${latest}`);
                execSync(`git -C ${sub.path} reset --hard ${latest}`, { stdio: 'inherit' });
                execSync(`git add ${sub.path}`);
                changed = true;
              } else {
                console.log(`‚úÖ ${sub.repo} up-to-date`);
              }
            }

            if (changed) {
              execSync('git config user.name "github-actions[bot]"');
              execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
              execSync(`git commit -m "Bump submodules to latest default branch"`);
              execSync(`git push origin ${branch}`);
            } else {
              console.log('‚úÖ All submodules already up-to-date');
            }

  merge-base-revert-pr:
    needs:
      - bump-base-revert-pr
    runs-on: ubuntu-latest
    steps:
      - name: Merge base revert PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const revertNumber = parseInt('${{ needs.bump-base-revert-pr.outputs.revert_number }}', 10);
            if (!revertNumber) {
              core.setFailed('‚ùå No revert PR number found to merge.');
              return;
            }
            core.info(`üîÑ Merging revert PR #${revertNumber}`);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: revertNumber,
              merge_method: 'squash'
            });
            core.info(`‚úÖ Successfully merged revert PR #${revertNumber}`);
