name: Auto-Revert Submodules + Base PR

on:
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: write
  issues: write
  actions: write

env:
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  detect-submodules:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      submodules: ${{ steps.extract.outputs.submodules }}
    steps:
      - id: extract
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            const cache = comments.find(c => /<!-- SUBMODULES_JSON -->/.test(c.body));
            if (!cache) { core.setOutput("submodules", "[]"); return; }
            const jsonMatch = cache.body.match(/```json\s*([\s\S]*?)\s*```/);
            core.setOutput('submodules', jsonMatch ? jsonMatch[1] : "[]");

  # Create the revert PR for the *base* PR **as soon as possible**
  create-revert-base:
    needs: detect-submodules
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      revert_pr_number: ${{ steps.create.outputs.revert_pr_number }}
      revert_branch:    ${{ steps.create.outputs.revert_branch }}
    steps:
      - name: Create revert PR via GraphQL
        id: create
        uses: actions/github-script@v7
        env:
          CROSS_TOKEN: ${{ env.CROSS_TOKEN }}
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            if (!pr.merged) {
              core.setFailed('Base PR is not merged ‚Äì nothing to revert.');
              return;
            }

            // 1Ô∏è‚É£ Revert the merged PR
            const revertResp = await github.graphql(`
              mutation($input: RevertPullRequestInput!) {
                revertPullRequest(input: $input) {
                  pullRequest {
                    number
                    headRefName
                  }
                }
              }
            `, {
              input: { pullRequestId: pr.node_id }
            });

            const revertPR = revertResp.revertPullRequest.pullRequest;
            core.setOutput('revert_pr_number', revertPR.number);
            core.setOutput('revert_branch', revertPR.headRefName);
            core.info(`üîÑ Created revert PR #${revertPR.number} (branch: ${revertPR.headRefName})`);

  
  revert-submodules:
    needs: detect-submodules
    if: needs.detect-submodules.outputs.submodules != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        submod: ${{ fromJson(needs.detect-submodules.outputs.submodules) }}
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\/|\.git$/g,'').split('/');
            const prNumber = sub.pr_number;
            core.info(`üîç Processing PR #${prNumber} in ${repo}`);
            // Get PR Node ID via GraphQL
            const prNodeQuery = `
              query($owner: String!, $repo: String!, $prNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $prNumber) {
                    id
                    merged
                  }
                }
              }
            `;
            const prNodeResp = await github.graphql(prNodeQuery, { owner, repo, prNumber });
            const prNode = prNodeResp.repository.pullRequest;
            if (!prNode.merged) {
              core.info(`‚ö†Ô∏è PR #${prNumber} in ${repo} is not merged. Skipping.`);
              return;
            }
            const prNodeId = prNode.id;
            const { data: openPRs } = await github.rest.pulls.list({
              owner, repo, state: 'open', sort: 'created', direction: 'desc', per_page: 20
            });
            let revertPR = openPRs.find(p =>
              p.title.includes(`Revert ${sub.name}`) || p.body?.includes(`#${prNumber}`)
            );
            // If no existing revert PR, create it via GraphQL
            if (!revertPR) {
              core.info(`No existing revert PR found for #${prNumber}, creating...`);
              try {
                await github.graphql(`
                  mutation($input: RevertPullRequestInput!) {
                    revertPullRequest(input: $input) {
                      pullRequest { id }
                    }
                  }
                `, { input: { pullRequestId: prNodeId } });
                const { data: recentPRs } = await github.rest.pulls.list({
                  owner, repo, state: 'open', sort: 'created', direction: 'desc', per_page: 5
                });
                revertPR = recentPRs.find(p =>
                  p.title.includes(`Revert "${prNumber}"`) || p.body?.includes(`#${prNumber}`)
                );
                if (!revertPR) throw new Error(`‚ùå Could not find revert PR after creating it for PR #${prNumber}`);
                core.info(`üîÑ Created revert PR #${revertPR.number}`);
              } catch (err) {
                // Handle race condition where GitHub already created a revert PR
                if (err.message.includes('Validation failed: A pull request already exists')) {
                  core.info(`‚ö†Ô∏è A revert PR already exists for #${prNumber}, using existing PR`);
                  revertPR = openPRs.find(p =>
                    p.title.includes(`Revert "${prNumber}"`) || p.body?.includes(`#${prNumber}`)
                  );
                } else {
                  throw err;
                }
              }
            } else {
              core.info(`‚ö†Ô∏è Existing revert PR found #${revertPR.number}, skipping creation`);
            }
            // Merge the revert PR
            await github.rest.pulls.merge({
              owner, repo, pull_number: revertPR.number, merge_method: "squash"
            });
            core.info(`‚úÖ Successfully merged revert PR #${revertPR.number} for original PR #${prNumber}`);
  aggregate:
    needs: revert-submodules
    runs-on: ubuntu-latest
    steps:
      - run: echo "All submodule reverts completed. Ready to bump."
  
  bump-submodules:
    needs:
      - detect-submodules
      - create-revert-base
      - aggregate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout revert branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ env.CROSS_TOKEN }}
          # Use the branch created by the revert‚ÄëPR job
          ref: ${{ needs.create-revert-base.outputs.revert_branch }}

      - name: Authenticate submodules
        run: |
          git config --global url."https://${{ env.CROSS_TOKEN }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive

      - name: Bump submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ needs.detect-submodules.outputs.submodules }}
          TOKEN: ${{ env.CROSS_TOKEN }}
          BRANCH: ${{ needs.create-revert-base.outputs.revert_branch }}
        with:
          script: |
            const { execSync } = require('child_process');
            const submodules = JSON.parse(process.env.SUBMODULES);
            let changed = false;

            for (const sub of submodules) {
              console.log(`üîß Updating submodule ${sub.repo} at ${sub.path}`);
              const urlWithToken = sub.url.replace(/^https:\/\//, `https://${process.env.TOKEN}@`);
              execSync(`git submodule update --init ${sub.path}`, { stdio: 'inherit' });

              const defaultBranch = execSync(
                `git ls-remote --symref ${urlWithToken} HEAD | grep '^ref:' | awk '{print $2}' | sed 's|refs/heads/||'`,
                { encoding: 'utf8' }
              ).trim();

              execSync(`git -C ${sub.path} fetch origin ${defaultBranch}:${defaultBranch}`, { stdio: 'inherit' });
              const latest = execSync(`git ls-remote ${urlWithToken} refs/heads/${defaultBranch} | awk '{print $1}'`, { encoding: 'utf8' }).trim();
              const current = execSync(`git -C ${sub.path} rev-parse HEAD`, { encoding: 'utf8' }).trim();

              if (current !== latest) {
                console.log(`‚ö†Ô∏è Resetting ${sub.repo} to ${latest}`);
                execSync(`git -C ${sub.path} reset --hard ${latest}`, { stdio: 'inherit' });
                execSync(`git add ${sub.path}`);
                changed = true;
              } else {
                console.log(`‚úÖ ${sub.repo} up-to-date`);
              }
            }

            if (changed) {
              execSync('git config user.name "github-actions[bot]"');
              execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
              execSync(`git commit -m "Bump submodules to latest default branch"`);
              execSync(`git push origin ${process.env.BRANCH}`);
            } else {
              console.log('‚úÖ All submodules already up-to-date');
            }

  # Merge the base revert‚ÄëPR that was created first
  merge-revert-base:
    needs:
      - bump-submodules
      - create-revert-base
    runs-on: ubuntu-latest
    steps:
      - name: Merge revert PR
        uses: actions/github-script@v7
        env:
          CROSS_TOKEN: ${{ env.CROSS_TOKEN }}
        with:
          github-token: ${{ env.CROSS_TOKEN }}
          script: |
            const revertNumber = ${{ needs.create-revert-base.outputs.revert_pr_number }};
            core.info(`üîÑ Merging revert PR #${revertNumber}`);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: revertNumber,
              merge_method: "squash"
            });
            core.info(`‚úÖ Successfully merged revert PR #${revertNumber}`);
