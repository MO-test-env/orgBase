name: Revert chain

on:
  issue_comment:
    types: [created]

permissions:
  pull-requests: write
  contents: write
  issues: write
  actions: write

env:
  RW_PAT: ${{ secrets.WORKFLOWS }}

jobs:
  revert-chain:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/revert' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout base repo
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0
          submodules: recursive

      - name: Get merged PR info
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNum = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNum
            });
            if (!pr.merged) {
              core.setFailed('Base PR is not merged ‚Äì nothing to revert.');
              return;
            }
            core.setOutput('merge_sha', pr.merge_commit_sha);
            core.setOutput('base_branch', pr.base.ref);
            core.setOutput('title', pr.title);

      - name: Create revert branch and commit
        id: revert
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin ${{ steps.pr.outputs.base_branch }}
          git checkout -b revert-${{ github.event.issue.number }} origin/${{ steps.pr.outputs.base_branch }}
          git revert -m 1 ${{ steps.pr.outputs.merge_sha }} || true
          git commit -am "Revert: ${{ steps.pr.outputs.title }}" || echo "No changes to commit"
          git push origin HEAD

      - name: Create PR for base revert
        id: create-base-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            const revertBranch = `revert-${prNumber}`;
            const { data: newPR } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Revert "${{ steps.pr.outputs.title }}"`,
              head: revertBranch,
              base: "${{ steps.pr.outputs.base_branch }}",
              body: `This reverts PR #${prNumber}`,
            });
            core.setOutput('revert_pr', newPR.number);
            core.info(`‚úÖ Created base revert PR #${newPR.number}`);

      - name: Detect submodule changes from merged SHA
        id: detect-submodules
        run: |
          echo "üîç Detecting submodule diffs..."
          git diff-tree -r --summary ${{ steps.pr.outputs.merge_sha }} | grep "^Submodule" || true
          git diff-tree -r --summary ${{ steps.pr.outputs.merge_sha }} | awk '/Submodule/ {print $2}' > changed_subs.txt || true
          if [ -s changed_subs.txt ]; then
            echo "Detected submodules:"
            cat changed_subs.txt
            echo "submodules=$(cat changed_subs.txt | xargs)" >> $GITHUB_OUTPUT
          else
            echo "No submodules changed."
          fi

      - name: Revert submodule PRs
        if: steps.detect-submodules.outputs.submodules != ''
        env:
          RW_PAT: ${{ env.RW_PAT }}
          SUBS: ${{ steps.detect-submodules.outputs.submodules }}
        run: |
          set -e
          for sub in $SUBS; do
            echo "üîÑ Processing submodule: $sub"
            url=$(git config -f .gitmodules submodule.${sub}.url)
            if [ -z "$url" ]; then
              echo "‚ö†Ô∏è Could not determine URL for $sub"
              continue
            fi
            echo "‚û°Ô∏è Cloning $url"
            git clone https://${RW_PAT}@${url#https://} ${sub}
            cd ${sub}
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            base_branch=$(git remote show origin | grep "HEAD branch" | awk '{print $NF}')
            git fetch origin $base_branch
            git checkout -b revert-sub-${GITHUB_RUN_ID} origin/$base_branch
            latest_commit=$(git rev-parse HEAD)
            if ! git revert -m 1 $latest_commit; then
              echo "‚ö†Ô∏è Could not revert cleanly for $sub, skipping"
              git revert --abort || true
              cd ..
              continue
            fi
            git push origin HEAD
            echo "üîÅ Creating PR in $url"
            owner_repo=$(echo $url | sed -E 's|https://github.com/||;s|.git$||')
            owner=$(echo $owner_repo | cut -d/ -f1)
            repo=$(echo $owner_repo | cut -d/ -f2)
            gh api repos/${owner}/${repo}/pulls \
              -f title="Revert latest submodule commit" \
              -f head=revert-sub-${GITHUB_RUN_ID} \
              -f base=$base_branch \
              -f body="Auto-revert of latest commit triggered by /revert in parent repo"
            pr_num=$(gh api repos/${owner}/${repo}/pulls --jq '.[0].number')
            echo "Merging PR #${pr_num} in ${repo}"
            gh api repos/${owner}/${repo}/pulls/${pr_num}/merge -f merge_method=squash
            cd ..
          done

      - name: Update submodules after revert
        run: |
          git submodule update --init --recursive
          git add .
          git commit -m "Update submodules after revert" || echo "No submodule updates"
          git push origin HEAD

      - name: Ensure base revert PR branch is up to date
        run: |
          gh pr checkout ${{ steps.create-base-pr.outputs.revert_pr }}
          gh pr merge ${{ steps.create-base-pr.outputs.revert_pr }} --rebase --auto --merge || \
          echo "‚ö†Ô∏è Could not auto-merge, please resolve conflicts manually."
        env:
          GH_TOKEN: ${{ env.RW_PAT }}
