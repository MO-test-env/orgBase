name: Squash

on:
  workflow_call:
    inputs:
      username:
        description: 'User that triggered the workflow'
        required: true
        type: string
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  USERNAME: ${{ inputs.username }}
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

concurrency:
  group: squash-operations-${{ inputs.owner }}-${{ inputs.repo }}
  cancel-in-progress: false

jobs:
  squash-pr:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Comment start
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n # ðŸ—œï¸ Squash workflow started #\n";
            appendMsg = appendMsg + `[ðŸ–¥ï¸ View this workflow run](${runUrl})`;
            appendMsg = appendMsg + "\n**_(Step 1/3)_** Initializing \n - Checking user permissions.";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Squash commits
        id: squash
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const prNumber = process.env.PR_NUMBER;
            
            try {
              // Get the PR details
              const pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });
              
              // Get commits for this PR
              const commitsResponse = await github.rest.pulls.listCommits({
                owner,
                repo,
                pull_number: prNumber,
              });
              
              const commits = commitsResponse.data;
              if (commits.length === 0) {
                throw new Error("No commits found in PR");
              }
              
              // For a single commit, we don't need to squash
              if (commits.length === 1) {
                core.info("Only one commit found, no squashing needed");
                core.setOutput("squash_result", "success");
                return;
              }
              
              // Get the base commit (first commit in the PR)
              const baseCommitSha = commits[0].sha;
              
              // Get the latest commit (last commit in the PR)
              const latestCommitSha = commits[commits.length - 1].sha;
              
              // Get the commit before the base commit on the target branch
              // We need to get the base of the PR (the commit on the target branch that this PR is based on)
              const baseOfPr = pr.data.base.sha;
              
              // Get the tree for the base of the PR
              const baseCommitResponse = await github.rest.repos.getCommit({
                owner,
                repo,
                ref: baseOfPr,
              });
              
              const baseTreeSha = baseCommitResponse.data.commit.tree.sha;
              
              // Get the diff between the base of the PR and latest commit
              const diffResponse = await github.rest.repos.compareCommits({
                owner,
                repo,
                basehead: `${baseOfPr}...${latestCommitSha}`,
              });
              
              // Create a new tree with the combined changes
              const treeItems = [];
              
              // Process each file change in the diff
              for (const file of diffResponse.data.files) {
                if (file.status === "added" || file.status === "modified") {
                  treeItems.push({
                    path: file.filename,
                    mode: "100644",
                    type: "blob",
                    content: file.patch ? 
                      // Extract the file content from the patch
                      extractFileContentFromPatch(file.patch) : 
                      ""
                  });
                } else if (file.status === "removed") {
                  // For removed files, we don't add them to the tree
                  continue;
                }
              }
              
              // Create the new tree
              const newTreeResponse = await github.rest.git.createTree({
                owner,
                repo,
                tree: treeItems,
                base_tree: baseTreeSha,
              });
              
              const newTreeSha = newTreeResponse.data.sha;
              
              // Create a new commit with the squashed changes
              const newCommitResponse = await github.rest.git.createCommit({
                owner,
                repo,
                message: `Squashed ${commits.length} commits\n\n${commits.map(c => c.commit.message).join("\n\n").substring(0, 65535)}`,
                tree: newTreeSha,
                parents: [baseOfPr], // Use the base of the PR as the parent
              });
              
              const newCommitSha = newCommitResponse.data.sha;
              
              // Update the PR branch with the new commit
              const prHeadRef = pr.data.head.ref;
              await github.rest.git.updateRef({
                owner,
                repo,
                ref: `heads/${prHeadRef}`,
                sha: newCommitSha,
                force: true,
              });
              
              core.info(`Successfully squashed ${commits.length} commits (${baseOfPr.substring(0, 8)} to ${latestCommitSha.substring(0, 8)}) into a single commit ${newCommitSha.substring(0, 8)}`);
              core.setOutput("squash_result", "success");
            } catch (error) {
              core.setFailed(`Failed to squash commits: ${error.message}`);
              core.setOutput("squash_result", "failed");
            }
            
            // Helper function to extract file content from patch
            function extractFileContentFromPatch(patch) {
              // This is a simplified implementation
              // In practice, you might want to use a proper diff parser
              const lines = patch.split('\n');
              let content = '';
              let inHunk = false;
              
              for (const line of lines) {
                if (line.startsWith('@@')) {
                  inHunk = true;
                  continue;
                }
                
                if (inHunk && line.startsWith('+')) {
                  content += line.substring(1) + '\n';
                } else if (inHunk && line.startsWith('-')) {
                  // Skip removed lines
                  continue;
                } else if (inHunk && line.startsWith(' ')) {
                  // Context lines are kept
                  content += line.substring(1) + '\n';
                }
              }
              
              return content;
            }

      - name: Comment result
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            
            // Get the squash result from the previous step
            const squashResult = process.env.SQUASH_RESULT || "success";
            let appendMsg = "";
            
            if (squashResult === "success") {
              appendMsg = "\n - Commits squashed successfully!";
            } else {
              appendMsg = "\n - Failed to squash commits. Please check the workflow logs.";
            }
            
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });