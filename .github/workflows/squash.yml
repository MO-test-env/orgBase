name: Squash

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR Number"
        required: true
        type: number
        default: 78

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.GITHUB_TOKEN }}

jobs:
  squash-pr:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Squash 
        id: squash
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = parseInt("${{ inputs.pr_number }}");
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Get PR metadata
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });

            // Get all commits in PR
            const { data: commits } = await github.rest.pulls.listCommits({
              owner,
              repo,
              pull_number: prNumber
            });

            if (commits.length <= 1) {
              core.setOutput("squash_needed", "false");
              core.info("PR has only one commit; skipping squash.");
              return;
            }

            core.info(`Found ${commits.length} commits in PR #${prNumber}`);

            const firstCommit = commits[0];
            const headCommit = commits[commits.length - 1];

            // Get the head commit tree
            const { data: headCommitData } = await github.rest.git.getCommit({
              owner,
              repo,
              commit_sha: headCommit.sha
            });

            // Get the FIRST PR commit’s parent
            // This is the correct parent for the squashed commit
            const { data: firstCommitData } = await github.rest.git.getCommit({
              owner,
              repo,
              commit_sha: firstCommit.sha
            });

            const parentSha = firstCommitData.parents[0].sha;
            core.info(`Using first PR commit’s parent as squash parent: ${parentSha}`);

            // Build commit message
            const squashMessage = `${pr.data.title}\n\n${pr.data.body || ''}\n\nSquashed commits: ${commits.length} (preserving original author and signature)`;

            // Get the author, committer, and signature information from the head commit to preserve metadata
            const author = headCommitData.author;
            const committer = headCommitData.committer;
            
            // Check if the head commit has a signature
            const signature = headCommitData.verification && headCommitData.verification.signature ? headCommitData.verification.signature : null;
            const payload = headCommitData.verification && headCommitData.verification.payload ? headCommitData.verification.payload : null;
            
            core.info(`Preserving original author metadata: ${author.name} <${author.email}>`);
            if (signature) {
              core.info(`Preserving original commit signature`);
            }
            
            // Create the new squashed commit with preserved author, committer, and signature metadata
            let commitOptions = {
              owner,
              repo,
              message: squashMessage,
              tree: headCommitData.tree.sha,
              parents: [parentSha],
              author: {
                name: author.name,
                email: author.email,
                date: author.date
              },
              committer: {
                name: committer.name,
                email: committer.email,
                date: committer.date
              }
            };
            
            // Add signature if available
            if (signature && payload) {
              commitOptions.signature = signature;
            }
            
            const { data: newCommit } = await github.rest.git.createCommit(commitOptions);

            // Force-update the PR branch to point to the new squash commit
            const branchRef = pr.data.head.ref;

            await github.rest.git.updateRef({
              owner,
              repo,
              ref: `heads/${branchRef}`,
              sha: newCommit.sha,
              force: true
            });

            core.info(`Squash completed. New commit: ${newCommit.sha}`);
            core.setOutput("squash_result", "success");
