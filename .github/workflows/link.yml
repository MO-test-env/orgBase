name: Link/Investigate submodules

on:
  workflow_call:
    inputs:
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'Base PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  MIN_REVIEWERS: 2
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  BASE_PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

jobs:
  link-submods:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Comment start
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n# üîó Submodule Link Workflow\n";
            appendMsg += `[üñ•Ô∏è View workflow](${runUrl})\n`;
            appendMsg += "**_(Step 1/2)_** Fetching PR details and submodule info...";
            await github.rest.issues.updateComment({ owner, repo, comment_id: commentId, body: appendMsg, });

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            
            // Get default branch of base repo 
            const { data: repo } = await github.rest.repos.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
            });
            core.setOutput("default_branch", repo.default_branch);
            core.setOutput("isMergeIntoDefaultBranch", pr.data.base.ref == repo.default_branch);
            
            // Get reviewers for the PR
            const { data: reviewData } = await github.rest.pulls.listRequestedReviewers({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            // Get all reviewers (both users and teams)
            const reviewers = reviewData.users ? reviewData.users.map(user => user.login) : [];
            const teamReviewers = reviewData.teams ? reviewData.teams.map(team => team.slug) : [];
            
            // Get assignees
            const assignees = pr.data.assignees ? pr.data.assignees.map(assignee => assignee.login) : [];
            
            core.setOutput("reviewers", JSON.stringify(reviewers));
            core.setOutput("team_reviewers", JSON.stringify(teamReviewers));
            core.setOutput("assignees", JSON.stringify(assignees));
            
            core.info(`Reviewers: ${JSON.stringify(reviewers)}`);
            core.info(`Team Reviewers: ${JSON.stringify(teamReviewers)}`);
            core.info(`Assignees: ${JSON.stringify(assignees)}`);

      - name: Determine changed submodules from PR diff
        id: changed-submodules
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.BASE_PR_NUMBER;

            // Get file list from GitHub PR diff
            const { data: files } = await github.rest.pulls.listFiles({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
              per_page: 300
            });

            // Any file that is a submodule appears with `status = modified` and `patch = null`
            // and type "submodule" in getContent (later)
            const changedSubmodulePaths = files
              .filter(f => f.filename && f.status !== "removed")
              .map(f => f.filename.split("/")[0]); // top-level folder of filename

            const unique = [...new Set(changedSubmodulePaths)];

            core.info(`Changed top-level paths from PR: ${JSON.stringify(unique)}`);
            core.setOutput("changed_paths", JSON.stringify(unique));

      - name: Parse .gitmodules
        id: parse-gitmodules
        uses: actions/github-script@v7
        env:
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          CHANGED_PATHS: ${{ steps.changed-submodules.outputs.changed_paths }}
        with:
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const baseRef = process.env.BASE_REF;
            const changedPaths = JSON.parse(process.env.CHANGED_PATHS || "[]");

            // Load .gitmodules
            let content = "";
            try {
              const { data: f } = await github.rest.repos.getContent({
                owner,
                repo,
                path: ".gitmodules",
                ref: baseRef
              });

              content = Buffer.from(f.content, "base64").toString("utf8");
            } catch (err) {
              core.setFailed("Failed to load .gitmodules: " + err.message);
              return;
            }

            const lines = content.split("\n");
            const rawSubmodules = {};
            let current = null;

            for (const line of lines) {
              const sub = line.match(/\[submodule \"(.*)\"\]/);
              const path = line.match(/\s*path = (.*)/);
              const url = line.match(/\s*url = (.*)/);
              const br = line.match(/\s*branch = (.*)/);

              if (sub) {
                current = sub[1];
                rawSubmodules[current] = {};
              } else if (current && path) {
                rawSubmodules[current].path = path[1].trim();
              } else if (current && url) {
                rawSubmodules[current].url = url[1].trim();
              } else if (current && br) {
                rawSubmodules[current].configuredBranch = br[1].trim();
              }
            }

            // Filter submodules: only ones whose top-level folder changed in PR
            for (const name of Object.keys(rawSubmodules)) {
              const p = rawSubmodules[name].path;
              const top = p.split("/")[0];
              if (!changedPaths.includes(top)) {
                delete rawSubmodules[name];
              }
            }

            core.info("Filtered raw submodules:");
            core.info(JSON.stringify(rawSubmodules, null, 2));
            core.setOutput("raw_submodules", JSON.stringify(rawSubmodules));

      - name: Enrich submodules (default branches, repoName, baseBranch)
        id: enrich-gitmodules
        uses: actions/github-script@v7
        env:
          RAW_SUBMODULES: ${{ steps.parse-gitmodules.outputs.raw_submodules }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          IS_MERGE_INTO_DEFAULT_BRANCH: ${{ steps.pr.outputs.isMergeIntoDefaultBranch }}
        with:
          script: |
            const raw = JSON.parse(process.env.RAW_SUBMODULES || "{}");
            const baseRef = process.env.BASE_REF;
            const owner = process.env.OWNER;

            const enriched = {};

            for (const [name, data] of Object.entries(raw)) {
              const { path, url, configuredBranch } = data;

              if (!path || !url) continue;

              //  derive repoName from URL 
              let repoName = null;

              if (url.startsWith("https://github.com/")) {
                repoName = url.replace("https://github.com/", "")
                              .replace(".git", "")
                              .split("/")[1];
              } else if (url.startsWith("git@github.com:")) {
                repoName = url.replace("git@github.com:", "")
                              .replace(".git", "")
                              .split("/")[1];
              } else if (url.startsWith("../")) {
                repoName = url.replace("../", "").replace(".git", "");
              } else {
                repoName = url.split(/[\/:]/).pop().replace(".git", "");
              }

              core.info(`Submodule ${name} resolves repoName: ${repoName}`);

              //  load default branch 
              let subDefaultBranch = null;
              try {
                const { data: repoInfo } = await github.rest.repos.get({
                  owner,
                  repo: repoName
                });
                subDefaultBranch = repoInfo.default_branch;
              } catch (err) {
                core.warning(`Failed repo lookup for ${repoName}: ${err.message}`);
                continue;
              }

              //  compute baseBranch 
              let baseBranch;
            if (process.env.IS_MERGE_INTO_DEFAULT_BRANCH === 'true')  {
              baseBranch = subDefaultBranch;
              core.info(`Using default branch '${baseBranch}' for submodule ${name}`);
            } else {
              baseBranch = baseRef;
              core.info(`Using PR base_ref '${baseBranch}' for submodule ${name}`);
            }

            enriched[name] = {
              path,
              url,
              repoName,
              configuredBranch,
              subDefaultBranch,
              baseBranch
            };
            
            core.info("Enriched submodules:");
            core.info(JSON.stringify(enriched, null, 2));
            core.setOutput("git_modules", JSON.stringify(enriched));
      
      - name: Update submodules with SHA, PR branch, and PR number
        id: diff-getprbr-getprnum
        uses: actions/github-script@v7
        env:
          GIT_MODULES: ${{ steps.enrich-gitmodules.outputs.git_modules }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          script: |
            const gitModules = JSON.parse(process.env.GIT_MODULES || "{}");
            const submod_with_pr_branches = {};

            if (Object.keys(gitModules).length === 0) {
              core.info("No changed submodules to process.");
              core.setOutput("submod_with_pr_branches", "{}");
              return;
            }

            // Helper: check if sha is anywhere on a branch (not only HEAD)
            async function shaInBranch(owner, repo, branch, sha) {
              try {
                const { data: commits } = await github.rest.repos.listCommits({
                  owner,
                  repo,
                  sha: branch,
                  per_page: 100
                });
                return commits.some(c => c.sha === sha);
              } catch (err) {
                return false;
              }
            }

            for (const [submodule, submoduleData] of Object.entries(gitModules)) {
              try {
                // Get the SHA of the submodule from the PR branch
                const { data: prContent } = await github.rest.repos.getContent({
                  owner: process.env.OWNER,
                  repo: process.env.REPO,
                  path: submoduleData.path,
                  ref: process.env.PR_BRANCH
                });

                if (!prContent || prContent.type !== "submodule") {
                  // Not submodule change so ignore
                  continue;
                }

                const sha = prContent.sha;
                const repoName = submoduleData.repoName || submoduleData.url.split('/').pop().replace('.git','');
                const submodBaseBranch = submoduleData.baseBranch;

                let branchesContainingSha = [];
                let prBranch = null;
                let prNumber = null;

                // Try to find branches where the SHA is at the head. This is very important to help create the PRs 
                try {
                  const { data: branches } = await github.rest.repos.listBranchesForHeadCommit({
                    owner: process.env.OWNER,
                    repo: repoName,
                    commit_sha: sha
                  });
                  branchesContainingSha = branches.map(b => b.name);
                } catch (err) {
                  core.warning(`Could not list branches for head commit ${sha}: ${err.message}`);
                }

                // Check if SHA is on the default branch (like if delivered or reverted)
                let isShaOnBaseBranch = false;
                if (submodBaseBranch) {
                  isShaOnBaseBranch = await shaInBranch(process.env.OWNER, repoName, submodBaseBranch, sha);
                }

                // Find all PRs associated with the commit
                let prs = [];
                try {
                  const { data: prList } =
                    await github.rest.repos.listPullRequestsAssociatedWithCommit({
                      owner: process.env.OWNER,
                      repo: repoName,
                      commit_sha: sha
                    });
                  prs = prList;
                } catch (err) {
                  core.warning(`Unable to find PRs associated with ${sha}: ${err.message}`);
                }

                const openPRs = prs.filter(pr => pr.state === "open");
                const mergedPRs = prs.filter(pr => pr.merged_at);

                // SHA on delivery branch 
                if (isShaOnBaseBranch) {
                  prBranch = submodBaseBranch;
                  prNumber = 0;
                }

                // SHA has exactly one open PR
                else if (openPRs.length === 1) {
                  const prObj = openPRs[0];
                  prBranch = prObj.head.ref;
                  prNumber = prObj.number;

                  // warning if head-of-branch contradicts PR branch
                  if (branchesContainingSha.length === 1 && branchesContainingSha[0] !== prBranch) {
                    core.warning(
                      `SHA ${sha} is HEAD of '${branchesContainingSha[0]}' but open PR uses branch '${prBranch}'.`
                    );
                  }
                }

                // SHA has merged PR(s)
                else if (mergedPRs.length >= 1) {
                  const latest = mergedPRs.sort(
                    (a, b) => new Date(b.merged_at) - new Date(a.merged_at)
                  )[0];

                  prBranch = latest.head.ref;
                  prNumber = latest.number;
                }

                // SHA is HEAD of exactly one branch ‚Üí no PR yet
                else if (branchesContainingSha.length === 1) {
                  prBranch = branchesContainingSha[0];
                  prNumber = -1;
                }

                // SHA is HEAD of multiple branches ‚Üí ambiguous
                else if (branchesContainingSha.length > 1) {
                  core.setFailed(
                    `SHA ${sha} is HEAD of multiple branches (${branchesContainingSha}) and has no PR.`
                  );
                  return;
                }

                // No PRs, not on head, not on base branch ‚Üí fail
                else {
                  core.setFailed(
                    `Could not determine PR or branch for SHA ${sha}. Not on default branch, not head of branch, no PRs.`
                  );
                  return;
                }

                // Save result
                submodulesWithPrBranches[submodule] = {
                  ...submoduleData,
                  sha,
                  prBranch,
                  prNumber
                };

                core.info(`Resolved ${submodule}: sha=${sha}, branch=${prBranch}, prNumber=${prNumber}`);

              } catch (err) {
                core.setFailed(`Error processing submodule ${submodule}: ${err.message}`);
                return;
              }
            }

            const submodulesWithPrBranchesJSON = JSON.stringify(submodulesWithPrBranches, null, 2);
            core.info("Added sha, PR branch, and PR number:");
            core.info(submodulesWithPrBranchesJSON);

            core.setOutput('submod_with_pr_branches', submodulesWithPrBranchesJSON);


      - name: Pre-check all Submodules and add additional submodule fields 
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-getprbr-getprnum.outputs.submod_with_pr_branches }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          BASE_BRANCH: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodulesAfterPrecheck = {};
            const prBranchName = process.env.PR_BRANCH;
            const baseBranchName = process.env.BASE_BRANCH;
            
            for (const [name, sub] of Object.entries(submods)) { 
              let prNumber = sub.prNumber;
              // If we already have a PR number from the previous step, use it
              if (prNumber !== null && prNumber !== undefined) {
                if (prNumber === 0) {
                  // Already merged (no pre-check needed)
                  submodulesAfterPrecheck[name] = {
                    ...sub,
                    prLink: null,
                    isPRCreated: false,
                    merged: true,
                    mergeableState: 'clean', 
                    approvals: null,
                  };
                } else if (prNumber === -1) {
                  // PR not created yet (no precheck needed)
                  submodulesAfterPrecheck[name] = {
                    ...sub,
                    prLink: null,
                    isPRCreated: false,
                    merged: false, 
                    approvals: null,
                  };
                } else {
                  // PR exists, need to pre-check/ fetch more info 
                    try {
                      // Check mergeability/ conflicts
                      // Retry logic for getting PR info when merged or mergeable_state is undefined
                      let prInfo = null;
                      let retryCount = 0;
                      const maxRetries = 3;
                      const retryDelay = 1000; // 1 second delay between retries
                      
                      while (retryCount <= maxRetries) {
                        try {
                          const response = await github.rest.pulls.get({
                            owner: process.env.OWNER,
                            repo: sub.repoName,
                            pull_number: prNumber
                          });
                          prInfo = response.data;
                          
                          // Check if we got the required information
                          if (prInfo.merged !== undefined && prInfo.mergeable_state !== undefined) {
                            break; // Success, exit retry loop
                          }
                          
                          // If we don't have the required info, retry if we haven't exceeded max retries
                          if (retryCount < maxRetries) {
                            retryCount++;
                            core.info(`PR info incomplete (merged: ${prInfo.merged}, mergeable_state: ${prInfo.mergeable_state}), retrying... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                          } else {
                            break; // Max retries reached
                          }
                        } catch (error) {
                          // If we get an error and haven't exceeded max retries, retry
                          if (retryCount < maxRetries) {
                            retryCount++;
                            core.info(`Error getting PR info: ${error.message}, retrying... (${retryCount}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                          } else {
                            throw error; // Re-throw if max retries reached
                          }
                        }
                      }
                      
                      // If we still don't have the required info after retries, log a warning
                      if (prInfo.merged === undefined || prInfo.mergeable_state === undefined) {
                        core.warning(`PR info still incomplete after retries (merged: ${prInfo.merged}, mergeable_state: ${prInfo.mergeable_state})`);
                      }

                      // Check approvals 
                      const { data: reviews } = await github.rest.pulls.listReviews({
                        owner: process.env.OWNER,
                        repo: sub.repoName,
                        pull_number: prNumber,
                      });
                      
                      const latestByUser = {};
                      for (const review of reviews) {
                        latestByUser[review.user.login] = review.state;
                      }
                      const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
                      const approvalCount = approvedUsers.length;
                      const changeRequestCount = Object.values(latestByUser).filter(s => s === 'CHANGES_REQUESTED').length;
                      const prState = prInfo.number === 0 ? null : prInfo.merged_at ? 'merged' : prInfo.state === 'closed' ? 'closed' : 'open';
                      
                      // Push full object 
                      submodulesAfterPrecheck[name] = {
                        ...sub,
                        prLink: prInfo.html_url,
                        isPRCreated: true,
                        prState: prState,
                        merged: prInfo.merged,
                        mergeableState: prInfo.mergeable_state,
                        approvals: approvalCount,
                        changeRequests: changeRequestCount,
                      };
                    } catch (error) {
                      console.log(`Error getting additional PR info for submodule ${name}: ${error.message}`);
                    }
                }
                continue;
              }
            }
            
            // Convert object to array for output and later steps 
            const submodulesArray = Object.values(submodulesAfterPrecheck);
            const submodulesAfterPrecheckJson = JSON.stringify(submodulesArray, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesAfterPrecheckJson);
              core.setOutput('submod_after_precheck', submodulesAfterPrecheckJson);
            
            // Filter only unmerged submodules
            const unmerged = submodulesArray.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);
            

            // Simple validation: ensure the number of submodules from the diff step matches the number in the pre-check step
            const submodulesFromDiff = JSON.parse(process.env.SUBMODULES_JSON);
            const diffSubmoduleCount = Object.keys(submodulesFromDiff).length;
            const precheckSubmoduleCount = submodulesArray.length;
            
            core.info(`Submodules from diff step: ${diffSubmoduleCount}, Submodules from pre-check step: ${precheckSubmoduleCount}`);
            
            // If the counts don't match, fail
            if (diffSubmoduleCount !== precheckSubmoduleCount) {
              const errorMsg = `Mismatch between submodules from diff step (${diffSubmoduleCount}) and pre-check step (${precheckSubmoduleCount}).`;
              core.setFailed(errorMsg);
              core.setOutput('failMsg', errorMsg);
            } else {
              core.info("Submodule counts match, validation passed.");
            }

      - name: Add reviewers and assignees to submodule PRs
        id: add-reviewers
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submod_after_precheck }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const reviewers = JSON.parse(process.env.REVIEWERS);
            const teamReviewers = JSON.parse(process.env.TEAM_REVIEWERS);
            const assignees = JSON.parse(process.env.ASSIGNEES);
            const owner = process.env.OWNER;
            
            core.info(`Adding reviewers ${JSON.stringify(reviewers)} and team reviewers ${JSON.stringify(teamReviewers)} to submodule PRs`);
            core.info(`Adding assignees ${JSON.stringify(assignees)} to submodule PRs`);
            
            // Process each submodule that has an open PR
            for (const submodule of submodules) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.prNumber) {

                try {
                  // Add reviewers if there are any
                  if (reviewers.length > 0 || teamReviewers.length > 0) {
                    await github.rest.pulls.requestReviewers({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      pull_number: submodule.prNumber,
                      reviewers: reviewers,
                      team_reviewers: teamReviewers
                    });
                  }
                  
                  // Add assignees if there are any
                  if (assignees.length > 0) {
                    await github.rest.issues.addAssignees({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.prNumber,
                      assignees: assignees
                    });
                  }
                } catch (error) {
                  core.warning(`Error adding reviewers/assignees to PR #${submodule.prNumber} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }
            
            // Store information about which PRs had reviewers added
            const prsWithReviewersAdded = submodules
              .filter(s => s.isPRCreated && s.prState === 'open' && s.prNumber)
              .map(s => ({ repo: s.repoName, pr: s.prNumber }));
            
            core.setOutput('prs_with_reviewers_added', JSON.stringify(prsWithReviewersAdded));

      - name: Add comment to submodule PRs linking back to base PR
        id: comment-submod-prs
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submod_after_precheck }}
          BASE_PR_NUMBER: ${{ env.BASE_PR_NUMBER }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodulesAfterPrecheck = JSON.parse(process.env.SUBMODULES_JSON);
            const basePrNumber = process.env.BASE_PR_NUMBER;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            
            core.info(`Adding comments to submodule PRs linking back to base PR #${basePrNumber}`);
            
            // Construct the base PR URL
            const basePrUrl = `https://github.com/${owner}/${repo}/pull/${basePrNumber}`;
            
            // Process each submodule that has an open PR
            for (const submodule of submodulesAfterPrecheck) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.prNumber) {
                try {
                  // Check if there's already a comment linking back to the base PR
                  const existingComments = await github.rest.issues.listComments({
                    owner: process.env.OWNER,
                    repo: submodule.repoName,
                    issue_number: submodule.prNumber,
                    per_page: 100
                  });
                  
                  // Look for an existing comment that links back to the base PR
                  const existingComment = existingComments.data.find(comment => 
                    comment.body && 
                    comment.body.includes('This submodule PR is part of a larger change') 
                  );
                  
                  // Add a comment to the submodule PR linking back to the base PR
                  let commentBody = `## üîó This submodule PR is part of a larger change in the parent repository. \n`;
                  commentBody += `Please review the [base PR #${basePrNumber}](${basePrUrl}) for context on how this submodule change fits into the overall update.`;
                  commentBody += `\n_This comment was automatically added by the submodule linking workflow._`;
                  
                  if (existingComment) {
                    // Update the existing comment
                    await github.rest.issues.updateComment({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      comment_id: existingComment.id,
                      body: commentBody
                    });
                    core.info(`Updated existing comment #${existingComment.id} on PR #${submodule.prNumber} in ${submodule.repoName}`);
                  } else {
                    // Create a new comment
                    await github.rest.issues.createComment({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.prNumber,
                      body: commentBody
                    });
                    core.info(`Added new comment to PR #${submodule.prNumber} in ${submodule.repoName} linking back to base PR #${basePrNumber}`);
                  }
                } catch (error) {
                  core.warning(`Error adding/updating comment to PR #${submodule.prNumber} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }

      - name: Update comment with submodule PR links
        id: update-comment
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submod_after_precheck }}
          PRS_WITH_REVIEWERS: ${{ steps.add-reviewers.outputs.prs_with_reviewers_added }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const submodulesAfterPrecheck = JSON.parse(process.env.SUBMODULES_JSON);
            const prsWithReviewers = JSON.parse(process.env.PRS_WITH_REVIEWERS || '[]');
            
            const { data: comment } = await github.rest.issues.getComment({ owner, repo, comment_id: commentId, });
            
            function getStatusIcon(sub) {
              if (!sub.prBranch) return '‚ùå';
              if (!sub.isPRCreated && sub.prNumber === -1) return 'üîÑ';
              if (!sub.isPRCreated) return '‚òëÔ∏è';
              if (sub.approvals !== null && (sub.approvals < parseInt(process.env.MIN_REVIEWERS) || sub.changeRequests > 0)) return '‚è≥';
              if (sub.isPRCreated) return '‚úÖ';
              return '‚ùì';
            }
            
            function getStatusText(sub) {
              if (!sub.prBranch) return '**Branch missing**';
              if (!sub.isPRCreated && sub.prNumber === -1) return '**Create PR**';
              if (!sub.isPRCreated) return '**PR missing**';
              if (sub.approvals !== null) {
                if (sub.approvals < parseInt(process.env.MIN_REVIEWERS)) return '**Pending approval**';
                if (sub.changeRequests > 0) return '**Changes requested**';
                return '**Approved**';
              }
              return '**PR exists**';
            }
            
            let appendMsg = "\n**_(Step 2/2)_** Submodule Analysis:\n\n";
            appendMsg += "| Status | Submodule | Branch | PR | Approvals | State |\n";
            appendMsg += "|--------|-----------|--------|----|-----------|---------| \n";
            
            submodulesAfterPrecheck.forEach(sub => {
              const icon = getStatusIcon(sub);
              const prDisplay = sub.isPRCreated ? `[#${sub.prNumber}](${sub.prLink})` : (sub.prNumber === 0 ? 'On Delivery Branch' : (sub.prNumber === -1 ? '**Create PR**' : 'none'));
              const approvalsDisplay = sub.approvals !== null ? `${sub.approvals}` : '-';
              let stateDisplay = sub.merged || sub.prState || '-';
              if ( sub.prNumber === '0' ){
                stateDisplay = '-';
              }
              appendMsg += `| ${icon} | \`${sub.path}\` | \`${sub.prBranch}\` | ${prDisplay} | ${approvalsDisplay} | ${stateDisplay} |\n`;
            });
            
            appendMsg += "\n### üéØ Action Items\n\n";
            const missingBranches = submodulesAfterPrecheck.filter(s => !s.prBranch);
            const missingPRs = submodulesAfterPrecheck.filter(s => s.prBranch && !s.isPRCreated && s.prBranch !== s.baseBranch);
            const pendingApprovals = submodulesAfterPrecheck.filter(s => s.isPRCreated && (s.approvals < parseInt(process.env.MIN_REVIEWERS) || s.changeRequests > 0));
            
            // Check if reviewers were added to any PRs
            const reviewersAdded = prsWithReviewers.length > 0;
            
            if (missingBranches.length > 0) {
              appendMsg += `üåø **Create branches**: ${missingBranches.map(s => '`' + s.path + '`').join(', ')}\n`;
            }
            if (missingPRs.length > 0) {
              appendMsg += `üîÑ **Create PRs**:\n`;
              for (const sub of missingPRs) {
                // Skip if the branch is the default branch
                if (sub.prBranch === sub.baseBranch) {
                  continue;
                }
                
                // Extract the branch name from the prBranch property if available
                // Otherwise use the PR branch name from the base PR
                const prBranch = sub.prBranch ? sub.prBranch.replace(/^origin\//, '') : `${{ steps.pr.outputs.head_ref}}`;
                
                // Skip if the branch name is the same as the base branch
                if (prBranch === sub.baseBranch) {
                  continue;
                }
                
                const compareUrl = `https://github.com/${owner}/${sub.repoName}/compare/${sub.baseBranch}...${prBranch}?expand=1`;
                appendMsg += `- [Create PR for ${sub.repoName}](${compareUrl}) (${sub.baseBranch} ‚Üê ${prBranch})\n`;
              }
              appendMsg += '\n';
            }
            if (pendingApprovals.length > 0) {
              appendMsg += `üëÄ **Request reviews**: ${pendingApprovals.map(s => '[' + s.repoName + '#' + s.prNumber + '](' + s.prLink + ')').join(', ')}\n`;
            }
            if (reviewersAdded) {
              const reviewersList = JSON.parse(process.env.REVIEWERS || '[]');
              const teamReviewersList = JSON.parse(process.env.TEAM_REVIEWERS || '[]');
              const assigneesList = JSON.parse(process.env.ASSIGNEES || '[]');
              
              let reviewersInfo = '';
              if (reviewersList.length > 0 || teamReviewersList.length > 0) {
                reviewersInfo += `üë• **Reviewers In Sync** `;
              }
              appendMsg += reviewersInfo;
            }
            if (missingBranches.length === 0 && missingPRs.length === 0 && pendingApprovals.length === 0) {
              appendMsg += `‚úÖ All submodules are ready! Type /merge to merge everything.\n`;
            }
            
            appendMsg += "\n Workflow complete ";
            
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({ owner, repo, comment_id: commentId, body: newBody, });

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_DIFF_SUBMODULES: ${{ steps.diff-getprbr-getprnum.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({ owner: process.env.OWNER, repo: process.env.REPO, comment_id: commentId, });
            
            let failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
            
            if ('${{ steps.diff-getprbr-getprnum.conclusion }}' == 'failure'){
              appendMsg = "Failed to parse submodule diff, get submodule PR branches, or submodule PR numbers." + (process.env.FAIL_MSG_DIFF_SUBMODULES || "");
              resolutionSteps = "_Please ensure you have pushed up your branches or ensure that the base sha is pointing to the right place._";
            } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
              appendMsg = "Submodule pre-check failed. " + (process.env.FAIL_MSG_PRE_CHECK_SUBMOD || "");
              if (appendMsg.includes("Mismatch between submodules needing PRs")) {
                resolutionSteps = "_Please ensure all submodule changes have corresponding PRs. Each updated submodule must have exactly one PR, except for submodules already on their default branch._";
              } else {
                resolutionSteps = "_Please ensure all submodule PRs are created and properly linked._";
              }
            } else {
              appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information.";
              resolutionSteps = "_Please try again later._";
            }
            
            const newBody = comment.body + "\n\n" + failureMsg + appendMsg + "\n" + resolutionSteps;
            await github.rest.issues.updateComment({ owner: process.env.OWNER, repo: process.env.REPO, comment_id: commentId, body: newBody, });
