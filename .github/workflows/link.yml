name: Link/Investigate submodules

on:
  workflow_call:
    inputs:
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  MIN_REVIEWERS: 2
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

jobs:
  link-submods:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Comment start
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n# üîó Submodule Link Workflow\n";
            appendMsg += `[üñ•Ô∏è View workflow](${runUrl})\n`;
            appendMsg += "**_(Step 1/2)_** Fetching PR details and submodule info...";
            await github.rest.issues.updateComment({ owner, repo, comment_id: commentId, body: appendMsg, });

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            // Get reviewers for the PR
            const { data: reviewData } = await github.rest.pulls.listRequestedReviewers({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            // Get all reviewers (both users and teams)
            const reviewers = reviewData.users ? reviewData.users.map(user => user.login) : [];
            const teamReviewers = reviewData.teams ? reviewData.teams.map(team => team.slug) : [];
            
            // Get assignees
            const assignees = pr.data.assignees ? pr.data.assignees.map(assignee => assignee.login) : [];
            
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("reviewers", JSON.stringify(reviewers));
            core.setOutput("team_reviewers", JSON.stringify(teamReviewers));
            core.setOutput("assignees", JSON.stringify(assignees));
            
            core.info(`Reviewers: ${JSON.stringify(reviewers)}`);
            core.info(`Team Reviewers: ${JSON.stringify(teamReviewers)}`);
            core.info(`Assignees: ${JSON.stringify(assignees)}`);

      - name: Read gitmodules file
        id: read-modules-file
        uses: actions/github-script@v7
        env:
          RW_PAT: ${{ env.RW_PAT }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const baseRef = process.env.BASE_REF;
            
            // Get the .gitmodules file content using GitHub API instead of readFileSync
            let gitmodulesContent = '';
            try {
              const { data: gitmodulesFile } = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.gitmodules',
                ref: baseRef
              });
              
              if (gitmodulesFile.content) {
                gitmodulesContent = Buffer.from(gitmodulesFile.content, 'base64').toString('utf8');
              } else {
                core.setFailed('Could not read .gitmodules file content');
                return;
              }
            } catch (error) {
              core.setFailed(`Error reading .gitmodules file: ${error.message}`);
              return;
            }
            
            const gitmodulesLines = gitmodulesContent.split('\n');
            const submodules = {};
            let currentSubmodule = null;
            
            // Process the .gitmodules file line by line to extract all information
            gitmodulesLines.forEach(line => {
              const submoduleMatch = line.match(/\[submodule \"(.*)\"\]/);
              const pathMatch = line.match(/\s*path = (.*)/);
              const urlMatch = line.match(/\s*url = (.*)/);
              const branchMatch = line.match(/\s*branch = (.*)/);
              
              if (submoduleMatch) {
                currentSubmodule = submoduleMatch[1];
                submodules[currentSubmodule] = {};
              } else if (currentSubmodule && pathMatch) {
                submodules[currentSubmodule].path = pathMatch[1].trim();
              } else if (currentSubmodule && urlMatch) {
                submodules[currentSubmodule].url = urlMatch[1].trim();
              } else if (currentSubmodule && branchMatch) {
                // Store the branch from .gitmodules if it exists
                submodules[currentSubmodule].configuredBranch = branchMatch[1].trim();
                core.info(`Found configured branch in .gitmodules: ${branchMatch[1].trim()} for submodule ${currentSubmodule}`);
              }
            });
            
            // Process each submodule to set up the complete information
            for (const name in submodules) {
              if (!submodules[name].path || !submodules[name].url) {
                core.warning(`Incomplete submodule information for ${name}, skipping`);
                delete submodules[name];
                continue;
              }
              
              const path = submodules[name].path;
              let url = submodules[name].url;
              const configuredBranch = submodules[name].configuredBranch; // This might be undefined
              
              // Extract repo name from URL
              let repoName;
              
              // Handle different URL formats
              if (url.startsWith('https://github.com/')) {
                // HTTPS URL format: https://github.com/org/repo.git
                const parts = url.replace('https://github.com/', '').replace('.git', '').split('/');
                if (parts.length >= 2) {
                  orgName = parts[0];
                  repoName = parts[1];
                } else {
                  repoName = parts[0];
                }
              } else if (url.startsWith('git@github.com:')) {
                // SSH URL format: git@github.com:org/repo.git
                const parts = url.replace('git@github.com:', '').replace('.git', '').split('/');
                if (parts.length >= 2) {
                  orgName = parts[0];
                  repoName = parts[1];
                } else {
                  repoName = parts[0];
                }
              } else if (url.startsWith('../')) {
                // Relative URL format: ../repo.git
                repoName = url.replace('../', '').replace('.git', '');
                url = `https://github.com/${owner}/${repoName}.git`;
              } else {
                // Handle any other format
                const parts = url.split(/[\/:]/).filter(Boolean);
                repoName = parts[parts.length - 1].replace('.git', '');
              }

              core.info(`Processing submodule: ${name} with path ${path}, url ${url}, repoName ${repoName}`);
              
              try {
                // Get the default branch for the submodule repository
                const { data: subRepo } = await github.rest.repos.get({
                  owner,
                  repo: repoName
                });
                
                const subDefaultBranch = subRepo.default_branch;
                
              // Branch selection logic: If PR is base_ref is default branch, use the default branch of the submodule, otherwise use the same branch name as base_ref
                let branch;
                if (baseRef === subDefaultBranch) {
                  branch = subDefaultBranch;
                  core.info(`Using default branch '${branch}' for submodule ${name}`);
                } else {
                  branch = baseRef;
                  core.info(`Using base_ref '${branch}' for submodule ${name}`);
                }
                
                submodules[name] = {
                  path,
                  url,
                  baseBranch: branch,
                  configuredBranch,
                  subDefaultBranch,
                  repoName: repoName,
                };
                
              } catch (error) {
                core.setFailed(`Error processing submodule ${name} (${repoName}): ${error.message}`);
                delete submodules[name];
              }
            }
            
            if (Object.keys(submodules).length === 0) {
              core.info("No submodules found in .gitmodules file.");
            }
            
            const json = JSON.stringify(submodules, null, 2);
            core.info("Submodules JSON:");
            core.info(json);
            core.setOutput('git_modules', json);

      - name: Update submodules with SHA and PR branch
        id: diff-submodules
        uses: actions/github-script@v7
        env:
          GIT_MODULES: ${{ steps.read-modules-file.outputs.git_modules }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
        with:
          script: |
            const gitModules = JSON.parse(process.env.GIT_MODULES);
            const updatedModules = {};
            const errors = [];

            // Get the list of changed files in the PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: process.env.PR_NUMBER,
              per_page: 100
            });

            // Process each submodule in parallel
            const submodulePromises = Object.entries(gitModules).map(async ([submodule, submoduleData]) => {
              try {
                // Get the submodule's content from the PR branch
                const { data: prContent } = await github.rest.repos.getContent({
                  owner: process.env.OWNER,
                  repo: process.env.REPO,
                  path: submoduleData.path,
                  ref: process.env.PR_BRANCH
                });

                if (prContent && prContent.type === 'submodule') {
                  const sha = prContent.sha;
                  
                  // Step 1: Try to find branches where the SHA is at the head (most accurate)
                  let normalizedBranches = [];
                  try {
                    const { data: branches } = await github.rest.repos.listBranchesForHeadCommit({
                      owner: process.env.OWNER,
                      repo: submoduleData.repoName || submoduleData.url.split('/').pop().replace('.git', ''),
                      commit_sha: sha
                    });

                    normalizedBranches = branches
                      .map(branch => branch.name)
                      .filter(branch => branch !== 'HEAD' && !branch.startsWith('origin/'));
                  } catch (error) {
                    core.warning(`Error finding branches for head commit ${sha}: ${error.message}`);
                  }

                  // Step 2: If no branches found, try to find PRs containing this SHA
                  if (normalizedBranches.length === 0) {
                    core.info(`No branches with SHA ${sha} as head found for submodule ${submodule}. Looking for PRs containing this SHA...`);
                    try {
                      const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                        owner: process.env.OWNER,
                        repo: submoduleData.repoName || submoduleData.url.split('/').pop().replace('.git', ''),
                        commit_sha: sha
                      });
                      
                      if (prs.length > 0) {
                        // Extract branch names from PRs
                        const prBranches = prs.map(pr => pr.head.ref);
                        normalizedBranches = prBranches.filter(branch => branch !== 'HEAD' && !branch.startsWith('origin/'));
                        core.info(`Found PRs with branches: ${normalizedBranches.join(', ')} containing SHA ${sha}`);
                      }
                    } catch (error) {
                      core.warning(`Error finding PRs for commit ${sha}: ${error.message}`);
                    }
                  }

                  // Step 3: If still no branches found, try to search through all branches (this can be expensive with hundreds of branches)
                  if (normalizedBranches.length === 0) {
                    core.info(`No PRs found with SHA ${sha} for submodule ${submodule}. Searching through branches...`);
                    try {
                      // Get list of branches (limit to 100 to avoid excessive API calls)
                      const { data: allBranches } = await github.rest.repos.listBranches({
                        owner: process.env.OWNER,
                        repo: submoduleData.repoName || submoduleData.url.split('/').pop().replace('.git', ''),
                        per_page: 100
                      });
                      
                      // For each branch, check if it contains our commit
                      // We'll limit this to avoid excessive API calls
                      const branchesToCheck = allBranches.slice(0, 30); // Check up to 30 branches
                      
                      for (const branch of branchesToCheck) {
                        try {
                          const { data: comparison } = await github.rest.repos.compareCommits({
                            owner: process.env.OWNER,
                            repo: submoduleData.repoName || submoduleData.url.split('/').pop().replace('.git', ''),
                            base: sha,
                            head: branch.name
                          });
                          
                          // If the comparison shows our SHA is an ancestor of the branch head
                          if (comparison.status === 'ahead' || comparison.status === 'identical') {
                            normalizedBranches.push(branch.name);
                            core.info(`Found branch ${branch.name} containing SHA ${sha}`);
                            break; // Found one branch, that's enough
                          }
                        } catch (error) {
                          // Skip errors for individual branches
                          continue;
                        }
                      }
                    } catch (error) {
                      core.warning(`Error searching branches for commit ${sha}: ${error.message}`);
                    }
                  }

                  if (normalizedBranches.length === 0) {
                    core.warning(`No branches found for submodule ${submodule} with SHA ${sha} after extensive search`);
                    core.setFailed(`No branches found for submodule ${submodule} with SHA ${sha} after extensive search`);
                    core.setOutput("failMsg", `No branches found for submodule ${submodule} with SHA ${sha} after extensive search.`);
                    return;
                  }
              
                  if (normalizedBranches.length > 1) {
                    core.info(`Submodule ${submodule} with SHA ${sha} is present on multiple branches: ${normalizedBranches.join(', ')}. Selecting best match.`);
                    
                    // Try to find a branch that matches the PR branch name pattern
                    const prBranchName = process.env.PR_BRANCH;
                    
                    // Priority order for branch selection:
                    // 1. Exact match with base PR branch name
                    // 5. First in the list
                    // TODO  - get this back to the original logic of matches base pr branch name, handle multiple rbanches with sha 
                    // if multiple and any non main then STOP - cant pick a branch
                    
                    // Check for exact match with PR branch name
                    const exactMatch = normalizedBranches.find(branch => branch === prBranchName);
                    if (exactMatch) {
                      core.info(`Found exact match with PR branch name: ${exactMatch}`);
                      normalizedBranches = [exactMatch];
                    } else {
                      // Fall back to first branch
                      core.info(`Falling back to first branch: ${normalizedBranches[0]}`);
                      normalizedBranches = [normalizedBranches[0]];
                    }
                  }

                  core.info(`Updating submodule ${submodule}: SHA=${sha}, Branch=${normalizedBranches[0]}`);
                  return {
                    submodule,
                    data: {
                      ...submoduleData,
                      sha,
                      prBranch: normalizedBranches[0]
                    }
                  };
                }
              } catch (error) {
                core.warning(`Error processing submodule ${submodule}: ${error.message}`);
                return null;
              }
            });

            // Wait for all submodule processing to complete
            let results;
            try {
              results = await Promise.allSettled(submodulePromises);
            } catch (error) {
              core.setFailed(`Error executing Promise.allSettled for submodules: ${error.message}`);
              core.setOutput('failMsg', `Error executing Promise.allSettled for submodules: ${error.message}`);
              return;
            } finally {
              // Cleanup operations can be added here if needed
              // For now, we're just ensuring the promise execution is handled properly
            }
            
            // Process results
            for (const result of results) {
              if (result.status === 'fulfilled' && result.value) {
                const { submodule, data } = result.value;
                updatedModules[submodule] = data;
              }
            }

            // Handle any errors
            if (errors.length > 0) {
              const errorMsg = errors.join('\n');
              core.setFailed('The following errors occurred while processing submodules:\n' + errorMsg);
              core.setOutput('failMsg', errorMsg);
              return;
            }

            const updatedGitModulesJSON = JSON.stringify(updatedModules, null, 2);
            core.info("Updated git_modules JSON:");
            core.info(updatedGitModulesJSON);

            core.setOutput('updated_git_modules', updatedGitModulesJSON);

      - name: Detect submod PR numbers and Pre-check all Submodules
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          BASE_BRANCH: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodules = {};
            const prBranchName = process.env.PR_BRANCH;
            const baseBranchName = process.env.BASE_BRANCH;
            
            for (const [name, sub] of Object.entries(submods)) {
              let prBranch = (sub.prBranch || '').replace(/^origin\//, '');
              
              if (prBranch === sub.baseBranch) {
                submodules[name] = {
                  ...sub,
                  pr_number: '0',
                  prLink: null,
                  isBranchExist: true,
                  isPRCreated: false,
                  approvals: null,
                  merged: true,
                  mergeable_state: 'clean',
                  sha: sub.sha,
                };
                continue;
              }
              
              // Start with base submodule info
              submodules[name] = {
                ...sub,
                directory: sub.repoName,
                branchName: prBranchName,
                isBranchExist: true,
                isPRCreated: false,
                merged: false
              };
              
              try {
                // Try to find PR by commit SHA first (most accurate)
                const prsWithCommit = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: process.env.OWNER,
                  repo: sub.repoName,
                  commit_sha: sub.sha
                });

                let relevantPr = prsWithCommit.data.find(pr => pr.base.ref === sub.baseBranch);

                // If no PR found but we know the branch name, check if the SHA is in that branch's history
                if (!relevantPr && prBranch) {
                  // Use the branch-based approach as fallback
                  let branchPrs = await github.rest.pulls.list({
                    owner: process.env.OWNER,
                    repo: sub.repoName,
                    head: `${process.env.OWNER}:${prBranch}`,
                    base: sub.baseBranch,
                    state: 'all',
                    sort: 'updated', 
                    direction: 'desc',
                    per_page: 4,
                  });
                  
                  // For each PR from this branch, check if it contains our SHA
                  for (const pr of branchPrs.data) {
                    const commits = await github.rest.pulls.listCommits({
                      owner: process.env.OWNER,
                      repo: sub.repoName,
                      pull_number: pr.number
                    });
                    
                    if (commits.data.some(commit => commit.sha === sub.sha)) {
                      relevantPr = pr;
                      break;
                    }
                  }
                }

                // If no PR found, keep the default values set earlier
                if (!relevantPr) {
                  return { name, data: baseSubmodule };
                }
                
                let prInfo = relevantPr;
                if (!prInfo.merged && (prInfo.mergeable_state === undefined || prInfo.mergeable_state === 'unknown')) {
                  for (let i = 0; i < 3; i++) {
                    console.log(`Retrying... ${i}`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const retry = await github.rest.pulls.get({
                      owner: process.env.OWNER,
                      repo: sub.repoName,
                      pull_number: prInfo.number
                    });
                    prInfo = retry.data;
                    if (prInfo.merged === true || (prInfo.mergeable_state !== undefined && prInfo.mergeable_state !== 'unknown')) {
                      break;
                    }
                  }
                }
                
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: process.env.OWNER,
                  repo: sub.repoName,
                  pull_number: prInfo.number,
                });
                
                const latestByUser = {};
                for (const review of reviews) {
                  latestByUser[review.user.login] = review.state;
                }
                const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
                const approvalCount = approvedUsers.length;
                const changeRequestCount = Object.values(latestByUser).filter(s => s === 'CHANGES_REQUESTED').length;
                const prState = prInfo.merged_at ? 'merged' : prInfo.state === 'closed' ? 'closed' : 'open';
                
                // Update the submodule with PR information
                submodules[name] = {
                  ...submodules[name],
                  pr_number: prInfo.number,
                  ticketNum: prInfo.number,
                  prLink: prInfo.html_url,
                  isPRCreated: true,
                  approvals: approvalCount,
                  changeRequests: changeRequestCount,
                  prState: prState,
                  merged: prInfo.merged,
                  mergeable_state: prInfo.mergeable_state
                };
              } catch (error) {
                console.log(`Error processing submodule ${name}: ${error.message}`);
              }
            }
            
            // Convert object to array for output
            const submodulesArray = Object.values(submodules);
            const submodulesJson = JSON.stringify(submodulesArray, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesJson);
            core.setOutput('submodules', submodulesJson);
            
            // Filter only unmerged submodules
            const unmerged = submodulesArray.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);
            
            // Check if the number of PRs found matches the number of updated submodules
            const updatedSubmodules = Object.keys(submods).length;
            const foundPRs = submodulesArray.filter(s => s.isPRCreated && s.pr_number && s.pr_number !== '0').length;
            
            core.info(`Updated submodules: ${updatedSubmodules}, Found PRs: ${foundPRs}`);
            
            if (updatedSubmodules > 0 && foundPRs !== updatedSubmodules) {
              const errorMsg = `Mismatch between updated submodules (${updatedSubmodules}) and found PRs (${foundPRs}). Please ensure all submodule changes have corresponding PRs.`;
              core.setFailed(errorMsg);
              core.setOutput('failMsg', errorMsg);
            }

      - name: Add reviewers and assignees to submodule PRs
        id: add-reviewers
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submodules }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const reviewers = JSON.parse(process.env.REVIEWERS);
            const teamReviewers = JSON.parse(process.env.TEAM_REVIEWERS);
            const assignees = JSON.parse(process.env.ASSIGNEES);
            const owner = process.env.OWNER;
            
            core.info(`Adding reviewers ${JSON.stringify(reviewers)} and team reviewers ${JSON.stringify(teamReviewers)} to submodule PRs`);
            core.info(`Adding assignees ${JSON.stringify(assignees)} to submodule PRs`);
            
            // Process each submodule that has an open PR
            for (const submodule of submodules) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.pr_number) {

                try {
                  // Add reviewers if there are any
                  if (reviewers.length > 0 || teamReviewers.length > 0) {
                    await github.rest.pulls.requestReviewers({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      pull_number: submodule.pr_number,
                      reviewers: reviewers,
                      team_reviewers: teamReviewers
                    });
                  }
                  
                  // Add assignees if there are any
                  if (assignees.length > 0) {
                    await github.rest.issues.addAssignees({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.pr_number,
                      assignees: assignees
                    });
                  }
                } catch (error) {
                  core.warning(`Error adding reviewers/assignees to PR #${submodule.pr_number} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }
            
            // Store information about which PRs had reviewers added
            const prsWithReviewersAdded = submodules
              .filter(s => s.isPRCreated && s.prState === 'open' && s.pr_number)
              .map(s => ({ repo: s.repoName, pr: s.pr_number }));
            
            core.setOutput('prs_with_reviewers_added', JSON.stringify(prsWithReviewersAdded));

      - name: Add comment to submodule PRs linking back to base PR
        id: comment-submod-prs
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submodules }}
          BASE_PR_NUMBER: ${{ inputs.pr_number }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const basePrNumber = process.env.BASE_PR_NUMBER;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            
            core.info(`Adding comments to submodule PRs linking back to base PR #${basePrNumber}`);
            
            // Construct the base PR URL
            const basePrUrl = `https://github.com/${owner}/${repo}/pull/${basePrNumber}`;
            
            // Process each submodule that has an open PR
            for (const submodule of submodules) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.pr_number) {
                try {
                  // Check if there's already a comment linking back to the base PR
                  const existingComments = await github.rest.issues.listComments({
                    owner: process.env.OWNER,
                    repo: submodule.repoName,
                    issue_number: submodule.pr_number,
                    per_page: 100
                  });
                  
                  // Look for an existing comment that links back to the base PR
                  const existingComment = existingComments.data.find(comment => 
                    comment.body && 
                    comment.body.includes('This submodule PR is part of a larger change') 
                  );
                  
                  // Add a comment to the submodule PR linking back to the base PR
                  let commentBody = `## üîó This submodule PR is part of a larger change in the parent repository. \n`;
                  commentBody += `Please review the [base PR #${basePrNumber}](${basePrUrl}) for context on how this submodule change fits into the overall update.`;
                  commentBody += `\n_This comment was automatically added by the submodule linking workflow._`;
                  
                  if (existingComment) {
                    // Update the existing comment
                    await github.rest.issues.updateComment({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      comment_id: existingComment.id,
                      body: commentBody
                    });
                    core.info(`Updated existing comment #${existingComment.id} on PR #${submodule.pr_number} in ${submodule.repoName}`);
                  } else {
                    // Create a new comment
                    await github.rest.issues.createComment({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.pr_number,
                      body: commentBody
                    });
                    core.info(`Added new comment to PR #${submodule.pr_number} in ${submodule.repoName} linking back to base PR #${basePrNumber}`);
                  }
                } catch (error) {
                  core.warning(`Error adding/updating comment to PR #${submodule.pr_number} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }

      - name: Update comment with submodule PR links
        id: update-comment
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submodules }}
          PRS_WITH_REVIEWERS: ${{ steps.add-reviewers.outputs.prs_with_reviewers_added }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const prsWithReviewers = JSON.parse(process.env.PRS_WITH_REVIEWERS || '[]');
            
            const { data: comment } = await github.rest.issues.getComment({ owner, repo, comment_id: commentId, });
            
            function getStatusIcon(sub) {
              if (!sub.isBranchExist) return '‚ùå';
              if (!sub.isPRCreated) return 'üîÑ';
              if (sub.approvals !== null && (sub.approvals < parseInt(process.env.MIN_REVIEWERS) || sub.changeRequests > 0)) return '‚è≥';
              if (sub.isPRCreated) return '‚úÖ';
              return '‚ùì';
            }
            
            function getStatusText(sub) {
              if (!sub.isBranchExist) return '**Branch missing**';
              if (!sub.isPRCreated) return '**PR missing**';
              if (sub.approvals !== null) {
                if (sub.approvals < parseInt(process.env.MIN_REVIEWERS)) return '**Pending approval**';
                if (sub.changeRequests > 0) return '**Changes requested**';
                return '**Approved**';
              }
              return '**PR exists**';
            }
            
            let appendMsg = "\n**_(Step 2/2)_** Submodule Analysis:\n\n";
            appendMsg += "| Status | Submodule | Branch | PR | Approvals | State |\n";
            appendMsg += "|--------|-----------|--------|----|-----------|---------| \n";
            
            submodules.forEach(sub => {
              const icon = getStatusIcon(sub);
              const prDisplay = sub.isPRCreated ? `[#${sub.pr_number}](${sub.prLink})` : (sub.pr_number === '0' ? 'default' : 'none');
              const approvalsDisplay = sub.approvals !== null ? `${sub.approvals}` : '-';
              const stateDisplay = sub.merged || sub.prState || '-';
              appendMsg += `| ${icon} | \`${sub.path}\` | \`${sub.prBranch}\` | ${prDisplay} | ${approvalsDisplay} | ${stateDisplay} |\n`;
            });
            
            appendMsg += "\n### üéØ Action Items\n\n";
            const missingBranches = submodules.filter(s => !s.isBranchExist);
            const missingPRs = submodules.filter(s => s.isBranchExist && !s.isPRCreated);
            const pendingApprovals = submodules.filter(s => s.isPRCreated && (s.approvals < parseInt(process.env.MIN_REVIEWERS) || s.changeRequests > 0));
            
            // Check if reviewers were added to any PRs
            const reviewersAdded = prsWithReviewers.length > 0;
            
            if (missingBranches.length > 0) {
              appendMsg += `üåø **Create branches**: ${missingBranches.map(s => '`' + s.directory + '`').join(', ')}\n`;
            }
            if (missingPRs.length > 0) {
              appendMsg += `üîÑ **Create PRs**:\n`;
              for (const sub of missingPRs) {
                // Extract the branch name from the prBranch property if available
                // Otherwise use the PR branch name from the base PR
                const prBranch = sub.prBranch ? sub.prBranch.replace(/^origin\//, '') : `${{ steps.pr.outputs.head_ref}}`;
                const compareUrl = `https://github.com/${owner}/${sub.directory}/compare/${sub.baseBranch}...${prBranch}?expand=1`;
                appendMsg += `- [Create PR for ${sub.directory}](${compareUrl}) (${sub.baseBranch} ‚Üê ${prBranch})\n`;
              }
            }
            if (pendingApprovals.length > 0) {
              appendMsg += `üëÄ **Request reviews**: ${pendingApprovals.map(s => '[' + s.directory + '#' + s.pr_number + '](' + s.prLink + ')').join(', ')}\n`;
            }
            if (reviewersAdded) {
              const reviewersList = JSON.parse(process.env.REVIEWERS || '[]');
              const teamReviewersList = JSON.parse(process.env.TEAM_REVIEWERS || '[]');
              const assigneesList = JSON.parse(process.env.ASSIGNEES || '[]');
              
              let reviewersInfo = '';
              if (reviewersList.length > 0 || teamReviewersList.length > 0) {
                reviewersInfo += `üë• **Reviewers In Sync** `;
              }
              appendMsg += reviewersInfo;
            }
            if (missingBranches.length === 0 && missingPRs.length === 0 && pendingApprovals.length === 0) {
              appendMsg += `‚úÖ All submodules are ready! Type /merge to merge everything.\n`;
            }
            
            appendMsg += "\n Workflow complete ";
            
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({ owner, repo, comment_id: commentId, body: newBody, });

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_DIFF_SUBMODULES: ${{ steps.diff-submodules.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({ owner: process.env.OWNER, repo: process.env.REPO, comment_id: commentId, });
            
            let failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
            
            if ('${{ steps.diff-submodules.conclusion }}' == 'failure'){
              appendMsg = "Submodule diff failed. " + (process.env.FAIL_MSG_DIFF_SUBMODULES || "");
              resolutionSteps = "_Please ensure you have pushed up your branches or ensure that the base sha is pointing to the right place._";
            } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
              appendMsg = "Submodule pre-check failed. " + (process.env.FAIL_MSG_PRE_CHECK_SUBMOD || "");
              if (appendMsg.includes("Mismatch between updated submodules")) {
                resolutionSteps = "_Please ensure all submodule changes have corresponding PRs. Each updated submodule must have exactly one PR._";
              } else {
                resolutionSteps = "_Please ensure all submodule PRs are created and properly linked._";
              }
            } else {
              appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information.";
              resolutionSteps = "_Please try again later._";
            }
            
            const newBody = comment.body + "\n\n" + failureMsg + appendMsg + "\n" + resolutionSteps;
            await github.rest.issues.updateComment({ owner: process.env.OWNER, repo: process.env.REPO, comment_id: commentId, body: newBody, });
