name: Link/Investigate submodules

on:
  workflow_call:
    inputs:
      owner:
        description: 'Organization'
        required: true
        type: string
      repo:
        description: 'Repository'
        required: true
        type: string
      pr_number:
        description: 'PR Number'
        required: true
        type: number
      comment_id:
        description: 'Comment ID'
        required: true
        type: number
    secrets:
      token:
        description: 'Personal Access Token with RW access to repo contents, PRs'
        required: true

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.token }}
  OWNER: ${{ inputs.owner }}
  REPO: ${{ inputs.repo }}
  PR_NUMBER: ${{ inputs.pr_number }}
  COMMENT_ID: ${{ inputs.comment_id }}

jobs:
  link-submods:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - name: Comment start
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            let appendMsg = "\n# üîó Submodule Link Workflow\n";
            appendMsg += `[üñ•Ô∏è View workflow](${runUrl})\n`;
            appendMsg += "**_(Step 1/2)_** Fetching PR details and submodule info...";
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: appendMsg,
            });

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = process.env.PR_NUMBER;
            const pr = await github.rest.pulls.get({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            // Get reviewers for the PR
            const { data: reviewData } = await github.rest.pulls.listRequestedReviewers({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              pull_number: prNumber,
            });
            
            // Get all reviewers (both users and teams)
            const reviewers = reviewData.users ? reviewData.users.map(user => user.login) : [];
            const teamReviewers = reviewData.teams ? reviewData.teams.map(team => team.slug) : [];
            
            // Get assignees
            const assignees = pr.data.assignees ? pr.data.assignees.map(assignee => assignee.login) : [];
            
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("reviewers", JSON.stringify(reviewers));
            core.setOutput("team_reviewers", JSON.stringify(teamReviewers));
            core.setOutput("assignees", JSON.stringify(assignees));
            
            core.info(`Reviewers: ${JSON.stringify(reviewers)}`);
            core.info(`Team Reviewers: ${JSON.stringify(teamReviewers)}`);
            core.info(`Assignees: ${JSON.stringify(assignees)}`);

      - name: Read gitmodules file
        id: read-modules-file
        uses: actions/github-script@v7
        env:
          RW_PAT: ${{ env.RW_PAT }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const owner = process.env.OWNER;
            const baseRef = process.env.BASE_REF;
            
            const gitmodulesContent = fs.readFileSync('.gitmodules', 'utf8');
            const gitmodulesLines = gitmodulesContent.split('\n');
            
            const submodules = {};
            let currentSubmodule = null;
            
            // Process the .gitmodules file line by line to extract all information
            gitmodulesLines.forEach(line => {
              const submoduleMatch = line.match(/\[submodule "(.*)"\]/);
              const pathMatch = line.match(/\s*path = (.*)/);
              const urlMatch = line.match(/\s*url = (.*)/);
              const branchMatch = line.match(/\s*branch = (.*)/);
              
              if (submoduleMatch) {
                currentSubmodule = submoduleMatch[1];
                submodules[currentSubmodule] = {};
              } else if (currentSubmodule && pathMatch) {
                submodules[currentSubmodule].path = pathMatch[1].trim();
              } else if (currentSubmodule && urlMatch) {
                submodules[currentSubmodule].url = urlMatch[1].trim();
              } else if (currentSubmodule && branchMatch) {
                // Store the branch from .gitmodules if it exists
                submodules[currentSubmodule].configuredBranch = branchMatch[1].trim();
                core.info(`Found configured branch in .gitmodules: ${branchMatch[1].trim()} for submodule ${currentSubmodule}`);
              }
            });
            
            // Process each submodule to set up the complete information
            for (const name in submodules) {
              if (!submodules[name].path || !submodules[name].url) {
                core.warning(`Incomplete submodule information for ${name}, skipping`);
                delete submodules[name];
                continue;
              }
              
              const path = submodules[name].path;
              let url = submodules[name].url;
              const configuredBranch = submodules[name].configuredBranch; // This might be undefined
              
              // Extract repo name from URL
              let repoName;

              // Handle different URL formats
              if (url.startsWith('https://github.com/')) {
                // HTTPS URL format: https://github.com/org/repo.git
                const parts = url.replace('https://github.com/', '').replace('.git', '').split('/');
                if (parts.length >= 2) {
                  orgName = parts[0];
                  repoName = parts[1];
                } else {
                  repoName = parts[0];
                }
              } else if (url.startsWith('git@github.com:')) {
                // SSH URL format: git@github.com:org/repo.git
                core.info('ssh');
                const parts = url.replace('git@github.com:', '').replace('.git', '').split('/');
                if (parts.length >= 2) {
                  orgName = parts[0];
                  repoName = parts[1];
                } else {
                  repoName = parts[0];
                }
              } else if (url.startsWith('../')) {
                // Relative URL format: ../repo.git
                repoName = url.replace('../', '').replace('.git', '');
                url = `https://github.com/${owner}/${repoName}.git`;
              } else {
                // Handle any other format
                const parts = url.split(/[\/:]/).filter(Boolean);
                repoName = parts[parts.length - 1].replace('.git', '');
              }

              core.info(`Processing submodule: ${name} with path ${path}, url ${url}, repoName ${repoName}`);
              if (configuredBranch) {
                core.info(`Found configured branch in .gitmodules: ${configuredBranch}`);
              }
              
              // Check if base_ref of base PR is default branch
              let isDefaultBranch = false;
              // Get the default branch for the repository
              const { data: repo } = await github.rest.repos.get({
                owner: process.env.OWNER,
                repo: process.env.REPO
              });
              
              const defaultBranch = repo.default_branch;
              isDefaultBranch = (baseRef === defaultBranch);
              core.info(`Base ref: ${baseRef}, Default branch: ${defaultBranch}, Is default: ${isDefaultBranch}`);
              
              // Get the default branch for the submodule
              const { data: subRepo } = await github.rest.repos.get({
                owner: process.env.OWNER,
                repo: repoName
              });
              
              const subDefaultBranch = subRepo.default_branch;
              
              // Branch selection logic: If PR is base_ref is default branch, use the default branch of the submodule, otherwise use the same branch name as base_ref
              let branch;
              if (isDefaultBranch) {
                branch = subDefaultBranch;
                core.info(`Using default branch '${branch}' for submodule ${name}`);
              } else {
                branch = baseRef;
                core.info(`Using base_ref '${branch}' for submodule ${name}`);
              }
              
              submodules[name] = {
                path,
                url,
                baseBranch: branch,
                configuredBranch,
                subDefaultBranch,
                repoName: repoName,
              };
            }
            
            if (Object.keys(submodules).length === 0) {
              core.info("No submodules found in .gitmodules file.");
            }
            
            const json = JSON.stringify(submodules, null, 2);
            core.info("Submodules JSON:");
            core.info(json);
            core.setOutput('git_modules', json);
      
      - name: Update submodules with SHA and PR branch
        id: diff-submodules
        uses: actions/github-script@v7
        env:
          GIT_MODULES: ${{ steps.read-modules-file.outputs.git_modules }}
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
        with:
          script: |
            const { execSync } = require('child_process');
            const gitModules = JSON.parse(process.env.GIT_MODULES);
            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };
            // get diff of PR branch to filter only changed submodules 
            const diff = run(`git diff origin/${process.env.BASE_REF}...origin/${process.env.PR_BRANCH} `);
            // Parse the diff to find changed submodules and their SHAs
            let changedSubmodules = {};
            let currentFile = null;
            diff.split('\n').forEach(line => {
              const fileMatch = line.match(/^\+\+\+ b\/(.*)$/);
              const subMatch = line.match(/^\+Subproject commit ([0-9a-f]{40})$/);
              
              if (fileMatch) {
                currentFile = fileMatch[1];
              } else if (subMatch && currentFile) {
                changedSubmodules[currentFile] = subMatch[1];
              }
            });
            console.log(`Changed submodules: ${JSON.stringify(changedSubmodules, null, 2)}`);
            
            // Update/ initialize only changed submodules
            for (const path in changedSubmodules) {
              console.log(`Updating submodule at path: ${path}`);
              try {
                run(`git submodule update --init  "${path}"`);
              } catch (error) {
                console.error(`Error updating submodule ${path}: ${error.message}`);
                core.warning(`Failed to update submodule ${path}: ${error.message}`);
              }
            }
            
            const updatedModules = {};
            for (const submodule in gitModules) {
              const path = gitModules[submodule].path;
              const sha = changedSubmodules[path];
              if (!sha) {
                core.info(`Removing submodule ${submodule} (path: ${path}) as it's not in the diff`);
                continue;
              }
              
              console.log(`submodule ${submodule} (path: ${path}) sha: ${sha}`);
              let prBranch = run(`git -C ${path} for-each-ref --format='%(refname:short)' refs/remotes/origin/ --points-at ${sha}`);
              if (prBranch == '')
              {
                //Fall back on just seeing if any branch contains the relevant sha (ex if user pushes a new change to branch in submodule but not update sha in base)
                console.info('Fall back on if any branch contains relevant sha');
                prBranch = run(`git -C ${path} branch -r --contains ${sha}`);
              }

              core.info(`PR branch: *${prBranch}*`);
              if (prBranch == '')
              {
                core.setFailed('Unable to find remote branch containing the SHA');
                core.setOutput("failMsg", `Unable to find remote branch containing the SHA for submodule ${submodule} with sha ${sha}. \nPlease ensure you have pushed up your branch or ensure that the base sha is pointing to the right place.`);
                return;
              }
              
              // Simple approach: clean up the branch data and create a normalized array
              const branchArr = prBranch.trim()
                .replace(/\n/g, ',')
                .split(',')
                .map(b => b.trim())
                .filter(b => b !== '');
              
              // Extract target branches from any "origin/HEAD -> origin/master" format entries
              const normalizedBranches = [];
              branchArr.forEach(branch => {
                // Remove any trailing asterisks and add to array
                branch = branch.replace(/\*$/, '').trim();
                normalizedBranches.push(branch);
                
                // If this is a pointer reference, also add the target
                if (branch.includes(' -> ')) {
                  const target = branch.split(' -> ')[1].trim();
                  normalizedBranches.push(target);
                }
              });
              
              core.info(`Normalized branches: ${normalizedBranches.join(', ')}`)
              // Use the branch determined in the read-modules-file step
              const submoduleBranch = gitModules[submodule].baseBranch;
              const baseBranch = `origin/${submoduleBranch}`;
              console.log(`Submodule branch: ${submoduleBranch}, baseBranch: ${baseBranch}`);
              
              // Check if the base branch exists in our normalized array
              if(normalizedBranches.includes(baseBranch) || normalizedBranches.some(branch => branch.includes(baseBranch)))
              {
                core.info('Prevent failure if the submodule is just pointing to the determined branch.');
                core.info(`Keeping submodule ${submodule}: SHA=${sha}, PR Branch=${prBranch}`);
                updatedModules[submodule] = {
                  ...gitModules[submodule],
                  sha,
                  prBranch: baseBranch,
                };
              } else if(normalizedBranches.length > 1)
              {
                core.setFailed('The submodule sha is present on multiple branches. ');
                core.setOutput("failMsg", `The submodule sha is present on multiple branches for submodule ${submodule} with sha ${sha}. \n Please ensure your base PR branch is pointing to the correct submodule sha. Delete any duplicate branches you do not want merged.`);
                return;
              }
              else 
              {
                core.info(`Keeping submodule ${submodule}: SHA=${sha}, PR Branch=${prBranch}`);
                updatedModules[submodule] = {
                  ...gitModules[submodule],
                  sha,
                  prBranch: normalizedBranches[0],
                };
              }
            }

            const updatedGitModulesJSON = JSON.stringify(updatedModules, null, 2);
            core.info("Updated git_modules JSON:");
            core.info(updatedGitModulesJSON);

            core.setOutput('updated_git_modules', updatedGitModulesJSON);

      - name: Detect submod PR numbers and Pre-check all Submodules
        id: pre-check-submod
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.diff-submodules.outputs.updated_git_modules }}
          PR_BRANCH: ${{ steps.pr.outputs.head_ref }}
          BASE_BRANCH: ${{ steps.pr.outputs.base_ref }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const submodules = {};
            const prBranchName = process.env.PR_BRANCH;
            const baseBranchName = process.env.BASE_BRANCH;
            
            for (const [name, sub] of Object.entries(submods)) {
              let prBranch = (sub.prBranch || '').replace(/^origin\//, '');
              
              if (prBranch === sub.baseBranch) {
                submodules[name] = {
                  ...sub,
                  pr_number: '0',
                  prLink: null,
                  isBranchExist: true,
                  isPRCreated: false,
                  approvals: null,
                  merged: true,
                  mergeable_state: 'clean',
                  sha: sub.sha,
                };
                continue;
              }
              
              // Start with base submodule info
              submodules[name] = {
                ...sub,
                directory: sub.repoName,
                branchName: prBranchName,
                isBranchExist: true,
                isPRCreated: false,
                merged: false
              };
              
              try {
                // Try to find PR by commit SHA first (most accurate)
                const prsWithCommit = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: process.env.OWNER,
                  repo: sub.repoName,
                  commit_sha: sub.sha
                });

                let relevantPr = prsWithCommit.data.find(pr => pr.base.ref === sub.baseBranch);

                // If no PR found but we know the branch name, check if the SHA is in that branch's history
                if (!relevantPr && prBranch) {
                  // Use the branch-based approach as fallback
                  let branchPrs = await github.rest.pulls.list({
                    owner: process.env.OWNER,
                    repo: sub.repoName,
                    head: `${process.env.OWNER}:${prBranch}`,
                    base: sub.baseBranch,
                    state: 'all',
                    sort: 'updated', 
                    direction: 'desc',
                    per_page: 4,
                  });
                  
                  // For each PR from this branch, check if it contains our SHA
                  for (const pr of branchPrs.data) {
                    const commits = await github.rest.pulls.listCommits({
                      owner: process.env.OWNER,
                      repo: sub.repoName,
                      pull_number: pr.number
                    });
                    
                    if (commits.data.some(commit => commit.sha === sub.sha)) {
                      relevantPr = pr;
                      break;
                    }
                  }
                }

                // If no PR found, keep the default values set earlier
                if (!relevantPr) {
                  continue;
                }
                
                let prInfo = relevantPr;
                if (!prInfo.merged && (prInfo.mergeable_state === undefined || prInfo.mergeable_state === 'unknown')) {
                  for (let i = 0; i < 3; i++) {
                    console.log(`Retrying... ${i}`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const retry = await github.rest.pulls.get({
                      owner: process.env.OWNER,
                      repo: sub.repoName,
                      pull_number: prInfo.number
                    });
                    prInfo = retry.data;
                    if (prInfo.merged === true || (prInfo.mergeable_state !== undefined && prInfo.mergeable_state !== 'unknown')) {
                      break;
                    }
                  }
                }
                
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: process.env.OWNER,
                  repo: sub.repoName,
                  pull_number: prInfo.number,
                });
                
                const latestByUser = {};
                for (const review of reviews) {
                  latestByUser[review.user.login] = review.state;
                }
                const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
                const approvalCount = approvedUsers.length;
                const changeRequestCount = Object.values(latestByUser).filter(s => s === 'CHANGES_REQUESTED').length;
                const prState = prInfo.merged_at ? 'merged' : prInfo.state === 'closed' ? 'closed' : 'open';
                
                // Update the submodule with PR information
                submodules[name] = {
                  ...submodules[name],
                  pr_number: prInfo.number,
                  ticketNum: prInfo.number,
                  prLink: prInfo.html_url,
                  isPRCreated: true,
                  approvals: approvalCount,
                  changeRequests: changeRequestCount,
                  prState: prState,
                  merged: prInfo.merged,
                  mergeable_state: prInfo.mergeable_state
                };
              } catch (error) {
                console.log(`Error processing submodule ${name}: ${error.message}`);
              }
            }
            
            // Convert object to array for output
            const submodulesArray = Object.values(submodules);
            const submodulesJson = JSON.stringify(submodulesArray, null, 2);
            core.info("Submodule JSON:");
            core.info(submodulesJson);
            core.setOutput('submodules', submodulesJson);
            
            // Filter only unmerged submodules
            const unmerged = submodulesArray.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);

      - name: Add reviewers and assignees to submodule PRs
        id: add-reviewers
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submodules }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const reviewers = JSON.parse(process.env.REVIEWERS);
            const teamReviewers = JSON.parse(process.env.TEAM_REVIEWERS);
            const assignees = JSON.parse(process.env.ASSIGNEES);
            const owner = process.env.OWNER;
            
            core.info(`Adding reviewers ${JSON.stringify(reviewers)} and team reviewers ${JSON.stringify(teamReviewers)} to submodule PRs`);
            core.info(`Adding assignees ${JSON.stringify(assignees)} to submodule PRs`);
            
            // Process each submodule that has an open PR
            for (const submodule of submodules) {
              if (submodule.isPRCreated && submodule.prState === 'open' && submodule.pr_number) {
                core.info(`Processing PR #${submodule.pr_number} for ${submodule.repoName}`);
                
                try {
                  // Add reviewers if there are any
                  if (reviewers.length > 0 || teamReviewers.length > 0) {
                    await github.rest.pulls.requestReviewers({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      pull_number: submodule.pr_number,
                      reviewers: reviewers,
                      team_reviewers: teamReviewers
                    });
                    core.info(`Added reviewers to PR #${submodule.pr_number} for ${submodule.repoName}`);
                  }
                  
                  // Add assignees if there are any
                  if (assignees.length > 0) {
                    await github.rest.issues.addAssignees({
                      owner: process.env.OWNER,
                      repo: submodule.repoName,
                      issue_number: submodule.pr_number,
                      assignees: assignees
                    });
                    core.info(`Added assignees to PR #${submodule.pr_number} for ${submodule.repoName}`);
                  }
                } catch (error) {
                  core.warning(`Error adding reviewers/assignees to PR #${submodule.pr_number} for ${submodule.repoName}: ${error.message}`);
                }
              }
            }
            
            // Store information about which PRs had reviewers added
            const prsWithReviewersAdded = submodules
              .filter(s => s.isPRCreated && s.prState === 'open' && s.pr_number)
              .map(s => ({ repo: s.repoName, pr: s.pr_number }));
            
            core.setOutput('prs_with_reviewers_added', JSON.stringify(prsWithReviewersAdded));

      - name: Update comment with submodule PR links
        id: update-comment
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.pre-check-submod.outputs.submodules }}
          PRS_WITH_REVIEWERS: ${{ steps.add-reviewers.outputs.prs_with_reviewers_added }}
          REVIEWERS: ${{ steps.pr.outputs.reviewers }}
          TEAM_REVIEWERS: ${{ steps.pr.outputs.team_reviewers }}
          ASSIGNEES: ${{ steps.pr.outputs.assignees }}
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const submodules = JSON.parse(process.env.SUBMODULES_JSON);
            const prsWithReviewers = JSON.parse(process.env.PRS_WITH_REVIEWERS || '[]');
            
            const { data: comment } = await github.rest.issues.getComment({
              owner,
              repo,
              comment_id: commentId,
            });
            
            function getStatusIcon(sub) {
              if (!sub.isBranchExist) return '‚ùå';
              if (!sub.isPRCreated) return 'üîÑ';
              if (sub.approvals !== null && (sub.approvals === 0 || sub.changeRequests > 0)) return '‚è≥';
              if (sub.isPRCreated) return '‚úÖ';
              return '‚ùì';
            }
            
            function getStatusText(sub) {
              if (!sub.isBranchExist) return '**Branch missing**';
              if (!sub.isPRCreated) return '**PR missing**';
              if (sub.approvals !== null) {
                if (sub.approvals === 0) return '**Pending approval**';
                if (sub.changeRequests > 0) return '**Changes requested**';
                return '**Approved**';
              }
              return '**PR exists**';
            }
            
            let appendMsg = "\n**_(Step 2/2)_** Submodule Analysis:\n\n";
            appendMsg += "| Status | Submodule | Branch | PR | Approvals | State |\n";
            appendMsg += "|--------|-----------|--------|----|-----------|---------| \n";
            
            submodules.forEach(sub => {
              const icon = getStatusIcon(sub);
              const prDisplay = sub.isPRCreated ? `[#${sub.pr_number}](${sub.prLink})` : (sub.pr_number === '0' ? 'default' : 'none');
              const approvalsDisplay = sub.approvals !== null ? `${sub.approvals}` : '-';
              const stateDisplay = sub.merged || sub.prState || '-';
              appendMsg += `| ${icon} | \`${sub.path}\` | \`${sub.prBranch}\` | ${prDisplay} | ${approvalsDisplay} | ${stateDisplay} |\n`;
            });
            
            appendMsg += "\n### üéØ Action Items\n\n";
            const missingBranches = submodules.filter(s => !s.isBranchExist);
            const missingPRs = submodules.filter(s => s.isBranchExist && !s.isPRCreated);
            const pendingApprovals = submodules.filter(s => s.isPRCreated && (s.approvals === 0 || s.changeRequests > 0));
            
            // Check if reviewers were added to any PRs
            const reviewersAdded = prsWithReviewers.length > 0;
            
            if (missingBranches.length > 0) {
              appendMsg += `üåø **Create branches**: ${missingBranches.map(s => '`' + s.directory + '`').join(', ')}\n`;
            }
            if (missingPRs.length > 0) {
              appendMsg += `üîÑ **Create PRs**:\n`;
              for (const sub of missingPRs) {
                // Extract the branch name from the prBranch property if available
                // Otherwise use the PR branch name from the base PR
                const prBranch = sub.prBranch ? sub.prBranch.replace(/^origin\//, '') : `${{ steps.pr.outputs.head_ref}}`;
                const compareUrl = `https://github.com/${owner}/${sub.directory}/compare/${sub.baseBranch}...${prBranch}?expand=1`;
                appendMsg += `- [Create PR for ${sub.directory}](${compareUrl}) (${sub.baseBranch} ‚Üê ${prBranch})\n`;
              }
            }
            if (pendingApprovals.length > 0) {
              appendMsg += `üëÄ **Request reviews**: ${pendingApprovals.map(s => '[' + s.directory + '#' + s.pr_number + '](' + s.prLink + ')').join(', ')}\n`;
            }
            if (reviewersAdded) {
              const reviewersList = JSON.parse(process.env.REVIEWERS || '[]');
              const teamReviewersList = JSON.parse(process.env.TEAM_REVIEWERS || '[]');
              const assigneesList = JSON.parse(process.env.ASSIGNEES || '[]');
              
              let reviewersInfo = '';
              if (reviewersList.length > 0 || teamReviewersList.length > 0) {
                reviewersInfo += `üë• **Reviewers added**: `;
                if (reviewersList.length > 0) reviewersInfo += `Users: ${reviewersList.join(', ')} `;
                if (teamReviewersList.length > 0) reviewersInfo += `Teams: ${teamReviewersList.join(', ')}`;
                reviewersInfo += '\n';
              }
              if (assigneesList.length > 0) {
                reviewersInfo += `üë§ **Assignees added**: ${assigneesList.join(', ')}\n`;
              }
              
              appendMsg += reviewersInfo;
              appendMsg += `‚úÖ **Reviewers/assignees added to**: ${prsWithReviewers.map(pr => '[' + pr.repo + '#' + pr.pr + '](' + `https://github.com/${owner}/${pr.repo}/pull/${pr.pr}` + ')').join(', ')}\n`;
            }
            if (missingBranches.length === 0 && missingPRs.length === 0 && pendingApprovals.length === 0) {
              appendMsg += `‚úÖ All submodules are ready! Type /merge to merge everything.\n`;
            }
            
            appendMsg += "\n Workflow complete ";
            
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          JOB_NAME: ${{ github.job }}
          FAIL_MSG_DIFF_SUBMODULES: ${{ steps.diff-submodules.outputs.failMsg }}
          FAIL_MSG_PRE_CHECK_SUBMOD: ${{ steps.pre-check-submod.outputs.failMsg }}
        with:
          script: |
            const commentId = process.env.COMMENT_ID;
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
            });
            
            let failureMsg = "‚ùå **Job failed:** ";
            let appendMsg = "";
            let resolutionSteps = "";
            
            if ('${{ steps.diff-submodules.conclusion }}' == 'failure'){
              appendMsg = "Submodule diff failed. " + (process.env.FAIL_MSG_DIFF_SUBMODULES || "");
              resolutionSteps = "_Please ensure you have pushed up your branches or ensure that the base sha is pointing to the right place._";
            } else if ('${{ steps.pre-check-submod.conclusion }}' == 'failure'){
              appendMsg = "Submodule pre-check failed. " + (process.env.FAIL_MSG_PRE_CHECK_SUBMOD || "");
              resolutionSteps = "_Please ensure all submodule PRs are created and properly linked._";
            } else {
              appendMsg = "Unknown error. Please check the job logs on **Actions** tab for more information.";
              resolutionSteps = "_Please try again later._";
            }
            
            const newBody = comment.body + "\n\n" + failureMsg + appendMsg + "\n" + resolutionSteps;
            await github.rest.issues.updateComment({
              owner: process.env.OWNER,
              repo: process.env.REPO,
              comment_id: commentId,
              body: newBody,
            });