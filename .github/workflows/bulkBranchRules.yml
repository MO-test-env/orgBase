name: Bulk Branch Rule Management (GitHub REST)

on:
  workflow_dispatch:
    inputs:
      org:
        description: 'Organization name'
        required: true
        default: 'MO-test-env'
      repo_filter:
        description: 'Optional: comma-separated repos to include (empty = all repos)'
        required: false
        default: ''
      branch:
        description: 'Branch to inspect or protect (use "default" to use each repo default branch)'
        required: true
        default: 'default'
      mode:
        description: 'Mode: "read" to list protections, "apply" to enforce protections'
        required: true
        default: 'read'
      dry_run:
        description: 'If "true", show what would be done without making requests'
        required: false
        default: 'false'

permissions:
  contents: read

env:
  RW_PAT: ${{ secrets.WORKFLOWS }}

jobs:
  list-repos:
    runs-on: ubuntu-latest
    outputs:
      repos_json: ${{ steps.get_repos.outputs.repos_json }}
    steps:
      - name: Get repositories in org (REST API)
        id: get_repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const org = `${{ github.event.inputs.org }}`;
            const repoFilter = `${{ github.event.inputs.repo_filter }}`;
            const repos = [];
            let page = 1;
            const per_page = 100;

            while (true) {
              const { data } = await github.rest.repos.listForOrg({
                org,
                per_page,
                page,
                type: 'all'
              });
              if (data.length === 0) break;
              repos.push(...data.map(r => r.name));
              if (data.length < per_page) break;
              page++;
            }

            let filtered = repos;
            if (repoFilter) {
              const wanted = repoFilter.split(',').map(r => r.trim());
              filtered = repos.filter(r => wanted.includes(r));
            }

            core.info(`Repos found: ${filtered.length}`);
            core.setOutput('repos_json', JSON.stringify(filtered));

  manage-protection:
    needs: list-repos
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo: ${{ fromJson(needs.list-repos.outputs.repos_json) }}
      max-parallel: 4

    steps:
      - name: Read or Apply Branch Protection 
        id: manage
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const fs = require('fs');
            const org = `${{ github.event.inputs.org }}`;
            const mode = `${{ github.event.inputs.mode }}`;
            const dryRun = `${{ github.event.inputs.dry_run }}` === 'true';
            const branchInput = `${{ github.event.inputs.branch }}`;
            const repo = '${{ matrix.repo }}';
            const outputFile = './branch_protections.json';

            core.info(`Processing repository: ${org}/${repo} [mode=${mode}]`);

            // Get repo metadata
            const { data: repoInfo } = await github.rest.repos.get({
              owner: org,
              repo,
            });
            const defaultBranch = repoInfo.default_branch;
            const branch = branchInput === 'default' ? defaultBranch : branchInput;
            core.info(`Target branch: ${branch}`);

            // READ MODE ‚Äî list existing protection
            if (mode === 'read') {
              try {
                const { data: protection } = await github.rest.repos.getBranchProtection({
                  owner: org,
                  repo,
                  branch,
                });
                core.startGroup(`üîí Existing protection for ${org}/${repo}@${branch}`);
                core.info(JSON.stringify(protection, null, 2));
                core.endGroup();

                // Save protection data to local file
                let existing = [];
                if (fs.existsSync(outputFile)) {
                  existing = JSON.parse(fs.readFileSync(outputFile, 'utf8'));
                }
                existing.push({ repo, branch, protection });
                fs.writeFileSync(outputFile, JSON.stringify(existing, null, 2));
              } catch (error) {
                if (error.status === 404) {
                  core.warning(`‚ö†Ô∏è No branch protection for ${org}/${repo}@${branch}`);
                } else {
                  core.error(`Error reading protection for ${org}/${repo}@${branch}`);
                  core.error(error);
                }
              }
              return; // Skip apply mode
            }

            // APPLY MODE ‚Äî create or update protection
            const protection = {
              required_status_checks: {
                strict: true,
                contexts: []
              },
              enforce_admins: true,
              required_pull_request_reviews: {
                dismiss_stale_reviews: true,
                require_code_owner_reviews: true,
                required_approving_review_count: 1
              },
              restrictions: null
            };

            core.info('Branch protection configuration:');
            core.info(JSON.stringify(protection, null, 2));

            if (dryRun) {
              core.info('üü° DRY RUN: No changes applied.');
              return;
            }

            try {
              await github.rest.repos.updateBranchProtection({
                owner: org,
                repo,
                branch,
                ...protection
              });
              core.info(`‚úÖ Branch protection applied to ${org}/${repo}@${branch}`);
            } catch (error) {
              core.error(`‚ùå Failed to apply branch protection for ${repo}@${branch}`);
              core.error(error);
              throw error;
            }

      - name: Upload protection data (only in read mode)
        if: ${{ github.event.inputs.mode == 'read' }}
        uses: actions/upload-artifact@v4
        with:
          name: branch-protection-data
          path: ./branch_protections.json

      - name: Done (log)
        if: always()
        run: echo "Finished processing ${{ matrix.repo }}"
