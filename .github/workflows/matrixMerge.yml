name: Merge (on /merge comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.WORKFLOWS }} # Personal Access Token with RW access to repo contents, PRs
  MIN_REVIEWERS: 0

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  init:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      head_ref: ${{ steps.pr.outputs.head_ref }}
      base_ref: ${{ steps.pr.outputs.base_ref }}
      pr_number: ${{ steps.pr.outputs.pr_number }}
      pr_title: ${{ steps.pr.outputs.title }}
      mergeable: ${{ steps.pr.outputs.mergeable }}
      merged: ${{ steps.pr.outputs.merged }}
      mergeable_state: ${{ steps.pr.outputs.mergeable_state }}
      state: ${{ steps.pr.outputs.state }}
    steps:
      - name: Comment start
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n" + "# üîß **Merge workflow started** # \n _This may take a few minutes_\n\n (Step 1/6) Initializing submodule information. ";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("title", pr.data.title);
            core.setOutput("body", pr.data.body);
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("merged", pr.data.merged);
            core.setOutput("mergeable_state", pr.data.mergeable_state);
            core.setOutput("state", pr.data.state);

      - name: Comment after init on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n" + "‚ùå FAILED to get submodule information from base pr comment";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });
  
  create-submodule-json:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      submodules: ${{ steps.add-merged-flag.outputs.submodules }}
      unmerged_submodules: ${{ steps.filter-unmerged.outputs.unmerged }}
    steps:
      ## TODO: Fix this to populate pr numbers (possibly also path, name, and url tbd) from comment or job check
      ## then add merged, mergeable, and reviews when i combine the next step
      - name: Detect submodules from comment and populate Json
        id: submod
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            // Find the most recent "üîç Submodule Analysis Results" comment
            const analysis = comments
              .filter(c => c.body.includes('üîç Submodule Analysis Results'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

            if (!analysis) {
              core.warning("No submodule analysis comment found.");
              core.setOutput('submodules', '[]');
              return;
            }

            const text = analysis.body;

            // Split by each section starting with "#### ‚è≥"
            const blocks = text.split(/(?=####\s*‚è≥)/g).filter(b => b.includes('PR:'));

            const submodules = [];

            for (const block of blocks) {
              const nameMatch = block.match(/####\s*‚è≥\s*`([^`]+)`/);
              const branchMatch = block.match(/\*\*Branch:\*\*\s*`([^`]+)`/);
              const statusMatch = block.match(/\*\*Status:\*\*\s*\*\*([^*]+)\*\*/);
              const prMatch = block.match(/\[?#(\d+)\]\((https:\/\/github\.com\/[^)]+)\)/);
              const approvalsMatch = block.match(/\*\*Approvals:\*\*\s*([\d/]+)/);
              const changeRequestsMatch = block.match(/\*\*Change Requests:\*\*\s*(\d+)/);

              if (!nameMatch || !prMatch) {
                core.warning(`‚ö†Ô∏è Skipping malformed submodule block:\n${block}`);
                continue;
              }

              const name = nameMatch[1];
              const branch = branchMatch ? branchMatch[1] : null;
              const status = statusMatch ? statusMatch[1].trim() : null;
              const pr_number = parseInt(prMatch[1], 10);
              const pr_url = prMatch[2];
              const approvals = approvalsMatch ? approvalsMatch[1] : null;
              const change_requests = changeRequestsMatch ? changeRequestsMatch[1] : null;

              // Extract org/repo from PR URL
              const [, org, repo] = pr_url.match(/github\.com\/([^/]+)\/([^/]+)\//) || [];

              submodules.push({
                name,
                branch,
                status,
                pr_number,
                approvals,
                change_requests,
                merged: false,
                repo: repo || name,
                org: org || context.repo.owner,
                url: pr_url,
              });
            }

            const json = JSON.stringify(submodules, null, 2);
            core.info("üì¶ Extracted submodule JSON:");
            core.info(json);
            core.setOutput('submodules', json);


      - name: Add merged flag to each submodule entry
        id: add-merged-flag
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.submod.outputs.submodules }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const enriched = [];

            for (const sub of submods) {
              // If the entry has no PR number we treat it as ‚Äúalready merged‚Äù
              if (!sub.pr_number) {
                enriched.push({ ...sub, merged: true });
                continue;
              }

              const url = new URL(sub.url);
              const [owner, repo] = url.pathname.replace(/^\/|\.git$/g, '').split('/');

              try {
                const { data: prInfo } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: sub.pr_number,
                });

                const isMerged = prInfo.state === 'closed' && prInfo.merged === true;
                enriched.push({ ...sub, merged: isMerged });
                core.info(`üîé Submodule ${sub.name} PR #${sub.pr_number} merged=${isMerged}`);
              } catch (err) {
                // If the API call fails we assume it still needs work ‚Äì do not abort the whole workflow
                core.warning(`‚ùóÔ∏è Could not fetch PR #${sub.pr_number} for ${owner}/${repo}: ${err.message}`);
                enriched.push({ ...sub, merged: false });
              }
            }

            const newJson = JSON.stringify(enriched);
            core.setOutput('submodules', newJson);
            core.info(`üóÇÔ∏è Updated submodule list (with merged flag): ${newJson}`);
      
      - name: Filter out merged submodules
        id: filter-unmerged
        run: |
          echo "unmerged=$(echo '${{ steps.add-merged-flag.outputs.submodules }}' \
                | jq -c '[.[] | select(.merged == false)]')" >> $GITHUB_OUTPUT
      - name: Comment after init
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n" + " ‚úÖ Submodule information found in comment\n\n(Step 2/6) Beginning to check for submodule conflicts";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });


  ## check base conflicts 
  check-base-conflicts:
    needs: [init]
    if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      conflicts: ${{ steps.detect-conflicts.outputs.conflicts }}
    steps:
      - name: Checkout PR branch
        if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
        uses: actions/checkout@v4
        with:
          token:       ${{ env.RW_PAT }}
          ref:         ${{ needs.init.outputs.base_ref }}
          fetch-depth: 0
          submodules:  false
      - name: Detect conflicts (dry‚Äërun merge)
        if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
        id: detect-conflicts
        uses: actions/github-script@v7
        env:
          BASE: ${{ needs.init.outputs.base_ref }}  
          PR_BRANCH: ${{ needs.init.outputs.head_ref }}
          TOKEN: ${{ env.RW_PAT }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');

            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };

            run('git config --global user.name "github-actions[bot]"');
            run('git config --global user.email "github-actions[bot]@users.noreply.github.com"');

            try {
              run(`git fetch origin "${process.env.PR_BRANCH}"`);
            } catch (e) {
              core.setFailed(`‚ùå Failed to fetch base branch ${process.env.PR_BRANCH}: ${e.message}`);
              process.exit(1);
            }

            // Parse submodule paths from .gitmodules 
            let submodulePaths = [];
            if (fs.existsSync('.gitmodules')) {
              const gm = fs.readFileSync('.gitmodules', 'utf8');
              const matches = [...gm.matchAll(/path\s*=\s*(.+)/g)];
              submodulePaths = matches.map(m => m[1].trim());
              console.log(`üì¶ Found submodules: ${submodulePaths.join(', ')}`);
            } else {
              core.setFailed('‚ö†Ô∏è No .gitmodules file found');
              process.exit(1);
            }

            try {
              run(`git merge --no-commit --no-ff "origin/${process.env.PR_BRANCH}"`, { stdio: 'inherit' });
            } catch (_) {
              // merge returned non‚Äëzero ‚Üí likely conflicts - allow it to fall through
            }

            let conflictList = '';
            try {
              conflictList = run('git diff --name-only --diff-filter=U');
            } catch (_) {
              // No conflicted files ‚Üí git diff returns nothing, keep empty string
            }

            if (!conflictList) {
              console.log('!! No conflicted files ‚Äì this is unexpected when mergeable_state was ‚Äúdirty‚Äù.');
              core.setOutput('conflict_files', '[]');  
            } else {
              console.log('‚ö°Ô∏è Conflicted files (plain‚Äëtext):');
              console.log(conflictList);

              const conflicts = conflictList
                .split('\n')
                .filter(Boolean)
                .map(f => f.trim());

              console.log('‚ö°Ô∏è Conflicted files:', conflicts);

              // Determine if any conflict is *not* inside a submodule path
              const nonSubmoduleConflicts = conflicts.filter(f => {
                return !submodulePaths.some(sub => f === sub || f.startsWith(`${sub}/`));
              });

              const json = JSON.stringify(conflicts);
              core.setOutput('conflict_files', json);
              
              run('git merge --abort || true');

              if (nonSubmoduleConflicts.length > 0) {
                console.log('‚ùå Non-submodule conflicts detected:');
                console.log(nonSubmoduleConflicts.join('\n'));
                core.setFailed('Conflicts found in non-submodule paths.');
              } else {
                console.log('‚úÖ Only submodule conflicts detected ‚Äî not failing.');
              }
            }

      - name: Report job failure to PR comment
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
          CONFLICT_FILES: ${{ steps.detect-conflicts.outputs.conflict_files }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = Number(process.env.COMMENT_ID);
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId
            });

            const conflicts = process.env.CONFLICT_FILES || '[]';
            const parsed = JSON.parse(conflicts);

            const conflictSummary =
              parsed.length > 0
                ? parsed.map(f => `‚Ä¢ \`${f}\``).join('\n')
                : '_No conflicted files listed._';
            const failureMsg = [
              `‚ùå **Job \`${job}\` failed**`,
              'This base PR has conflicts in **non-submodule paths**.',
              'Please manually fix them and push this branch again.',
              '',
              '**Conflicted files:**',
              conflictSummary
            ].join('\n');

            const newBody = comment.body + "\n" + failureMsg;

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody
            });
  

  check-submodule-conflicts:
    needs: [create-submodule-json]  
    if: ${{ needs.create-submodule-json.outputs.unmerged_submodules != '[]' }}
    runs-on: ubuntu-latest
    timeout-minutes: 2
    strategy:
      matrix:
        submod: ${{ fromJson(needs.create-submodule-json.outputs.unmerged_submodules) }}
      max-parallel: 8
      fail-fast: true
    env:
      GITHUB_API_URL: https://github.com/api/v3
    steps:
      - name: Verify submodule PR state
        id: api-check
        uses: actions/github-script@v7
        env:
          SUBMODULE: ${{ toJson(matrix.submod) }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const sub = JSON.parse(process.env.SUBMODULE);

            if (!sub.pr_number) {
              core.info(`‚öôÔ∏è Submodule "${sub.name}" has no associated PR ‚Äì skipping check.`);
              core.setOutput('result',
                JSON.stringify({ path: sub.path, repo: sub.url, result: "no_pr" }));
              return;
            }

            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\/|\.git$/g, '').split('/');

            core.info(`üîé Checking submodule PR #${sub.pr_number} in ${owner}/${repo}`);

            let prInfo;
            try {
              const { data } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: sub.pr_number,
              });
              prInfo = data;
            } catch (err) {
              core.setFailed(`‚ùå Could not fetch PR #${sub.pr_number} for ${owner}/${repo}: ${err.message}`);
              return;
            }

            if (prInfo.state === 'closed' && prInfo.merged) {
              core.info(`‚úÖ Submodule PR #${sub.pr_number} is already merged.`);
              core.setOutput('result',
                JSON.stringify({ path: sub.path, repo: `${owner}/${repo}`, result: "merged" }));
              return;
            }

            let reviews = [];
            try {
              const { data } = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: sub.pr_number,
              });
              reviews = data;
            } catch (err) {
              core.warning(`‚ö†Ô∏è Could not list reviews for ${owner}/${repo}#${sub.pr_number}: ${err.message}`);
              // Continue ‚Äì we will treat it as ‚Äúno approvals yet‚Äù.
            }

            const approvedSet = new Set();
            for (const r of reviews) {
              if (r.state === 'APPROVED') {
                approvedSet.add(r.user.login);
              }
            }
            const approvedCount = approvedSet.size;

            const min = parseInt(process.env.MIN_REVIEWERS, 10) || 0; // fallback to 0
            core.info(`üëÄ Found ${approvedCount} distinct APPROVED review(s) (need ‚â• ${min}).`);

            if (prInfo.state !== 'open') {
              core.setFailed(`‚ùå Submodule PR #${sub.pr_number} is ${prInfo.state} (expected open).`);
              return;
            }
            if (!prInfo.mergeable) {
              core.setFailed(`‚ùå Submodule PR #${sub.pr_number} is not mergeable (likely has conflicts).`);
              return;
            }
            if (approvedCount < min) {
              core.setFailed(
                `‚ùå Submodule PR #${sub.pr_number} does not meet the minimum reviewer requirement (${approvedCount}/${min} approved).`
              );
              return;
            }-
            core.info(`‚úÖ Submodule PR #${sub.pr_number} is ready to be merged.`);
            core.setOutput('result',
              JSON.stringify({ path: sub.path, repo: `${owner}/${repo}`, result: "ready" }));

      - name: Report job failure to PR comment
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME:   ${{ github.job }}
          SUBMODULE: ${{ toJson(matrix.submod) }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = Number(process.env.COMMENT_ID);
            const job       = process.env.JOB_NAME;

            // Parse the submodule that was being processed when the job failed
            let subInfo = {};
            try {
              subInfo = JSON.parse(process.env.SUBMODULE);
            } catch (_) {}

            const subDesc = subInfo.name
              ? `**${subInfo.name}** (repo: ${subInfo.url || 'unknown'})`
              : "`unknown submodule`";

            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              comment_id: commentId
            });

            const failureMsg = `‚ùå **Job \`${job}\` failed while checking submodule ${subDesc}**\n\nThe PR is either not not open, not approved, or has merge conflicts. Please go check ALL submodules and fix the isue.`;
            const newBody = comment.body + "\n" + failureMsg;

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              comment_id: commentId,
              body: newBody
            });

  aggregate-precheck:
    needs: [check-submodule-conflicts, check-base-conflicts, merge-base-no-submodules]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      (needs.check-submodule-conflicts.result == 'success' ||
      needs.check-submodule-conflicts.result == 'skipped') &&
      (needs.check-base-conflicts.result == 'success' ||
      needs.check-base-conflicts.result == 'skipped') && 
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' && 
      needs.merge-base-no-submodules.result == 'skipped'
    steps:
      - name: Comment after Aggregate submod precheck
        uses: actions/github-script@v7
        env:
          SUBMODULE_RESULT: ${{ needs.check-submodule-conflicts.result }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            let newBody = comment.body + "\n";
            const result = process.env.SUBMODULE_RESULT;
            if( result == "skipped")
            {
              newBody = newBody + " ‚úÖ **Submodule precheck skipped.** All submodules already merged. \n\n(Step 3/6) Skipping merge submodules";
            }
            else
            {
              newBody = newBody + " ‚úÖ No merge conflicts were found in submodule prs. \n\n(Step 3/6) Beginning to merge submodules";
            }
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  merge-submodules:
    needs: [aggregate-precheck, create-submodule-json, merge-base-no-submodules]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      needs.create-submodule-json.result == 'success' &&
      needs.aggregate-precheck.result == 'success' &&
      needs.create-submodule-json.outputs.unmerged_submodules != '[]' && 
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      needs.merge-base-no-submodules.result == 'skipped'
    env:
      GITHUB_API_URL: https://github.com/api/v3
    strategy:
      matrix:
        submod: ${{ fromJson(needs.create-submodule-json.outputs.unmerged_submodules) }}
      max-parallel: 4
      fail-fast: true
    steps:
      - name: Merge submodule PR
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            console.info(`üîé Processing submodule: ${JSON.stringify(sub)}`);

            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\//,'').replace(/\.git$/,'').split('/');
            const pr = sub.pr_number;
            const { data: prInfo } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
            const res = await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: pr,
              merge_method: "squash",
            });
      - name: Report job failure to PR comment
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = Number(process.env.COMMENT_ID);
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              comment_id: commentId
            });

            const failureMsg = `‚ùå **Job \`${job}\` failed**`;
            const newBody = comment.body + "\n" + failureMsg;

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody
            });

  aggregate:
    needs: [merge-submodules, merge-base-no-submodules, check-base-conflicts]
    runs-on: ubuntu-latest
    timeout-minutes: 1
    if: >-
      always() &&
      (needs.merge-submodules.result == 'success' ||
      needs.merge-submodules.result == 'skipped') && 
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      needs.merge-base-no-submodules.result == 'skipped' &&
      needs.check-base-conflicts.result == 'success'
    steps:
      - name: Comment after Aggregate 
        uses: actions/github-script@v7
        env:
          SUBMODULE_RESULT: ${{ needs.merge-submodules.result }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            let newBody = comment.body + "\n";
            const result = process.env.SUBMODULE_RESULT;
            if( result == "skipped")
            {
              newBody = newBody + " ‚úÖ **Submodule merge skipped.** All submodules already merged. \n\n(Step 4/6) Beginning to bump submodules for base PR branch.";
            }
            else
            {
              newBody = newBody + " ‚úÖ All submodules merged.\n\n(Step 4/6) Beginning to bump submodules for base PR branch.";
            }
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  bump-rebase-submodules:
    needs: [aggregate, check-base-conflicts, init, create-submodule-json]
    if: >-
      always() &&
      needs.aggregate.result == 'success' &&
      ( needs.check-base-conflicts.result == 'success' || needs.check-base-conflicts.result == 'skipped') &&
      needs.init.result == 'success' &&
      needs.create-submodule-json.result == 'success' &&
      needs.create-submodule-json.outputs.submodules != '[]'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0
          ref: ${{ needs.init.outputs.head_ref }}
          submodules: false

      - name: Authenticate submodules
        run: |
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ needs.create-submodule-json.outputs.submodules }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{ needs.init.outputs.head_ref }}
        with:
          script: |
            const { execSync } = require('child_process');
            const submoduleJson = JSON.parse(process.env.SUBMODULES);
            let changed = false;

            for (const sub of submoduleJson) {
              console.log(`üîß Updating submodule ${sub.repo} at ${sub.path}`);
              let urlWithToken = sub.url.startsWith('https://')
                ? sub.url.replace('https://', `https://${process.env.TOKEN}@`)
                : sub.url;

              // Get default branch of submodule from .gitmodules
              const defaultBranch = execSync(
                `git config --file .gitmodules --get submodule.${sub.name}.branch`,
                { encoding: 'utf8' }
              ).trim();

              execSync(`git -C ${sub.path} fetch origin ${defaultBranch}:${defaultBranch}`, { stdio: 'inherit' });
              const latestCommit = execSync(
                `git ls-remote ${urlWithToken} refs/heads/${defaultBranch} | awk '{print $1}'`,
                { encoding: 'utf8' }
              ).trim();
              const currentCommit = execSync(`git -C ${sub.path} rev-parse HEAD`, { encoding: 'utf8' }).trim();

              if (currentCommit !== latestCommit) {
                console.log(`‚ö†Ô∏è  ${sub.repo} is outdated. Resetting to ${latestCommit}`);
                execSync(`git -C ${sub.path} reset --hard ${latestCommit}`, { stdio: 'inherit' });
                execSync(`git add ${sub.path}`);
                changed = true;
              } else {
                console.log(`‚úÖ ${sub.repo} is already up-to-date`);
              }
            }
            if (changed) {
              execSync(`git commit -m "Bump submodules to latest default branch"`);
              execSync(`git push origin ${process.env.BRANCH}`);
            } else {
              console.log('‚úÖ All submodules already up-to-date.');
            }

      - name: Comment after Bump
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n" + " ‚úÖ Submodules bumped \n\n(Step 5/6) Beginning to rebase base pr onto main (_resolving submodule pointer conflicts_)";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });
      
      - name: Squash all PR commits 
        if: ${{ needs.init.outputs.mergeable != 'true' }}
        id: squash
        run: |
          set -euo pipefail
          git fetch origin ${{ needs.init.outputs.base_ref }}:refs/remotes/origin/${{ needs.init.outputs.base_ref }}
          BASE=$(git merge-base HEAD origin/${{ needs.init.outputs.base_ref }})

          MSGS=$(git log --reverse --pretty=format:"%s%b" "$BASE"..HEAD)

          SUBJECT="${{ needs.init.outputs.pr_title }}"
          BODY=$(echo "$MSGS" | tail -n +2)
          git reset --soft "$BASE"

          git commit -m "$SUBJECT" -m "$BODY"

      - name: Rebase onto base branch & resolve submodule conflicts
        if: ${{ needs.init.outputs.mergeable != 'true' && steps.squash.conclusion == 'success'}}
        run: |
          set -euo pipefail
          git checkout "${{ needs.init.outputs.head_ref }}"
          echo "‚è≥ Starting rebase onto ${{ needs.init.outputs.base_ref }} ..."
          git rebase "origin/${{ needs.init.outputs.base_ref }}" || echo "‚ö†Ô∏è Rebase paused ‚Äì conflicts detected"

          conflicted=$(git diff --name-only --diff-filter=U)
          submodule_paths=$(git config --file .gitmodules --get-regexp '^submodule\..*\.path' | awk '{print $2}')
          conflicted_submodules=""

          for sub in $submodule_paths; do
            if echo "$conflicted" | grep -qx "$sub"; then
              conflicted_submodules="${conflicted_submodules:+$conflicted_submodules }$sub"
            fi
          done

          if [ -n "$conflicted_submodules" ]; then
            echo "üîß Resolving submodule conflicts: $conflicted_submodules"
            for sub in $conflicted_submodules; do
              git add "$sub"
            done

            # Commit the resolution if anything was staged
            if ! git diff --cached --quiet; then
              git commit --no-edit
            fi
          fi

          git rebase --continue || echo "‚ö†Ô∏è Rebase still has non‚Äësubmodule conflicts ‚Äì manual resolution needed"

          echo "üöÄ Force‚Äëpushing rebased branch"
          git push --force-with-lease origin "${{ needs.init.outputs.head_ref }}"

      - name: Comment after Rebase
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n" + " ‚úÖ Rebase pushed successfully. \n";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Report job failure to PR comment
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
          STEP_STATUS: ${{ github.actions.step.status }}
          STEP_NAME: ${{ github.actions.step.name }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = Number(process.env.COMMENT_ID);
            const job = process.env.JOB_NAME;
            const stepStatus = process.env.STEP_STATUS;
            const stepName = process.env.STEP_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              comment_id: commentId
            });

            let failureMsg;
            let resolutionSteps;

            if (stepName === 'Bump submodules') {
              failureMsg = `‚ùå **Job \`${job}\` failed: Submodule bump failed**`;
              resolutionSteps = `
              Please check the submodule configuration and try again.
              `;
            } else if (stepName === 'Rebase to resolve submodule conflicts') {
              failureMsg = `‚ùå **Job \`${job}\` failed: Rebase failed**`;
              resolutionSteps = `
              If the rebase fails, it's likely due to merge conflicts in the base repository. Please manually resolve these conflicts and push the branch back to continue.
              Steps to resolve:
              1. Ensure that your local main is up-to-date with origin main. 
                - git checkout main 
                - git pull origin main
              2. Checkout the base branch: git checkout ${{needs.init.outputs.head_ref }}
              3. Pull the latest changes: git pull origin ${{needs.init.outputs.head_ref }}
              4. Merge the changes into your branch. git merge main 
              5. Commit the resolved changes: git commit -am 'Resolved merge conflicts'
              6. Push the updated branch: git push 
              `;
            } else {
              failureMsg = `‚ùå **Job \`${job}\` failed: Unknown step failed**`;
              resolutionSteps = `
              Please check the job logs for more information and try again.
              `;
            }

            const newBody = comment.body + "\n" + failureMsg + "\n" + resolutionSteps;

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody
            });

  merge-base-no-submodules:
    needs: create-submodule-json
    if: ${{ needs.create-submodule-json.outputs.submodules == '[]' }}
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Merge base PR (no submodules)
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });
  
  merge-base:
    needs: [bump-rebase-submodules, merge-base-no-submodules]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      needs.bump-rebase-submodules.result == 'success' &&
      needs.merge-base-no-submodules.result == 'skipped'
    steps:
      - name: Merge base PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });

            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n" + " ### **üöÄ (Step 6/6) Base PR merged successfully.** ### \n";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Report job failure to PR comment
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = Number(process.env.COMMENT_ID);
            const job = process.env.JOB_NAME;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId
            });

            const failureMsg = `‚ùå (Step 6/6)**Job \`${job}\` failed**\n The PR likely has merge conflicts. Please manually resolve them and push the changes to this branch. `;
            const newBody = comment.body + "\n" + failureMsg;

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody
            });
  