name: Merge Submodule Matrix + Base PR (on /mergeMat comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write
  actions: write

env:
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}
  GH_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  # ------------------------------------------------------------------
  # 1Ô∏è‚É£ Prepare list of submodules
  # ------------------------------------------------------------------
  detect-submodules:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/mergeMat' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      submodules: ${{ steps.collect.outputs.submodules }}
    steps:
      - name: Checkout base repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ env.CROSS_TOKEN }}

      - name: Collect submodules
        id: collect
        run: |
          SUBMODULES_JSON="[]"
          while IFS= read -r entry; do
            SUB_PATH=$(echo "$entry" | awk '{print $2}')
            SUB_URL=$(git config --file .gitmodules --get "submodule.${SUB_PATH}.url")

            if [[ "$SUB_URL" == git@github.com:* ]]; then
              SUB_REPO=${SUB_URL#git@github.com:}
            elif [[ "$SUB_URL" == https://github.com/* ]]; then
              SUB_REPO=${SUB_URL#https://github.com/}
            else
              echo "‚ùå Unsupported submodule URL: $SUB_URL"
              exit 1
            fi
            SUB_REPO=${SUB_REPO%.git}

            SUBMODULES_JSON=$(jq -c \
              --arg path "$SUB_PATH" \
              --arg repo "$SUB_REPO" \
              '. += [{"path": $path, "repo": $repo}]' <<< "$SUBMODULES_JSON")
          done < <(git config --file .gitmodules --get-regexp '^submodule\..*\.path$')

          echo "submodules=$SUBMODULES_JSON" >> $GITHUB_OUTPUT
          echo "‚úÖ Found submodules: $SUBMODULES_JSON"

  # ------------------------------------------------------------------
  # 2Ô∏è‚É£ Process each submodule in parallel (matrix)
  # ------------------------------------------------------------------
  process-submodules:
    needs: detect-submodules
    runs-on: ubuntu-latest
    strategy:
      matrix:
        submod: ${{ fromJson(needs.detect-submodules.outputs.submodules) }}
      max-parallel: 4   # tune concurrency
    outputs:
      result: ${{ steps.subproc.outputs.result }}
    steps:
      - name: Checkout base repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ env.CROSS_TOKEN }}

      - name: Get base PR metadata
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('base_ref', pr.base.ref);

      - name: Process submodule
        id: subproc
        env:
          CROSS_TOKEN: ${{ env.CROSS_TOKEN }}
          GH_TOKEN: ${{ secrets.WORKFLOWS }} 
          SUB_PATH: ${{ matrix.submod.path }}
          SUB_REPO: ${{ matrix.submod.repo }}
          HEAD_REF: ${{ steps.pr_info.outputs.head_ref }}
          BASE_REF: ${{ steps.pr_info.outputs.base_ref }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "üîé Processing $SUB_REPO at $SUB_PATH"

          # --------------------------------------------------------------
          # 1Ô∏è‚É£ Find a submodule PR whose head ref matches the base PR
          # --------------------------------------------------------------
          PR_NUM=$(gh api repos/$SUB_REPO/pulls \
            --jq ".[] | select(.head.ref==\"$HEAD_REF\") | .number" || true)

          if [[ -z "$PR_NUM" ]]; then
            echo "‚ö†Ô∏è No matching submodule PR found for $SUB_REPO ‚Äì skipping."
            echo "result=‚Ä¢ $SUB_REPO: no matching PR" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Found submodule PR #$PR_NUM"

          # --------------------------------------------------------------
          # 2Ô∏è‚É£ Squash‚Äëmerge the submodule PR
          # --------------------------------------------------------------
          # gh api -X PUT \
          #   -H "Accept: application/vnd.github+json" \
          #   repos/$SUB_REPO/pulls/$PR_NUM/merge \
          #   -f merge_method=squash \
          #   -f commit_title="chore(submod): merge $SUB_REPO #$PR_NUM" \
          #   -f commit_message="Squash‚Äëmerged submodule PR #$PR_NUM" \
          #   || { echo "‚ùå Merge failed for $SUB_REPO PR #$PR_NUM"; exit 1; }
          echo "üè∑Ô∏è THIS WOULD GET MERGED IM JUST TIRED OF OPENING NEW PRS üè∑Ô∏è"

          # --------------------------------------------------------------
          # 3Ô∏è‚É£ Bump the submodule pointer in the base repo
          # --------------------------------------------------------------
          # 1Ô∏è‚É£ Refresh submodule and get its latest commit SHA
          #    (uses the same branch name as the base PR's base ref, fallback to 'main')
          SUBMODULE_DEFAULT_BRANCH="${BASE_REF:-main}"
          git -C "$SUB_PATH" fetch origin
          SUBMODULE_SHA=$(git -C "$SUB_PATH" rev-parse "origin/${SUBMODULE_DEFAULT_BRANCH}")

          echo "where am i getting err"

          # 2Ô∏è‚É£ Get the tree SHA for the current head of the base PR
          BASE_TREE_SHA=$(gh api \
            repos/${REPO}/git/trees/${HEAD_REF} \
            -q .sha)

            echo "2 completed"

          # 3Ô∏è‚É£ Build a new tree that updates the submodule entry (gitlink mode 160000)
          #    Use --raw-field so the JSON array is sent un‚Äëescaped.
          SUB_TREE_PAYLOAD=$(jq -c -n \
            --arg path "$SUB_PATH" \
            --arg sha "$SUBMODULE_SHA" \
            '[{ "path": $path, "mode": "160000", "type": "commit", "sha": $sha }]')
          echo "$SUB_TREE_PAYLOAD" | jq .
          BUMP_TREE=$(gh api -X POST \
            "repos/${REPO}/git/trees" \
            -f base_tree="$BASE_TREE_SHA" \
            --raw-field tree="$SUB_TREE_PAYLOAD" \
            -q .sha)

          echo "3 i think its here"

          # 4Ô∏è‚É£ Create a commit that points to the new tree
          BUMP_COMMIT=$(gh api -X POST \
            repos/${REPO}/git/commits \
            -f message="chore(submod): bump $SUB_REPO to $SUBMODULE_SHA" \
            -f tree=$BUMP_TREE \
            -f parents='["'"$(gh api repos/${REPO}/git/refs/heads/${HEAD_REF} -q .object.sha)"'"]' \
            -q .sha)

          echo "4 completed"

          # 5Ô∏è‚É£ Move the branch tip to the new commit (no force‚Äëpush)
          gh api -X PATCH \
            repos/${REPO}/git/refs/heads/${HEAD_REF} \
            -f sha=$BUMP_COMMIT \
          echo "5"

          echo "result=‚Ä¢ $SUB_REPO: merged #$PR_NUM + bumped ‚úÖ" >> "$GITHUB_OUTPUT"

  # ------------------------------------------------------------------
  # 3Ô∏è‚É£ Merge base PR after all submodules succeed
  # ------------------------------------------------------------------
  merge-base:
    needs: [process-submodules]
    runs-on: ubuntu-latest
    steps:
      - name: Get base PR metadata
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('pr_number', pr.number);

      - name: Merge base PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const number = parseInt('${{ steps.pr_info.outputs.pr_number }}', 10);
            # await github.rest.pulls.merge({
            #   owner: context.repo.owner,
            #   repo: context.repo.repo,
            #   pull_number: number,
            #   merge_method: 'squash',
            #   commit_title: `chore(submods): squash merge #${number}`,
            #   commit_message: `Squash-merged base PR after submodule merges.`,
            # });
            echo "üè∑Ô∏è THIS BASE WOULD GET MERGED IM JUST TIRED OF OPENING NEW PRS üè∑Ô∏è"

  # ------------------------------------------------------------------
  # 4Ô∏è‚É£ Final comment (nicely formatted)
  # ------------------------------------------------------------------
  comment-result:
    needs: [process-submodules, merge-base]
    runs-on: ubuntu-latest
    steps:
      - name: Collect results
        id: collect
        run: |
          run: |
          # Write the multi‚Äëline output in a way the shell can parse safely
          echo "results<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n' "${{ join(needs.process-submodules.*.outputs.result, '\n') }}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Comment results
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            const results = `${{ steps.collect.outputs.results }}`;
            const body = [
              "Pull Request Merged ‚úÖ",
              "",
              "### Submodule Results",
              results,
              "",
              "### Base Repo",
              "‚Ä¢ Base PR merged successfully ‚úÖ"
            ].join("\n");
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body
            })
