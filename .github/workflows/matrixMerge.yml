name: Merge (on /merge comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write

env:
  RW_PAT: ${{ secrets.WORKFLOWS2 }} # Personal Access Token with RW access to repo contents, PRs
  MIN_REVIEWERS: 0

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  init:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      head_ref: ${{ steps.pr.outputs.head_ref }}
      base_ref: ${{ steps.pr.outputs.base_ref }}
      pr_number: ${{ steps.pr.outputs.pr_number }}
      pr_title: ${{ steps.pr.outputs.title }}
      mergeable: ${{ steps.pr.outputs.mergeable }}
      merged: ${{ steps.pr.outputs.merged }}
      mergeable_state: ${{ steps.pr.outputs.mergeable_state }}
      state: ${{ steps.pr.outputs.state }}
      submodules: ${{ steps.add-merged-flag.outputs.submodules }}
      unmerged_submodules: ${{ steps.add-merged-flag.outputs.unmerged }}
    steps:
      - name: Get BasePR details
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("pr_number", pr.data.number);
            core.setOutput("title", pr.data.title);
            core.setOutput("body", pr.data.body);
            core.setOutput("mergeable", pr.data.mergeable);
            core.setOutput("merged", pr.data.merged);
            core.setOutput("mergeable_state", pr.data.mergeable_state);
            core.setOutput("state", pr.data.state);
            if (pr.data.merged){
              core.notice("Workflow stopped because the base PR is already merged.");
              return;
            }

      - name: Comment on init
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            if(steps.pr.outputs.merged){
              const appendMsg = "\n ## Nothing to merge. ##"
            }
            else{
              const appendMsg = "\n # üîß Merge workflow started #\n**_(Step 1/6)_** Initializing "
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });
      
      - name: Confirm Approvals for base PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const latestByUser = {};
            for (const review of reviews) {
              latestByUser[review.user.login] = review.state;
            }
            const approvedUsers = Object.values(latestByUser).filter(s => s === 'APPROVED');
            const approvalCount = approvedUsers.length;

            console.log(`‚úÖ Current approvals: ${approvalCount}/${process.env.MIN_REVIEWERS}`);

            if (approvalCount < parseInt(process.env.MIN_REVIEWERS || '0', 10)) {
              core.setFailed(`‚ùå Not enough approvals (${approvalCount}/${process.env.MIN_REVIEWERS})`);
              return;
            } else {
              console.log('‚úÖ Required approvals met.');
            }
      
      - name: Comment on pr data success
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const appendMsg = "\n - Successfully got PR data.\n - Starting to detect submodules from comment. ";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Detect submodules from comment and populate Json
        id: submod
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const analysis = comments
              .filter(c => /üîç Submodule Analysis Results/.test(c.body))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

            if (!analysis) {
              core.warning("‚ö†Ô∏è No 'Submodule Analysis Results' comment found.");
              core.setOutput('submodules', '[]');
              return;
            }
            const submodules = [];
            const text = analysis.body;
            const blocks = text.split(/(?=####\s*[‚úÖ‚è≥üîÑ‚ùå]\s*`)/g).filter(b => /PR:/i.test(b));

            for (const block of blocks) {
              // If the markdown for the comment generated by the app changes, everything will break
              const nameMatch = block.match(/####\s*[‚úÖ‚è≥üîÑ‚ùå]\s*`([^`]+)`/);
              const branchMatch = block.match(/\*\*Branch:\*\*\s*`([^`]+)`/);
              const statusMatch = block.match(/\*\*Status:\*\*\s*\*\*([^*]+)\*\*/);
              const prMatch = block.match(/\[?#(\d+)\]\((https:\/\/github\.com\/[^)]+)\)/);
              const approvalsMatch = block.match(/\*\*Approvals:\*\*\s*([\d/]+)/);
              const changeRequestsMatch = block.match(/\*\*Change Requests:\*\*\s*(\d+)/);

              if (!nameMatch || !prMatch) {
                core.warning(`‚ö†Ô∏è Skipping malformed submodule block:\n${block}`);
                continue;
              }

              const name = nameMatch[1].trim();
              const branch = branchMatch ? branchMatch[1].trim() : null;
              const status = statusMatch ? statusMatch[1].trim() : null;
              const pr_number = parseInt(prMatch[1], 10);
              const pr_url = prMatch[2];
              const approvals = approvalsMatch ? approvalsMatch[1] : null;
              const change_requests = changeRequestsMatch ? changeRequestsMatch[1] : null;
              const [, org, repo] = pr_url.match(/github\.com\/([^/]+)\/([^/]+)\//) || [];

              submodules.push({
                name,
                branch,
                status,
                pr_number,
                change_requests,
                repo: repo || name,
                org: org || context.repo.owner,
                url: pr_url,
              });
            }

            const json = JSON.stringify(submodules, null, 2);
            core.info("üì¶ Extracted submodule JSON:");
            core.info(json);
            core.setOutput('submodules', json);

      - name: Comment on submodule precheck
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const appendMsg = "\n - Starting to Pre-check submodules ";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Pre-check all Submodules
        id: add-merged-flag
        uses: actions/github-script@v7
        env:
          SUBMODULES_JSON: ${{ steps.submod.outputs.submodules }}
          RW_PAT: ${{ env.RW_PAT }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const submods = JSON.parse(process.env.SUBMODULES_JSON);
            const enriched = [];

            for (const sub of submods) {
              if (!sub.pr_number) {
                enriched.push({ ...sub, merged: true });
                continue;
              }

              const url = new URL(sub.url);
              const [owner, repo] = url.pathname.replace(/^\/|\.git$/g, '').split('/');

              try {
                const { data: prInfo } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: sub.pr_number,
                });

                const isMerged = prInfo.state === 'closed' && prInfo.merged === true;
                const isMergeableClean = prInfo.mergeable_state === 'clean';

                if (!isMergeableClean && !isMerged) {
                  core.setFailed(`‚ùå Submodule ${sub.name} PR #${sub.pr_number} is not mergeable (state=${prInfo.mergeable_state})`);
                  return;
                }

                enriched.push({ ...sub, merged: isMerged, mergeable_state: prInfo.mergeable_state });

                core.info(`üîé Submodule ${sub.name} PR #${sub.pr_number} merged=${isMerged}, mergeable_state=${prInfo.mergeable_state}`);

                // Fetch reviews
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner,
                  repo,
                  pull_number: sub.pr_number,
                });

                const approvedReviews = reviews.filter(r => r.state === 'APPROVED');
                if (approvedReviews.length < parseInt(process.env.MIN_REVIEWERS, 10)) {
                  core.setFailed(`‚ùå Submodule ${sub.name} PR #${sub.pr_number} does not have enough approvals.`);
                  return;
                }

                core.info(`‚úÖ Submodule ${sub.name} has ${approvedReviews.length} approved review(s).`);

              } catch (err) {
                core.warning(`‚ùóÔ∏è Could not fetch PR #${sub.pr_number} for ${owner}/${repo}: ${err.message}`);
                enriched.push({ ...sub, merged: false, mergeable_state: 'unknown' });
                return;
              }
            }

            const enrichedJson = JSON.stringify(enriched, null, 2);
            core.info("Submodule JSON:");
            core.info(enrichedJson);
            core.setOutput('submodules', enrichedJson);

            // Filter only unmerged submodules
            const unmerged = enriched.filter(s => s.merged === false);
            const unmergedJson = JSON.stringify(unmerged, null, 2);
            core.info("‚ùå Unmerged submodules:");
            core.info(unmergedJson);
            core.setOutput('unmerged', unmergedJson);

      - name: Comment after init
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });

            let appendMsg = "\n - Submodules have approvals and no conflicts\n";
            const mergeableState = "${{ steps.pr.outputs.mergeable_state }}";
            const prState = "${{ steps.pr.outputs.state }}";
            const noSubmod = "${{ steps.add-merged-flag.outputs.unmerged }}" === "[]";
            const skip = mergeableState === "dirty" && prState === "open";
            if(skip && !noSubmod){
              appendMsg = appendMsg + "\n**_(Step 2/6)_** Skipping base repo pre-check. No conflicts detected.\n\n**_(Step 3/6)_** Starting to merge submodules."
            }
            if(skip && !noSubmod){
              appendMsg = appendMsg + "\n**_(Step 2/6)_** Pre-checking base repo for approvals and conflicts. "
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Comment on Failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const newBody = comment.body + "\n\n" + "‚ùå FAILED to initialize: base pr does not have enough approvals OR could not create and pre-check submodule array";
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  check-base-conflicts:
    needs: [init]
    if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      conflicts: ${{ steps.detect-conflicts.outputs.conflicts }}
    steps:
      - name: Checkout PR branch
        if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
        uses: actions/checkout@v4
        with:
          token:       ${{ env.RW_PAT }}
          ref:         ${{ needs.init.outputs.base_ref }}
          fetch-depth: 0
          submodules:  false

      - name: Detect conflicts (dry‚Äërun merge)
        if: ${{ needs.init.outputs.mergeable_state == 'dirty' && needs.init.outputs.state == 'open' }}
        id: detect-conflicts
        uses: actions/github-script@v7
        env:
          BASE: ${{ needs.init.outputs.base_ref }}  
          PR_BRANCH: ${{ needs.init.outputs.head_ref }}
          TOKEN: ${{ env.RW_PAT }}
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');

            const run = (cmd, opts = {}) => {
              const stdio = opts.stdio ?? 'pipe';
              const encoding = opts.encoding ?? 'utf8';
              return execSync(cmd, { stdio, encoding }).trim();
            };

            run('git config --global user.name "github-actions[bot]"');
            run('git config --global user.email "github-actions[bot]@users.noreply.github.com"');

            try {
              run(`git fetch origin "${process.env.PR_BRANCH}"`);
            } catch (e) {
              core.setFailed(`‚ùå Failed to fetch base branch ${process.env.PR_BRANCH}: ${e.message}`);
              process.exit(1);
            }

            // Parse submodule paths from .gitmodules 
            let submodulePaths = [];
            if (fs.existsSync('.gitmodules')) {
              const gm = fs.readFileSync('.gitmodules', 'utf8');
              const matches = [...gm.matchAll(/path\s*=\s*(.+)/g)];
              submodulePaths = matches.map(m => m[1].trim());
              console.log(`üì¶ Found submodules: ${submodulePaths.join(', ')}`);
            } else {
              core.setFailed('‚ö†Ô∏è No .gitmodules file found');
              process.exit(1);
            }

            try {
              run(`git merge --no-commit --no-ff "origin/${process.env.PR_BRANCH}"`, { stdio: 'inherit' });
            } catch (_) {
              // merge returned non‚Äëzero ‚Üí likely conflicts - allow it to fall through
            }

            let conflictList = '';
            try {
              conflictList = run('git diff --name-only --diff-filter=U');
            } catch (_) {
              // No conflicted files ‚Üí git diff returns nothing, keep empty string
            }

            if (!conflictList) {
              console.log('!! No conflicted files ‚Äì this is unexpected when mergeable_state was ‚Äúdirty‚Äù.');
              core.setOutput('conflict_files', '[]');  
            } else {
              console.log('‚ö°Ô∏è Conflicted files (plain‚Äëtext):');
              console.log(conflictList);

              const conflicts = conflictList
                .split('\n')
                .filter(Boolean)
                .map(f => f.trim());

              console.log('‚ö°Ô∏è Conflicted files:', conflicts);

              // Determine if any conflict is *not* inside a submodule path
              const nonSubmoduleConflicts = conflicts.filter(f => {
                return !submodulePaths.some(sub => f === sub || f.startsWith(`${sub}/`));
              });

              const json = JSON.stringify(conflicts);
              core.setOutput('conflict_files', json);
              
              run('git merge --abort || true');

              if (nonSubmoduleConflicts.length > 0) {
                console.log('‚ùå Non-submodule conflicts detected:');
                console.log(nonSubmoduleConflicts.join('\n'));
                core.setFailed('Conflicts found in non-submodule paths.');
                return;
              } else {
                console.log('‚úÖ Only submodule conflicts detected ‚Äî not failing.');
              }
            }

      - name: Comment on Success
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            let newBody = comment.body + "\n Base repository has no meaningful conflicts.";
            const unmergedSubmodules = "${{ needs.init.outputs.unmerged_submodules }}";
            const skip = unmergedSubmodules !== "[]";
            if(skip){
              newBody += "\n" + "**_(Step 3/6)_** Starting to merge submodules.";
            }
            else{
              newBody += "\n" + "**_(Step 3/6)_** Skipping submodule merge. All submodules are already merged";
            }
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Comment on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
          CONFLICT_FILES: ${{ steps.detect-conflicts.outputs.conflict_files }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const conflicts = process.env.CONFLICT_FILES || '[]';
            const parsed = JSON.parse(conflicts);
            const conflictSummary =
              parsed.length > 0
                ? parsed.map(f => `‚Ä¢ \`${f}\``).join('\n')
                : '_No conflicted files listed._';
            const failureMsg = [
              `‚ùå **Job \`${job}\` failed**`,
              'This base PR has conflicts in **non-submodule paths**.',
              'Please manually fix them and push this branch again.',
              '',
              '**Conflicted files:**',
              conflictSummary
            ].join('\n');

            const appendMsg = "\n"+ failureMsg;
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  merge-submodules:
    needs: [ init ]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      needs.init.result == 'success' &&
      needs.init.outputs.unmerged_submodules != '[]' && 
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      needs.init.outputs.merged == 'false'
    env:
      GITHUB_API_URL: https://github.com/api/v3
    strategy:
      matrix:
        submod: ${{ fromJson(needs.init.outputs.unmerged_submodules) }}
      max-parallel: 4
      fail-fast: true
    steps:
      - name: Merge submodule PR
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const sub = ${{ toJson(matrix.submod) }};
            console.info(`üîé Processing submodule: ${JSON.stringify(sub)}`);

            const url = new URL(sub.url);
            const [owner, repo] = url.pathname.replace(/^\//,'').replace(/\.git$/,'').split('/');
            const pr = sub.pr_number;
            const { data: prInfo } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
            const res = await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: pr,
              merge_method: "squash",
            });

      - name: Comment on failure (Submodule merge)
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const failureMsg = `‚ùå **Job \`${job}\` failed**`;
            const appendMsg = "\n"+ failureMsg;
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  aggregate:
    needs: [merge-submodules,check-base-conflicts, init]
    runs-on: ubuntu-latest
    timeout-minutes: 1
    if: >-
      always() &&
      needs.init.result == 'success' &&
      (needs.check-base-conflicts.result == 'success' || needs.check-base-conflicts.result == 'skipped') &&
      (needs.merge-submodules.result == 'success' || needs.merge-submodules.result == 'skipped') && 
      (needs.init.outputs.submodules != '[]') &&
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/merge' &&
      needs.init.outputs.merged == 'false'
    steps:
      - name: Comment after Aggregate 
        uses: actions/github-script@v7
        env:
          SUBMODULE_RESULT: ${{ needs.merge-submodules.result }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            let newBody = comment.body + "\n";
            const result = process.env.SUBMODULE_RESULT;
            if( result == "skipped")
            {
              newBody = newBody + "\n\n**_(Step 4/6)_** Beginning to bump submodules for base PR branch.";
            }
            else
            {
              newBody = newBody + " - All submodules merged.\n\n**_(Step 4/6)_** Beginning to bump submodules for base PR branch.";
            }
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  bump-rebase-submodules:
    needs: [aggregate, check-base-conflicts, init]
    if: >-
      always() &&
      needs.aggregate.result == 'success' &&
      ( needs.check-base-conflicts.result == 'success' || needs.check-base-conflicts.result == 'skipped') &&
      needs.init.result == 'success' &&
      needs.init.outputs.submodules != '[]' &&
      needs.init.outputs.merged == 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token: ${{ env.RW_PAT }}
          fetch-depth: 0
          ref: ${{ needs.init.outputs.head_ref }}
          submodules: false

      - name: Authenticate submodules
        run: |
          git config --global url."https://${{ env.RW_PAT }}:x-oauth-basic@github.com/".insteadOf "https://github.com/"
          git submodule sync --recursive
          git submodule update --init --recursive
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump submodules
        uses: actions/github-script@v7
        env:
          SUBMODULES: ${{ needs.init.outputs.submodules }}
          TOKEN: ${{ env.RW_PAT }}
          BRANCH: ${{ needs.init.outputs.head_ref }}
        with:
          script: |
            const { execSync } = require('child_process');
            const submoduleJson = JSON.parse(process.env.SUBMODULES);
            let changed = false;

            for (const sub of submoduleJson) {
              const path = sub.name;
              const org = sub.org;
              const branch = sub.branch;
              const urlWithToken = `https://${process.env.TOKEN}@github.com/${org}/${sub.repo}.git`;

              console.log(`üîß Updating submodule ${sub.repo} at ${path}`);

              execSync(`git -C ${path} fetch origin ${branch}:${branch}`, { stdio: 'inherit' });

              const latestCommit = execSync(
                `git ls-remote ${urlWithToken} refs/heads/${branch} | awk '{print $1}'`,
                { encoding: 'utf8' }
              ).trim();

              const currentCommit = execSync(
                `git -C ${path} rev-parse HEAD`,
                { encoding: 'utf8' }
              ).trim();

              if (currentCommit !== latestCommit) {
                console.log(`‚ö†Ô∏è  ${sub.name} is outdated. Resetting to ${latestCommit}`);
                execSync(`git -C ${path} reset --hard ${latestCommit}`, { stdio: 'inherit' });
                execSync(`git add ${path}`);
                changed = true;
              } else {
                console.log(`‚úÖ ${sub.name} is already up-to-date`);
              }
            }

            if (changed) {
              execSync(`git commit -m "Bump submodules to latest default branch"`);
              execSync(`git push origin ${process.env.BRANCH}`);
            } else {
              console.log('‚úÖ All submodules already up-to-date.');
            }

      - name: Comment after Bump
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            let appendMsg = "\n - Submodules bumped \n\n";
            const mergeable = "${{ needs.init.outputs.mergeable }}" === "true";
            if (mergeable) {
              appendMsg = appendMsg + "**_(Step 5/6)_** Skipping suqash and rebase. (No conflicts detected)\n\n**_(Step 6/6)_** Starting to merge base."
            }
            else {
              appendMsg = appendMsg + "**_(Step 5/6)_** Starting to auto-resolve submodule conflicts with squash and rebase."
            }
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Squash all PR commits 
        if: ${{ needs.init.outputs.mergeable != 'true' }}
        id: squash
        run: |
          set -euo pipefail
          git fetch origin ${{ needs.init.outputs.base_ref }}:refs/remotes/origin/${{ needs.init.outputs.base_ref }}
          BASE=$(git merge-base HEAD origin/${{ needs.init.outputs.base_ref }})

          MSGS=$(git log --reverse --pretty=format:"%s%b" "$BASE"..HEAD)

          SUBJECT="${{ needs.init.outputs.pr_title }}"
          BODY=$(echo "$MSGS" | tail -n +2)
          git reset --soft "$BASE"

          git commit -m "$SUBJECT" -m "$BODY"

      - name: Rebase onto base branch & resolve submodule conflicts
        if: ${{ needs.init.outputs.mergeable != 'true' && steps.squash.conclusion == 'success'}}
        run: |
          set -euo pipefail
          git checkout "${{ needs.init.outputs.head_ref }}"
          echo "‚è≥ Starting rebase onto ${{ needs.init.outputs.base_ref }} ..."
          git rebase "origin/${{ needs.init.outputs.base_ref }}" || echo "‚ö†Ô∏è Rebase paused ‚Äì conflicts detected"

          conflicted=$(git diff --name-only --diff-filter=U)
          submodule_paths=$(git config --file .gitmodules --get-regexp '^submodule\..*\.path' | awk '{print $2}')
          conflicted_submodules=""

          for sub in $submodule_paths; do
            if echo "$conflicted" | grep -qx "$sub"; then
              conflicted_submodules="${conflicted_submodules:+$conflicted_submodules }$sub"
            fi
          done

          if [ -n "$conflicted_submodules" ]; then
            echo "üîß Resolving submodule conflicts: $conflicted_submodules"
            for sub in $conflicted_submodules; do
              git add "$sub"
            done

            # Commit the resolution if anything was staged
            if ! git diff --cached --quiet; then
              git commit --no-edit
            fi
          fi

          git rebase --continue || echo "‚ö†Ô∏è Rebase still has non‚Äësubmodule conflicts ‚Äì manual resolution needed"

          echo "üöÄ Force‚Äëpushing rebased branch"
          git push --force-with-lease origin "${{ needs.init.outputs.head_ref }}"

      - name: Comment after Rebase
        uses: actions/github-script@v7
        if: ${{ needs.init.outputs.mergeable != 'true' }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const appendMsg = "\n - Rebase pushed successfully. \n\n**_(Step 6/6)_** Starting to merge base.";
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

      - name: Comment on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
          STEP_STATUS: ${{ github.actions.step.status }}
          STEP_NAME: ${{ github.actions.step.name }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const job = process.env.JOB_NAME;
            const stepStatus = process.env.STEP_STATUS;
            const stepName = process.env.STEP_NAME;
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            
            let failureMsg;
            let resolutionSteps;
            if (stepName === 'Bump submodules') {
              failureMsg = `‚ùå **Job \`${job}\` failed: Submodule bump failed**`;
              resolutionSteps = `
              Please check the submodule configuration and try again.
              `;
            } else if (stepName === 'Rebase to resolve submodule conflicts') {
              failureMsg = `‚ùå **Job \`${job}\` failed: Rebase failed**`;
              resolutionSteps = `
              If the rebase fails, it's likely due to merge conflicts in the base repository. Please manually resolve these conflicts and push the branch back to continue.`;
            } else {
              failureMsg = `‚ùå **Job \`${job}\` failed: Unknown step failed**`;
              resolutionSteps = `
              Please check the job logs for more information and try again.
              `;
            }
            const appendMsg = "\n"+ failureMsg + "\n" + resolutionSteps;
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });

  
  merge-base:
    needs: [bump-rebase-submodules, init]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: >-
      always() &&
      needs.bump-rebase-submodules.result == 'success' || (needs.init.outputs.submodules == '[]') &&
      needs.init.outputs.merged == 'false'
    steps:
      - name: Merge base PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const prNumber = context.issue.number;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });


      - name: Comment on success
        if: ${{ success() }}
        uses: actions/github-script@v7
        with:
          script: |
            const commentId = context.payload.comment.id;
              const { data: comment } = await github.rest.issues.getComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
              });

              const appendMsg = "\n ### **üöÄ Base PR merged successfully.** ### \n";
              const newBody = comment.body + appendMsg;
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
                body: newBody,
              });

      - name: Comment on failure
        if: ${{ failure() }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ github.event.comment.id }}
          JOB_NAME: ${{ github.job }}
        with:
          github-token: ${{ env.RW_PAT }}
          script: |
            const commentId = context.payload.comment.id;
            const { data: comment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
            });
            const failureMsg = `‚ùå **Job \`${job}\` failed**\n The PR likely has merge conflicts. Please manually resolve them and push the changes to this branch. `;
            const appendMsg = "\n"+ failureMsg;
            const newBody = comment.body + appendMsg;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: newBody,
            });
