name: Merge Submodule Matrix + Base PR (on /mergeMat comment)

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: write
  actions: write

env:
  CROSS_TOKEN: ${{ secrets.WORKFLOWS }}
  GH_TOKEN: ${{ secrets.WORKFLOWS }}

jobs:
  # ------------------------------------------------------------------
  # 1Ô∏è‚É£ Prepare list of submodules
  # ------------------------------------------------------------------
  detect-submodules:
    if: |
      github.event.issue.pull_request != null &&
      github.event.comment.body == '/mergeMat' &&
      github.event.comment.user.type != 'Bot'
    runs-on: ubuntu-latest
    outputs:
      submodules: ${{ steps.collect.outputs.submodules }}
    steps:
      - name: Checkout base repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ env.CROSS_TOKEN }}

      - name: Collect submodules
        id: collect
        run: |
          SUBMODULES_JSON="[]"
          while IFS= read -r entry; do
            SUB_PATH=$(echo "$entry" | awk '{print $2}')
            SUB_URL=$(git config --file .gitmodules --get "submodule.${SUB_PATH}.url")

            if [[ "$SUB_URL" == git@github.com:* ]]; then
              SUB_REPO=${SUB_URL#git@github.com:}
            elif [[ "$SUB_URL" == https://github.com/* ]]; then
              SUB_REPO=${SUB_URL#https://github.com/}
            else
              echo "‚ùå Unsupported submodule URL: $SUB_URL"
              exit 1
            fi
            SUB_REPO=${SUB_REPO%.git}

            SUBMODULES_JSON=$(jq -c \
              --arg path "$SUB_PATH" \
              --arg repo "$SUB_REPO" \
              '. += [{"path": $path, "repo": $repo}]' <<< "$SUBMODULES_JSON")
          done < <(git config --file .gitmodules --get-regexp '^submodule\..*\.path$')

          echo "submodules=$SUBMODULES_JSON" >> $GITHUB_OUTPUT
          echo "‚úÖ Found submodules: $SUBMODULES_JSON"

  # ------------------------------------------------------------------
  # 2Ô∏è‚É£ Process each submodule in parallel (matrix)
  # ------------------------------------------------------------------
  process-submodules:
    needs: detect-submodules
    runs-on: ubuntu-latest
    strategy:
      matrix:
        submod: ${{ fromJson(needs.detect-submodules.outputs.submodules) }}
      max-parallel: 4   # tune concurrency
    outputs:
      result: ${{ steps.subproc.outputs.result }}
    steps:
      - name: Checkout base repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ env.CROSS_TOKEN }}

      - name: Get base PR metadata
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('base_ref', pr.base.ref);

      - name: Process submodule
        id: subproc
        env:
          CROSS_TOKEN: ${{ env.CROSS_TOKEN }}
          GH_TOKEN: ${{ secrets.WORKFLOWS }} 
          SUB_PATH: ${{ matrix.submod.path }}
          SUB_REPO: ${{ matrix.submod.repo }}
          HEAD_REF: ${{ steps.pr_info.outputs.head_ref }}
          BASE_REF: ${{ steps.pr_info.outputs.base_ref }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "üîé Processing $SUB_REPO at $SUB_PATH"

          # --------------------------------------------------------------
          # 1Ô∏è‚É£ Find a submodule PR whose head ref matches the base PR
          # --------------------------------------------------------------
          PR_NUM=$(gh api repos/$SUB_REPO/pulls \
            --jq ".[] | select(.head.ref==\"$HEAD_REF\") | .number" || true)

          if [[ -z "$PR_NUM" ]]; then
            echo "‚ö†Ô∏è No matching submodule PR found for $SUB_REPO ‚Äì skipping."
            echo "result=‚Ä¢ $SUB_REPO: no matching PR" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "‚úÖ Found submodule PR #$PR_NUM"

          # --------------------------------------------------------------
          # 2Ô∏è‚É£ Squash‚Äëmerge the submodule PR
          # --------------------------------------------------------------
          # gh api -X PUT \
          #   -H "Accept: application/vnd.github+json" \
          #   repos/$SUB_REPO/pulls/$PR_NUM/merge \
          #   -f merge_method=squash \
          #   -f commit_title="chore(submod): merge $SUB_REPO #$PR_NUM" \
          #   -f commit_message="Squash‚Äëmerged submodule PR #$PR_NUM" \
          #   || { echo "‚ùå Merge failed for $SUB_REPO PR #$PR_NUM"; exit 1; }
          echo "üè∑Ô∏è THIS WOULD GET MERGED IM JUST TIRED OF OPENING NEW PRS üè∑Ô∏è"

          # --------------------------------------------------------------
          # 3Ô∏è‚É£ Bump the submodule pointer in the base repo safely
          # --------------------------------------------------------------
          git fetch origin "$HEAD_REF"
          git checkout -B "$HEAD_REF" "origin/$HEAD_REF"
          git submodule update --init "$SUB_PATH"

          # Fetch latest commit from the submodule's default branch
          SUBMODULE_DEFAULT_BRANCH="${BASE_REF:-main}"
          git -C "$SUB_PATH" fetch origin "$SUBMODULE_DEFAULT_BRANCH"
          SUBMODULE_SHA=$(git -C "$SUB_PATH" rev-parse "origin/$SUBMODULE_DEFAULT_BRANCH")
          echo "Latest submodule SHA: $SUBMODULE_SHA"

          # Update the submodule pointer on the PR branch
          git add "$SUB_PATH"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Commit only if there are changes
          if git diff --cached --quiet; then
            echo "No changes in submodule pointer; skipping commit."
          else
            git commit -m "chore(submod): bump $SUB_REPO to $SUBMODULE_SHA"
            # Push safely without force
            git push "https://${CROSS_TOKEN}@github.com/$REPO.git" "$HEAD_REF"
          fi

          RESULT="‚Ä¢ $SUB_REPO: merged #$PR_NUM + bumped ‚úÖ"


  # ------------------------------------------------------------------
  # 3Ô∏è‚É£ Merge base PR after all submodules succeed
  # ------------------------------------------------------------------
  merge-base:
    needs: [process-submodules]
    runs-on: ubuntu-latest
    steps:
      - name: Get base PR metadata
        id: pr_info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            core.setOutput('pr_number', pr.number);

      - name: Merge base PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const number = parseInt('${{ steps.pr_info.outputs.pr_number }}', 10);
            # await github.rest.pulls.merge({
            #   owner: context.repo.owner,
            #   repo: context.repo.repo,
            #   pull_number: number,
            #   merge_method: 'squash',
            #   commit_title: `chore(submods): squash merge #${number}`,
            #   commit_message: `Squash-merged base PR after submodule merges.`,
            # });
            echo "üè∑Ô∏è THIS BASE WOULD GET MERGED IM JUST TIRED OF OPENING NEW PRS üè∑Ô∏è"

  # ------------------------------------------------------------------
  # 4Ô∏è‚É£ Final comment (nicely formatted)
  # ------------------------------------------------------------------
  comment-result:
    needs: [process-submodules, merge-base]
    runs-on: ubuntu-latest
    steps:
      - name: Collect results
        id: collect
        run: |
          run: |
          # Write the multi‚Äëline output in a way the shell can parse safely
          echo "results<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n' "${{ join(needs.process-submodules.*.outputs.result, '\n') }}" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Comment results
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commentId = context.payload.comment.id;
            const results = `${{ steps.collect.outputs.results }}`;
            const body = [
              "Pull Request Merged ‚úÖ",
              "",
              "### Submodule Results",
              results,
              "",
              "### Base Repo",
              "‚Ä¢ Base PR merged successfully ‚úÖ"
            ].join("\n");
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body
            })
