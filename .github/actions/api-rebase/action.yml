name: API Rebase PR
description: "Rebase a PR branch on top of its target branch using only the GitHub API"

inputs:
  owner:
    description: 'Organization or user'
    required: true
    type: string
  repo:
    description: 'Repository'
    required: true
    type: string
  pr_number:
    description: "PR number to rebase"
    required: true
    type: number
  token:
    description: "GitHub token"
    required: true

outputs:
  rebase_result:
    description: "Result of the rebase operation (success, skipped, or failed)"
  rebase_needed:
    description: "Whether rebase was needed"

runs:
  using: "composite"
  steps:
    - name: Rebase PR via API
      id: rebase
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const prNumber = parseInt("${{ inputs.pr_number }}");
          const owner = "${{ inputs.owner }}";
          const repo = "${{ inputs.repo }}";

          // Get PR info
          const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
          const prBranch = pr.data.head.ref;
          const baseBranch = pr.data.base.ref;

          core.info(`PR #${prNumber} branch: ${prBranch}`);
          core.info(`Target branch: ${baseBranch}`);

          // Get all commits in PR branch
          const { data: prCommits } = await github.rest.pulls.listCommits({ owner, repo, pull_number: prNumber });

          if (prCommits.length === 0) {
            core.setOutput("rebase_needed", "false");
            core.setOutput("rebase_result", "skipped");
            core.info("PR has no commits; skipping rebase.");
            return;
          }

          // Use compareCommits to check if rebase is needed
          const comparison = await github.rest.repos.compareCommits({
            owner,
            repo,
            base: baseBranch,
            head: prBranch
          });

          if (comparison.data.status === "identical" || comparison.data.status === "behind") {
            core.setOutput("rebase_needed", "false");
            core.setOutput("rebase_result", "skipped");
            core.info(`PR branch is already up-to-date with ${baseBranch}; skipping rebase.`);
            return;
          }

          core.info(`PR branch needs rebasing (status: ${comparison.data.status}).`);

          // Get latest commit SHA of the target branch
          const { data: baseRef } = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
          let parentSha = baseRef.object.sha;
          let newCommitSha;

          for (const commit of prCommits) {
            // Get commit tree
            const { data: commitData } = await github.rest.git.getCommit({ owner, repo, commit_sha: commit.sha });

            // Create a new commit on top of the current parent
            const { data: newCommit } = await github.rest.git.createCommit({
              owner,
              repo,
              message: commit.commit.message,
              tree: commitData.tree.sha,
              parents: [parentSha],
              author: {
                name: commit.commit.author.name,
                email: commit.commit.author.email,
                date: commit.commit.author.date
              },
              committer: {
                name: commit.commit.committer.name,
                email: commit.commit.committer.email,
                date: commit.commit.committer.date
              }
            });

            parentSha = newCommit.sha;
            newCommitSha = newCommit.sha;
          }

          // Update PR branch ref to point to the new top commit
          await github.rest.git.updateRef({
            owner,
            repo,
            ref: `heads/${prBranch}`,
            sha: newCommitSha,
            force: true
          });

          core.info(`Rebase completed. PR branch ${prBranch} is now based on ${baseBranch}`);
          core.setOutput("rebase_result", "success");
          core.setOutput("rebase_needed", "true");
